<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写给亚瑟的一封信</title>
    <url>/2020/09/18/AletterToArthur/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=78171705&bvid=BV1TJ411i7u9&cid=133749242&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>&emsp;&emsp;我偶尔还是会在西部的荒野疾驰，去听听森林的鸟鸣，去和那该死的灰熊相扑，去拜访一下你以前的老友，少了你的西部，少了点狂野味道</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4280.jpg" width=100%/>

<p>&emsp;&emsp;以前和你疾驰在西部的时候那得多狂野，在瓦伦丁酒吧那次枪战，可谓是一举成名啊杀的人可以排满整个瓦伦丁的铁路，抢的马可以堆满我们营地的那片草原了瓦伦丁的邮局甚至都不敢贴我们俩的悬赏名单，觊觎我们项上人头的赏金猎人可以从黑水镇排到安妮斯堡，可就是没人敢过来惹咱俩，毕竟你的死亡之眼可不是徒有虚名的，甚至于到了罗兹，咱们还特意跑回去瓦伦丁的银行，和比尔、凯伦、蓝尼他们狠狠地抢了一波，想起来那倒是痛快，毕竟谁能想到这居然是这段时间乃至以后最成功的一次抢银行，后来被赶到了罗兹，却被那该死的格雷家族和布雷斯维特家族利用，我们是谁？单凭神枪手—亚瑟摩根，你的项上人头就值 5000 美金，更何况还有我在，结果那自然是罗兹镇的格雷家族横尸遍野以及那让他们引以为傲的布雷斯维特庄园被烧成灰烬，</p>
<p>&emsp;&emsp;但是逃亡的日子也总是不好过，尤其是西恩死后和小杰克被抢走后，那日子愈发的紧张了不过我们起码到了个不错的居所，你曾经的居所，一个可以遮风挡雨的地方，从黑水镇以后达奇确实是变了，大家也都变得紧张起来当小杰克回来时，他那句：这是我经历过最快乐的时光了，着实刺疼你和约翰看得出约翰和你都露出难堪的脸色，一群亡命之徒带着一个孩子，算什么亡命之徒，对吧你们想要着最为平静的生活，而达奇却依旧在幻想他的美好世界，直到被削了的脑袋的基兰被送回营地时，我们才意识到我们结下的梁子和麻烦有多少</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4WvT.jpg" width=100%/>

<p>&emsp;&emsp;可那达奇被那该死的勃朗特洗了脑，被忽悠着抢了座分文不值的驿站，而后我们又在抢银行时被那平克顿侦探截了胡，何西亚和蓝尼就这样永久离开了我们。再然后你就和我们这群人就这样走散了而等到你们回来时，你的脸色就不太好了。而自打你从医生那回来，你就告诉我，你最近时常能梦到一匹鹿，在静谧的森林里的一头鹿</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4gCq.jpg" width=100%/>

<p>&emsp;&emsp;我知道的，我早该知道，是肺结核，那该死的唐斯一家，那该死的放债人，尤其是那该死的西部幻想家，这他妈都做了多少事，总是不切实际地让我们干着干那，你这身体无论如何都会吃不消的。我说再去西部狂野一把，去狩猎，去抢银行，可是你却说算了算了，帮派还有那么多不安稳的人接着帮达奇干起了的肮脏的勾当，你还是相信着他的美梦，只是没那么蠢了后来你终于醒了看来是被那该死的唐斯太太给劝醒了也不知道该不该谢谢这位唐斯太太最后的那段时间，你简直换了个人，但又还是那个亚瑟以往对达奇言听计从的亚瑟背着他救出了约翰、飞鹰，以往视金钱如命的亚瑟居然散尽家财帮助其他人</p>
<p>&emsp;&emsp;后来你还告诉我，你认识了一名老兵，一名和你很像的老兵，看清了生死；那印第安人的首领——落雨，是为数不多想帮你减轻痛苦的人，是他告诉了你人生的意义，他才是那位真正有远识的人在去和达奇见最后一面时，你告诉我，你因没有救下飞鹰而后悔，你甚至后悔没有告诉玛丽你的事情，你没有安排好所有人，只能把他们的命运托给沙迪夫人和我，</p>
<p>&emsp;&emsp;我想你是想好好和他们道个别的，但总是少那么个机会毕竟西部的世界总是那么狂野，狂野到没有坐下来好好休息、聊天的时间听你说你喜欢能看见太阳的地方，查尔斯还特意选了个好位置给你呢，这下你可有时间坐下来好好休息了可这西部啊，少了你，就少了点味道少了那味道，我都不知道该干些什么了你知道吗，在你离开之后，帮派也散了。皮尔逊那家伙去当了个商店老板，这个脑袋少根筋的家伙居然还把我们的合照挂在了墙头，也不怕其他人闻起来，不知道这个自恋的家伙追到他喜欢的姑娘没？莎迪夫人还是老样子，雷厉风行，她说：像她这种人，在屋子被烧掉后，就注定没有归宿。于是一个人在狂野的西部当起了赏金猎人，虽然她的枪法很烂而且整个人还是鲁莽，但我还是希望她能活久一点，毕竟她骑马去打听迈卡消息的时候，我居然看到了一丝你的身影</p>
<p>&emsp;&emsp;还记得那个被你赶走的放债人吗，那家伙最后一笔债放给一个叫做亚瑟的人。一路上听见的都是“亚瑟死了”，真他妈的难听。就是这样一个斯文败类又弱不禁风的德国人最后还是被平克顿侦探抓住了。只是没想到，这家伙即使是被折磨致死都不肯说出我们的下落，果然人就不能看那该死的行为，你看那杀千刀迈卡不就是一个 25 仔？噢，</p>
<p>&emsp;&emsp;对了，怎么能忘了约翰·马斯顿这家伙？这家伙，正如你所说的：be a god damn man，这个开头被狼啃坏脑子的人居然真得开始了农场主的生活。虽然还是那幅牛仔样，还是那个一言不合就拔枪的人。说起来你还真狡猾，居然把全部东西给了马斯顿，你的帽子，枪，照片，日记甚至是戒指。不过也好，倘若是留给我那就是压箱底的宝物了，我可不像那马斯顿，拿起你的日记继续写着他的生活，甚至还拿起你的戒指在黑水镇的胡中心向阿比盖尔求起了婚，天晓得这对老夫老妻有多幸福。如果那天你逃出来了，是不是会拿着这枚戒指跑去找玛丽。不过，你应该不敢，在爱人这方面，你可比马斯顿逊色多了</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4R2V.jpg" width=100%/>

<p>&emsp;&emsp;对了，说起马斯顿，这家伙居然不听阿比盖尔的劝和莎迪去找迈卡报仇了，带着你的帽子和你的枪。不得不说，这家伙功夫还是不到家啊，你喝醉酒的枪法都比清醒时的他强，甚至在最后差点被迈卡所杀，好在达奇那老糊涂总算是清醒了一次大家都过得很好，该成家立业都成家立业，即使是大叔和查尔斯在外流浪的人也都留在了马斯顿的身边经营着那新建的农场。如果你肯定会喜欢这种生活，毕竟你和马斯顿曾经在瓦伦丁一起赶过羊呢！玛丽，她说着和你永远不相见，却还是偷偷跑去你的墓旁哭泣，她大概是再也不会遇到一个那么傻的神枪手了，</p>
<p>&emsp;&emsp;我至今还是无法回忆起你“血仇，血债，血偿”那条路，那条路上的你总是想起最后那段时间他们所说的话，但总得还是那句——“做你能做的”。那句对达奇说的：i gave you all i had，是我见过最无奈的话了我可太不同意查尔斯那句话了：“知道自己的死期比很多人幸运。”但我又太同意这句话了，西恩，何西亚，蓝尼甚至连话都没说就被这狂野的西部杀了，措手不及。于是在最后的时刻你尽力自己所能救了他们，也救了自己。至少在最后，你会说：in the end，i did it 最后我还是选择留在了之前有你的瓦伦丁镇，毕竟只有那时候，大家还是有退路，而你还是那个意气风发的神枪手</p>
]]></content>
      <categories>
        <category>游戏日记</category>
      </categories>
      <tags>
        <tag>荒野大镖客</tag>
        <tag>亚瑟-摩根</tag>
      </tags>
  </entry>
  <entry>
    <title>AlohaHejaHe</title>
    <url>/2020/11/10/AlohaHejaHe/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=32337953&auto=1&height=66"></iframe>

<p><a href="https://music.163.com/#/song?id=32337953">https://music.163.com/#/song?id=32337953</a></p>
<p>Hab’ die ganze Welt geseh’n 我曾看过整个世界</p>
<p>Von Singapur bis Aberdeen 从新加坡到阿伯丁</p>
<p>Wenn du mich fragst wo’s am schönsten war 你要问我那里最美</p>
<p>Sag’ ich Sansibar! 我会说是桑给巴尔</p>
<p>Es war ‘ne harte überfahrt – 那曾经是一段艰难的旅程</p>
<p>Zehn Wochen nur das Deck geschrubbt 十个星期都在海浪中浮沉</p>
<p>Hab’ die Welt verflucht 我曾诅咒世界</p>
<p>In den Wind gespuckt 曾对暴风唾骂</p>
<p>Und salziges Wasser geschluckt! 也吞下过咸涩海水</p>
<p>Als wir den Anker warfen war es himmlische Ruh’ 当我们抛下锚后 是极其美妙的平静</p>
<p>Und die Sonne stand senkrecht am Himmel 阳光也重新照耀我们</p>
<p>Als ich über die Reeling sah 绞盘后我看到</p>
<p>Da glaubte ich zu tr?umen – 我还以为是梦境——</p>
<p>Da war’n tausend Boote und sie hielten auf uns zu! 那是数千艘船 朝着我们驶来</p>
<p>In den Booten waren M?nner und Frau’n 船上站着男男女女</p>
<p>Ihre Leiber gl?nzten in der Sonne 在阳光下引人注目</p>
<p>Und sie sangen ein Lied 他们唱着一支歌</p>
<p>Das kam mir seltsam bekannt vor 歌声让我感觉异常亲切</p>
<p>Aber so hab’ ich’s noch nie geh?rt 但是我却从未听过</p>
<p>Uhhhh, so hab’ ich’s noch nie geh?rt! 喔，我却从未听过</p>
<p>Aloha heja he – aloha heja he, aloha heja he 阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿~（这是瑞典语加油加油的意思）</p>
<p>Aloha heja he – aloha heja he, aloha heja he 阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿~</p>
<p>Ihre Boote machten l?ngsseits fest 他们的船并排停下</p>
<p>Und mit dem Wind wehte Gel?chter herüber 笑声随风飘扬过来</p>
<p>Sie nahmen ihre Blumenkr?nze ab 他们取下头上花冠</p>
<p>Und warfen sie zu uns herüber 然后扔向我们</p>
<p>Hehhhh, und schon war die Party im Gange! 狂欢已经开始</p>
<p>Aloha heja he – aloha heja he, aloha heja he 阿啰哈 嘿呀 嘿~</p>
<p>Aloha heja he – aloha heja he, aloha heja he 阿啰哈 嘿呀 嘿~</p>
<p>Ich hab’ das Paradies geseh’n 我看到了天堂</p>
<p>Es war um neunzehnhundertzehn! 在那 1910 年</p>
<p>Der Steuermann hatte Matrosen am Mast 大副让水手们守在桅杆旁</p>
<p>Und den Zahlmeister ha’m die Gonokokken vernascht – 军需官遭受了淋球菌感染</p>
<p>Aber sonst war’n wir bei bester Gesundheit! 但除此之外我们一切健康</p>
<p>Aloha heja he – aloha heja he, aloha heja he 阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿~</p>
<p>Aloha heja he – aloha heja he, aloha heja he 阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿~</p>
<p>Aloha heja he – aloha heja he, aloha heja he 阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿~</p>
<p>Aloha heja he – aloha heja he, aloha heja he 阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿~</p>
<p>Aloha heja he – aloha heja he, aloha heja he 阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿~</p>
<p>Aloha heja he – aloha heja he, aloha heja . . . 阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿阿啰哈嘿呀 嘿~</p>
]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>Completion Record</title>
    <url>/2020/11/21/Completion%20Record/</url>
    <content><![CDATA[<p>JavaScript 用语句来完成流程控制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这是一条简单的 <code>if</code> 语句，它的完成状态可能是不一样的，<code>return</code> 有可能会执行也有可能不会执行取决于x变量具体的值，</p>
<p>所以 JavaScript 引擎在解析<code>if</code>语句的时候就需要知道它完成之后的结果到底是怎样的。于是在 JavaScript 语言中就需要一种数据结构来存储语句的完成结果，这就是我们所谓的 Completion Record 类型了，它不在其中基本类型中，我们在 JavaScript 中无论如何都是无法获取到这个数据，它没有办法赋值给变量也没有办法作为参数，但是它确确实实存在于 JavaScript 的运行时，</p>
<p>每写一条一句就会产生 Completion Record 这样的东西，</p>
<p>比如上面的<code>if</code>语句，它的  Completion Record 可能包含了这些信息：是否返回了？返回值是啥？等等…..</p>
<p>接下来我们就来看看一个具体的 Completion Record 是怎样组成的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[[type]]: normal, break，continue，return，or throw</span><br><span class="line">[[value]]: 基本类型值</span><br><span class="line">[[target]]：label</span><br></pre></td></tr></table></figure>

<p>type 部分是它的类型，正常的语句它都是 normal，有些语句可能会产生break，continue，return，or throw，type 是一个非常关键的信息，</p>
<p>值得注意的是，比如说我们的<code>if</code>语句或者说我们<code>for</code>循环，它里面都有可能产生 <code>return</code>，<code>break</code>，<code>continue</code>，这些穿透力比较强的 type 可能会改变父语句的 type</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数被直接返回了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>value：有些语句，尤其是表达式语句，他一定是有一个返回值的，正因为它有返回值，所以它才能发挥一定的作用，另外 return，throw，它都会带着一个值，这个值也是控制中的一个关键，这个值可能会被抛给其他的语句或者是赋值给一些变量去执行，所以 value 也是 Completion Record里面一个重要的信息</p>
<p>target：这个非常少见  target 是一个label，这个东西其实就是我们在语句前面加上一个标识符和冒号，然后这样的话这个语句就变成了一个带 label 的语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">javascript:<span class="keyword">void</span>();</span><br><span class="line"><span class="comment">// label 可以和break，continue 配合使用达到一些如跳出指定循环的效果</span></span><br><span class="line">outPoint: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i, j)</span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">55</span> &amp;&amp; j === <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> outPoint;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是JavaScript 中的 Completion Record 了，我们单看Completion Record，其实他就是一个语句完成状态的这样的一个记录</p>
]]></content>
  </entry>
  <entry>
    <title>Generator函数的语法</title>
    <url>/2020/10/13/Generator%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>
<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ending&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p>
<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p>
<p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码一共调用了四次<code>next</code>方法。</p>
<p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>
<p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>
<p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p>
<p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p>
<p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p>
<p>ES6 没有规定，<code>function</code>关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure>

<p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在<code>function</code>关键字后面。本书也采用这种写法。</p>
<h4 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h4><p>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</p>
<p>遍历器对象的<code>next</code>方法的运行逻辑如下。</p>
<ol>
<li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值</li>
<li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</li>
<li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li>
<li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</li>
</ol>
<p>需要注意的是，<code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>yield</code>后面的表达式<code>123 + 456</code>，不会立即求值，只会在<code>next</code>方法将指针移到这一句时，才会求值。</p>
<p><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）<code>return</code>语句，但是可以执行多次（或者说多个）<code>yield</code>表达式。正常函数只能返回一个值，因为只能执行一次<code>return</code>；Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。</p>
<p>Generator 函数可以不用<code>yield</code>表达式，这时就变成了一个单纯的暂缓执行函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;执行了！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> generator = f();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  generator.next();</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>如果是普通函数，在为变量<code>generator</code>赋值时就会执行。但是，函数<code>f</code>是一个 Generator 函数，就变成只有调用<code>next</code>方法时，函数<code>f</code>才会执行。</p>
<p>另外需要注意，<code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure>

<p>上面代码在一个普通函数中使用<code>yield</code>表达式，结果产生一个句法错误。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码也会产生句法错误，因为<code>forEach</code>方法的参数是一个普通函数，但是在里面使用了<code>yield</code>表达式（这个函数里面还使用了<code>yield*</code>表达式，详细介绍见后文）。一种修改方法是改用<code>for</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo(<span class="keyword">yield</span> <span class="string">&quot;a&quot;</span>, <span class="keyword">yield</span> <span class="string">&quot;b&quot;</span>); <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript面向对象还是基于对象？</title>
    <url>/2020/11/03/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%98%E6%98%AF%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%EF%BC%9F/</url>
    <content><![CDATA[<p>与其他语言相比，JavaScript 中的对象总是显得不那么合群。一些新人再学习 JavaScript 面向对象的时候，往往也会有疑惑</p>
<ul>
<li>为什么 JavaScript（直到 ES6）有对象的概念，但是却没有像其他语言那样，有类的概念呢？</li>
<li>为什么 JavaScript 对象可以自由添加属性，而其他语言却不能呢？</li>
</ul>
<p>甚至，再一些争论中，有人强调：JavaScript 并非 “面向对象的语言”，而是基于对象的语言，这个说法一度流传甚广，而事实上，我至今遇到持有这一说法的人中，无一能够回答，如何定义面向对象和基于对象，这个问题</p>
<p>实际上，基于对象和面向对象两个形容词都出现了 JavaScript 标准的各个版本当中</p>
<p>我们可以先看看，JavaScript 标准基于对象的定义，这个定义的具体内容是：“语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列相互通讯的对象集合”</p>
<p>这里的意思根本不是表达弱化的面向对象的意思，反而是表达对象对于语言的重要性。</p>
<p>那么，在本篇文章中，我会尝试让你去理解面向对象和 JavaScript 中的面向对象究竟是什么，</p>
<h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><p>我们先来说说，什么是对象，因为翻译的原因，中文语境下我们很难理解“对象的真正含义”，事实上，Object（对象）在英文中，是一切事物的总称，这和面向对象的抽象思维有互通之处。</p>
<p>中文的 “对象”，却没有这样的普适性，在学习编程的过程中，更多的是把它当作一个专业名词来理解</p>
<p>但不论如何，我们应该认识到，对象并不是计算机领域凭空捏造出来的概念，它是顺着人类思维模式产生的一种抽象，（于是面向对象编程也被认为是更接近人类思维模式的一种编程范式）。</p>
<p>那么我们先来看看人类思维模式下，对象究竟是什么。</p>
<blockquote>
<p>对象这以概念在人类的幼儿期形成，这远远早于我们编程中常用的值，过程等概念，在幼年期，我们总是先认识到某一个苹果能吃（这里的一个苹果就是一个对象）继而认识到所有的苹果都可以吃，（这里所有的苹果就是一个类），再后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字 3 （值）的概念</p>
</blockquote>
<p>在《面向对象分析与设计》这本书中，Grady Booch 替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一：</p>
<ul>
<li>一个可以触摸或者可以看见的东西；</li>
<li>人的智力可以理解的东西；</li>
<li>可以指导思考或行动（进行想象或施加动作）的东西。</li>
</ul>
<p>有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。</p>
<p>而 JavaScript 早年却选择了一个更为冷门的方式：原型。这是我在前面说它不合群的原因之一。</p>
<p>然而很不幸，因为一些公司政治原因，JavaScript 推出之时受管理层之命被要求模仿 Java，所以，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this 等语言特性，使之“看起来更像 Java”。</p>
<p>在 ES6 出现之前，大量的 JavaScript 程序员试图在原型体系的基础上，把 JavaScript 变得更像是基于类的编程，进而产生了很多所谓的“框架”，比如 PrototypeJS、Dojo。</p>
<p>事实上，它们成为了某种 JavaScript 的古怪方言，甚至产生了一系列互不相容的社群，显然这样做的收益是远远小于损失的。</p>
<p>如果我们从运行时角度来谈论对象，就是在讨论 JavaScript 实际运行中的模型，这是由于任何代码执行都必定绕不开运行时的对象模型。</p>
<p>不过，幸运的是，从运行时的角度看，可以不必受到这些“基于类的设施”的困扰，这是因为任何语言运行时类的概念都是被弱化的。</p>
<p>首先我们来了解一下 JavaScript 是如何设计对象模型的。</p>
<h3 id="JavaScript-对象的特征"><a href="#JavaScript-对象的特征" class="headerlink" title="JavaScript 对象的特征"></a>JavaScript 对象的特征</h3><p>在我看来，不论我们使用什么样的编程语言，我们都先应该去理解对象的本质特征（参考 Grandy Booch 《面向对象分析与设计》）。总结看来，对象有如下几个特点。</p>
<ul>
<li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象</li>
<li>对象有状态：对象具有状态，同一对象可能处于不同状态之下</li>
<li>对象具有行为：即对象的状态，可能因为它的行为产生变迁</li>
</ul>
<p>我们先来看第一个特征，对象具有唯一标识性，一般而言，各种语言的对象唯一标识性都是用内存地址来体现的，对象具有唯一标识的内存地址，所以具有唯一的标识。</p>
<p>所以 JavaScript 程序员都知道，任何不同的 JavaScript 对象其实都是互不相等的，我们可以看下面的代码，o1 和 o2 初看是两个一摸一样的对象，但是打印出来的结果却是 false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o1 == o2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>关于对象的第二个和第三个特征 “状态和行为”，不同语言会使用不同的属于来抽象描述它们，比如 C++ 中称它们为 “成员变量”和“成员函数”，Java 中则称它们为 “属性”和“方法”</p>
<p>在 JavaScript 中，将状态和行为统一抽象为 “属性”，考虑到 JavaScript 中将函数设计成一种特殊的对象，所以 JavaScript 中的行为和状态都能用属性来抽象</p>
<p>下面这段代码其实就展示了普通属性和函数作为属性的一个例子，其中 o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    d: <span class="number">1</span>,</span><br><span class="line">    f() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以，总结一句话来看，在 JavaScript 中，对象的状态和行为其实都被抽象为了属性。如果你用过 Java，一定不要觉得奇怪，尽管设计思路有一定差别，但是二者都很好地表现了对象的基本特征：标识性、状态和行为。</p>
<p>在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</p>
<p>我来举个例子，比如，JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。如果你用过 Java 或者其它别的语言，肯定会产生跟我一样的感受。</p>
<p>下面这段代码就展示了运行时如何向一个对象添加属性，一开始我定义了一个对象 o，定义完成之后，再添加它的属性 b，这样操作是完全没问题的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">o.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.a, o.b); <span class="comment">//1 2</span></span><br></pre></td></tr></table></figure>

<p>为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。</p>
<h3 id="JavaScript-对象的两类属性"><a href="#JavaScript-对象的两类属性" class="headerlink" title="JavaScript 对象的两类属性"></a>JavaScript 对象的两类属性</h3><p>对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）</p>
<p>先来说说第一类属性，数据属性，它比较接近其他语言的属性概念，数据属性具有四个特征</p>
<ul>
<li>value：就是属性的值。</li>
<li>writable：决定属性能否被赋值。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<p>在大多数情况下，我们只关心数据属性的只即可</p>
<p>第二类属性是访问器（getter/setter）属性，它也有四个特征</p>
<ul>
<li>getter：函数或 undefined，在取属性值时被调用。</li>
<li>setter：函数或 undefined，在设置属性值时被调用。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p>
<p>我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 getOwnPropertyDescripter 来查看，如以下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">o.b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//a和b皆为数据属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;a&quot;</span>) <span class="comment">// &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;b&quot;</span>) <span class="comment">// &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们在这里使用了两种语法来定义属性，定义完属性后，我们用 JavaScript 的 API 来查看这个属性，我们可以发现，这样定义出来的属性都是数据属性，writeable、enumerable、configurable 都是默认值为 true。</p>
<p>如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 Object.defineProperty，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;b&quot;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">//a和b都是数据属性，但特征值变化了</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;a&quot;</span>); <span class="comment">// &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;b&quot;</span>); <span class="comment">// &#123;value: 2, writable: false, enumerable: false, configurable: true&#125;</span></span><br><span class="line">o.b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用了 Object.defineProperty 来定义属性，这样定义属性可以改变属性的 writable 和 enumerable。</p>
<p>我们同样用 Object.getOwnPropertyDescriptor 来查看，发现确实改变了 writable 和 enumerable 特征。因为 writable 特征为 false，所以我们重新对 b 赋值，b 的值不会发生变化。</p>
<p>在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="keyword">get</span> <span class="title">a</span>() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数。这里我们的 getter 函数返回了 1，所以 o.a 每次都得到 1。</p>
<p>这样，我们就理解了，实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。</p>
<p>对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。我们以上面的对象 o 为例，你可以想象一下“a”是 key。</p>
<p>{writable:true,value:1,configurable:true,enumerable:true}是 value。我们在前面的类型课程中，已经介绍了 Symbol 类型，能够以 Symbol 为属性名，这是 JavaScript 对象的一个特色。</p>
<p>讲到了这里，如果你理解了对象的特征，也就不难理解我开篇提出来的问题。</p>
<p>你甚至可以理解为什么会有“JavaScript 不是面向对象”这样的说法了。这是由于 JavaScript 的对象设计跟目前主流基于类的面向对象差异非常大。</p>
<p>可事实上，这样的对象系统设计虽然特别，但是 JavaScript 提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式（下一节课我们会给你介绍 JavaScript 中两种面向对象编程的范式：基于类和基于原型），所以它也是正统的面向对象语言。</p>
<p>JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言，我想标准中能这样说，正是因为 JavaScript 的高度动态性的对象系统。</p>
<p>所以，我们应该在理解其设计思想的基础上充分挖掘它的能力，而不是机械地模仿其它语言。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>要想理解 JavaScript 对象，必须清空我们脑子里“基于类的面向对象”相关的知识，回到人类对对象的朴素认知和面向对象的语言无关基础理论，我们就能够理解 JavaScript 面向对象设计的思路。</p>
<p>在这篇文章中，我从对象的基本理论出发，和你理清了关于对象的一些基本概念，分析了 JavaScript 对象的设计思路。接下来又从运行时的角度，介绍了 JavaScript 对象的具体设计：具有高度动态性的属性集合。</p>
<p>很多人在思考 JavaScript 对象时，会带着已有的“对象”观来看问题，最后的结果当然就是“剪不断理还乱”了。</p>
<h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p>结合文章通篇看下来，觉得 JS 的 OO 和他基于类的 OO 不同之处，在于 JS 可以在运行时修改对象，而 class based 的类只能预先全部定义好，我们并不能在运行时动态修改类。在我理解来说，条条大路通罗马，面向对象是罗马，class based 是一条路，prototype based 是另一条路。而且 Symbol 的出现，暴露出了许多内置接口，让 JS 又在这条路上走了更远一些。（以前上学背面向对象的三个特征，封装，继承，多态，现在看一下突然觉得很对。。。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>理论</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2020/10/29/KMP/</url>
    <content><![CDATA[<p>有些算法，适合从他的产生的动机，如何设计与解决问题这样正向的去介绍，但 KMP 算法真的不合适这样去学，最好的方法使先搞清楚它所用的数据结构是什么，再搞清楚怎么用，最后为什么的问题就会有恍然大悟的感觉，我试着从这个思路介绍一下</p>
<p>KMP 算法的和核心，是一个被称为部分匹配表（Partial Match Table）的数组，理解 KMP 的最大障碍就是 PMT，有些人看了很多 KMP 的文章后仍然搞不懂 PMT 中的值代表什么意思，这里我们抛开所有的枝枝蔓蔓，先来解释下这个数据到底是什么东西</p>
<p>对于字符转 “abababca”，它的 PMT 如下表所示</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-e905ece7e7d8be90afc62fe9595a9b0f_720w.jpg?source=1940ef5c" alt="PMT"></p>
<p>就像图中所示，如果待匹配的模式字符串有 8 个字符，那么 PMT 就会有 8 个值。</p>
<p>我先解释下字符串的前缀和后缀，如果字符串 A 和 B 存在 A=BS，其中 S 是任意的非空字符串，那么就称 B 为 A 的前缀，例如“Harry”的前缀包括<code>[&quot;H&quot;,&quot;Ha&quot;,&quot;Har&quot;,&quot;Harr&quot;]</code> 我们把所有前缀组合成的集合称为字符串的前缀集合，同样可以定义 A=SB ，其中 S 是任意非空字符，那就称 B 为 A 的后缀，例如，“Potter”的后缀包括<code>[&quot;otter&quot;,&quot;tter&quot;,&quot;ter&quot;,&quot;er&quot;,&quot;r&quot;]</code>。然后把所有的后缀组合成新的集合，称为字符串的后缀集合，要注意的是，字符串本身并不是自己的后缀或前缀</p>
<p>有了这个定义，就可以说明 PMT 中的值的意义了，<strong>PMT 中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</strong>。例如，对于 “aba”，它的前缀集合为<code>[&quot;a&quot;,&quot;ab&quot;]</code>，后缀集合为<code>[&quot;ba&quot;,&quot;a&quot;]</code>，这两个集合的交集为<code>[&quot;a&quot;]</code>，那么最长的元素就是字符串 “a” 了，长度为 1，所以对于”abc”而言， 它在 PMT 表中对应值就是 1。再比如，对于字符串 ”ababa”，它的前缀集合为<code>[”a”, ”ab”, ”aba”, ”abab”]</code>，它的后缀集合为<code>[”baba”, ”aba”, ”ba”, ”a”]</code>， 两个集合的交集为<code>[”a”, ”aba”]</code>，其中最长的元素为 ”aba”，长度为 3。</p>
<p>好了，解释清楚这个表是什么之后，我们再来看如何使用这个表来加速字符串的查找，以及这样用的道理是什么。如图 1.12 所示，要在主字符串”ababababca”中查找模式字符串”abababca”。如果在 j 处字符不匹配，那么由于前边所说的模式字符串 PMT 的性质，主字符串中 i 指针之前的 PMT[j −1] 位就一定与模式字符串的第 0 位至第 PMT[j−1] 位是相同的。这是因为主字符串在 i 位失配，也就意味着主字符串从 i−j 到 i 这一段是与模式字符串的 0 到 j 这一段是完全相同的。而我们上面也解释了，模式字符串从 0 到 j−1 ，在这个例子中就是”ababab”，其前缀集合与后缀集合的交集的最长元素为”abab”， 长度为 4。所以就可以断言，主字符串中 i 指针之前的 4 位一定与模式字符串的第 0 位至第 4 位是相同的，即长度为 4 的后缀与前缀相同。这样一来，我们就可以将这些字符段的比较省略掉。具体的做法是，保持 i 指针不动，然后将 j 指针指向模式字符串的 PMT[j −1]位即可。</p>
<p>简言之，以图中的例子来说，在 i 处失配，那么主字符串和模式字符串的前边 6 位就是相同的。又因为模式字符串的前 6 位，它的前 4 位前缀和后 4 位后缀是相同的，所以我们推知主字符串 i 之前的 4 位和模式字符串开头的 4 位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p>
<p><img data-src="https://pic4.zhimg.com/50/v2-03a0d005badd0b8e7116d8d07947681c_hd.jpg?source=1940ef5"></p>
<p>有了上面的思路，我们就可以使用 PMT 加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，所以为了编程的方便， 我们不直接使用 PMT 数组，而是将 PMT 数组向后偏移一位。我们把新得到的这个数组称为 next 数组。下面给出根据 next 数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把 PMT 进行向右偏移时，第 0 位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next 数组如下表所示。</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-40b4885aace7b31499da9b90b7c46ed3_720w.jpg?source=1940ef5c"></p>
<p>具体的程序如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kmp</span>(<span class="params">source, pattern</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 求出 pmt 表格</span></span><br><span class="line">  <span class="keyword">let</span> table = <span class="keyword">new</span> <span class="built_in">Array</span>(pattern.length).fill(<span class="number">0</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; pattern.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pattern[i] === pattern[j]) &#123;</span><br><span class="line">        ++i, ++j;</span><br><span class="line">        table[i] = j;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          j = table[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ++i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 匹配</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; source.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pattern[j] === source[i]) &#123;</span><br><span class="line">        ++i, ++j;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          j = table[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ++i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (j === pattern.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kmp(<span class="string">&quot;abababcaabababca&quot;</span>, <span class="string">&quot;abababca&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>好了，讲到这里，其实 KMP 算法的主体就已经讲解完了。你会发现，其实 KMP 算法的动机是很简单的，解决的方案也很简单。远没有很多教材和算法书里所讲的那么乱七八糟，只要搞明白了 PMT 的意义，其实整个算法都迎刃而解。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy</title>
    <url>/2020/11/02/Proxy/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, propKey, value, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.count = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.count;</span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(object, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time; <span class="comment">// 35</span></span><br><span class="line">proxy.name; <span class="comment">// 35</span></span><br><span class="line">proxy.title; <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p>
<p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.a = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">target.a; <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p>
<p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time; <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>
<p>同一个拦截器函数，可以设置拦截多个操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&quot;prototype&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> (<span class="params">target, thisBinding, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span> (<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: args[<span class="number">1</span>] &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> fproxy(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">fproxy.prototype === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line">fproxy.foo === <span class="string">&quot;Hello, foo&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li>
<li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li>
<li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
<li>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
<li>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>
<li>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>
<li>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ul>
<h3 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h3><p><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo = <span class="number">123</span>;</span><br><span class="line">proxy.foo; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo; <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure>

<p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p>
<p><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h3 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h3><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === proxy);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.m(); <span class="comment">// false</span></span><br><span class="line">proxy.m(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p>
<p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    _name.set(<span class="built_in">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _name.get(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> Person(<span class="string">&quot;Jane&quot;</span>);</span><br><span class="line">jane.name; <span class="comment">// &#x27;Jane&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.name; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p>
<p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2015-01-01&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&quot;getDate&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>另外，Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + key;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === handler);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// Hello, foo</span></span><br><span class="line"></span><br><span class="line">proxy.foo = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Star Sky</title>
    <url>/2020/11/10/SkySky/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=31654478&auto=1&height=66"></iframe>

<p><a href="https://music.163.com/#/song?id=31654478">https://music.163.com/#/song?id=31654478</a></p>
<p>Here we are 我们在此地</p>
<p>Riding the sky 翱翔于天际</p>
<p>Painting the night with sun 绘夜空以晨旭</p>
<p>You and I, Mirrors of light 你和我 交相辉映</p>
<p>Twin flames of fire 如两团火焰</p>
<p>Lit in another time and place 闪亮在彼时彼地</p>
<p>I knew your name 我曾知你生名</p>
<p>I knew your face 也曾忆你音容</p>
<p>Your love and grace 与你爱和魅力</p>
<p>Past and present now embrace 过往与现在汇聚</p>
<p>Worlds collide in inner space 世界激荡于内心</p>
<p>Unstoppable, the song we play 我们奏响的歌 永不停息</p>
<p>（chorus）（合唱）</p>
<p>Burn the page for me 忘记我的过去</p>
<p>I cannot erase the time of sleep 沉睡时光我无法抹去</p>
<p>I cannot be loved so set me free 我不能被爱 所以放我自由</p>
<p>I cannot deliver your love 我不能接受你的爱</p>
<p>Or caress your soul so 也无法抚慰你（的灵魂） 那</p>
<p>turn that page for me 就让过往逝去</p>
<p>I cannot embrace the touch that you give 我不能接受你的拥抱</p>
<p>I cannot find solace in your words 也找不到安慰的话语</p>
<p>I cannot deliver you your love 我不能回应你的爱意</p>
<p>or caress your soul 也不能抚慰你（的灵魂）</p>
<p>Age to age 年复一年</p>
<p>I feel the call 我感到那呼唤</p>
<p>Memory of future dreams 未来梦想的记忆</p>
<p>You and I, riding the sky 你和我 相依比翼</p>
<p>Keeping the fire bright 让火焰永不熄</p>
<p>From another time and place 在彼时彼地</p>
<p>I know your name 我知你生名</p>
<p>I know your face 将你容颜记</p>
<p>Your touch and grace 和你的怀抱和魅力</p>
<p>All of time can not erase 时间也无法抹去</p>
<p>What our hearts remember stays 我们记得要留在哪里</p>
<p>Forever on a song we play 永远留在 我们的那首歌里</p>
<p>（chorus）（合唱）</p>
<p>Burn the page for me 忘记我的过去</p>
<p>I cannot erase the time of sleep 沉睡时光我无法抹去</p>
<p>I cannot be loved so set me free 我不能被爱 所以放我自由</p>
<p>I cannot deliver your love 我不能接受你的爱</p>
<p>Or caress your soul so 也无法抚慰你（的灵魂） 那</p>
<p>turn that page for me 就让过往逝去</p>
<p>I cannot embrace the touch that you give 我不能接受你的拥抱</p>
<p>I cannot find solace in your words 也找不到安慰的话语</p>
<p>I cannot deliver you your love 我不能回应你的爱意</p>
<p>or caress your soul 也不能抚慰你（的灵魂）</p>
<h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><ul>
<li>女神站在高山之巅，圣咏这和平和凡世绝美，众生顶礼</li>
<li>我的学生都战死了，现在轮到我这个老师上去了！这是 1940 年一名中央航空教练员驾驶飞机冲向 32 架日本轰炸机前留在日记本上的最后一句话！传奇不该被遗忘！！</li>
<li>不和亲，不赔款，不割地，不纳贡，天子守国门，君王死社稷！——明朝祖训 “朕死，无面目见祖宗，自去冠冕，以发覆面，任贼分尸，勿伤百姓一人。”——崇祯于 1644 年三月十九日凌晨于煤山自缢前，留在衣服上的那份遗诏。</li>
<li>世界上通用的语言就两种：音乐和利剑。一样征服人，一样征服心。</li>
<li>秦始皇：朕统六国，天下归一，筑长城以镇九州龙脉，卫我大秦、护我社稷。朕以始皇之名在此立誓！朕在，当守土开疆，扫平四夷，定我大秦万世之基！朕亡，亦将身化龙魂，佑我华夏永世不衰！此誓，日月为证，天地共鉴，仙魔鬼神共听之！</li>
</ul>
]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>cssom</title>
    <url>/2020/11/06/cssom/</url>
    <content><![CDATA[<p>前面的课程中，我们已经学些了 DOM 相关的 API，狭义的 DOM API 仅仅包含 DOM 树形结构的相关内容，今天我们来学习一类新的 API：CSSOM</p>
<p>我想，你在最初接触浏览器 API 的时候，应该都有跟我类似的想法，“好想要 element.width,element.height” 这样的 API 啊</p>
<p>这样的 API 可以直接获取元素的显示相关信息，它们是非常符合人的第一印象的设计，但是偏偏 DOM API 中没有这样的内容。</p>
<p>随着深入我才知道，这样的设计是有背后逻辑的，正如 HMLT 和 CSS 分别承担了语义和表现的分工，DOM 和 CSSOM 也有语义和表现的分工，</p>
<p>顾名思义，CSSOM 是 CSS 对象模型，在 W3C 标准中，它包含两个部分，描述样式表和规则等 CSS 的模型部分（CSSOM），和跟元素视图相关 View 部分（CSSOM，View）</p>
<p>在实际使用中，CSSOM View 比 CSSOM 更常用一些，因为我们很少需要用代码动态的管理样式表</p>
<p>在今天的文章中，我来分别为你介绍这两部分 API</p>
<h3 id="CSSOM"><a href="#CSSOM" class="headerlink" title="CSSOM"></a>CSSOM</h3><p>首先我们来介绍 CSS 样式表的模型，也就是 CSSOM 的本体。</p>
<p>我们通常创建样式表都是使用 HTML 标签来做的，我们使 style 和 link 标签创建样式表，就像这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style title=<span class="string">&quot;Hello&quot;</span>&gt;</span><br><span class="line">a &#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> title=<span class="string">&quot;x&quot;</span> href=<span class="string">&quot;data:text/css,p%7Bcolor:blue%7D&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>我们创建好样式表后，还有可能要对它进行一些操作。如果我们以 DOM 的角度去理解的话，这些标签在 DOM 中是一个节点，它们有节点的内容、属性，这两个标签也遵循 DOM 节点的操作规则，所以可以使用 DOM API 去访问。</p>
<p>但是，这样做的后果是我们需要去写很多分支逻辑，并且，要想解析 CSS 代码结构也不是一件简单的事情，所以，这种情况下，我们直接使用 CSSOM API 去操作它们生成的样式表，这是一个更好的选择。</p>
<p>我们首先了解一下 CSSOM API 的基本用法，一般来说，我们需要先获取文档中所有的样式表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.styleSheets</span><br></pre></td></tr></table></figure>

<p>document 的 styleSheets 属性表示文档中的所有样式表，这是一个只读的列表，我们可以用方括号运算符下标访问样式表，也可以使用 item 方法来访问，它有 length 属性表示文档中的样式表数量。</p>
<p>样式表只能使用 style 标签或者 link 标签创建（对 XML 来说，还可以使用，咱们暂且不表）。</p>
<p>我们虽然无法用 CSSOM API 来创建样式表，但是我们可以修改样式表中的内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].insertRule(<span class="string">&quot;p &#123; color:pink; &#125;&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].removeRule(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>更进一步，我们可以获取样式表中特定的规则（Rule），并且对它进行一定的操作，具体来说，就是使用它的 cssRules 属性来实现：</p>
<p>这里取到的规则列表，同样是支持 item、length 和下标运算。</p>
<p>不过，这里的 Rules 可就没那么简单了，它可能是 CSS 的 at-rule，也可能是普通的样式规则。不同的 rule 类型，具有不同的属性。</p>
<p>我们在 CSS 语法部分，已经为你整理过 at-rule 的完整列表，多数 at-rule 都对应着一个 rule 类型：</p>
<ul>
<li>CSSStyleRule</li>
<li>CSSCharsetRule</li>
<li>CSSImportRule</li>
<li>CSSMediaRule</li>
<li>CSSFontFaceRule</li>
<li>CSSPageRule</li>
<li>CSSNamespaceRule</li>
<li>CSSKeyframesRule</li>
<li>CSSKeyframeRule</li>
<li>CSSSupportsRule</li>
</ul>
<p>具体规则支持的属性，建议你用到的时候，再去查阅 MDN 或者 W3C 的文档，在我们文章中，仅为你介绍最常用 CSSStyleRule。</p>
<p>CSSStyleRule 有两个属性：selectorText 和 style，分别表示一个规则的选择器部分和样式部分。</p>
<p>selector 部分是一个字符串，这里显然偷懒了没有设计进一步的选择器模型，我们按照选择器语法设置即可。</p>
<p>style 部分是一个样式表，它跟我们元素的 style 属性是一样的类型，所以我们可以像修改内联样式一样，直接改变属性修改规则中的具体 CSS 属性定义，也可以使用 cssText 这样的工具属性。</p>
<p>此外，CSSOM 还提供了一个非常重要的方法，来获取一个元素最终经过 CSS 计算得到的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(elt, pseudoElt);</span><br></pre></td></tr></table></figure>

<p>其中第一个参数就是我们要获取属性的元素，第二个参数是可选的，用于选择伪元素。</p>
<p>好了，到此为止，我们可以使用 CSSOM API 自由地修改页面已经生效的样式表了。接下来，我们来一起关注一下视图的问题。</p>
<h3 id="CSSOM-View"><a href="#CSSOM-View" class="headerlink" title="CSSOM View"></a>CSSOM View</h3><p>CSSOM View 这一部分的 API，可以视为 DOM API 的扩展，它在本来的 Element 接口上，添加了显示相关的功能， 又可以分为三个部分：窗口部分，滚动部分和布局部分，下面我们来一一了解。</p>
<h4 id="窗口-API"><a href="#窗口-API" class="headerlink" title="窗口 API"></a>窗口 API</h4><p>窗口 API 用于操作浏览器窗口的位置，尺寸等。</p>
<ul>
<li>moveTo(x, y) 窗口移动到屏幕的特定坐标；</li>
<li>moveBy(x, y) 窗口移动特定距离；</li>
<li>resizeTo(x, y) 改变窗口大小到特定尺寸；</li>
<li>resizeBy(x, y) 改变窗口大小特定尺寸；</li>
</ul>
<p>此外，窗口 API 还规定了 window.open() 的第三个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">&quot;about:blank&quot;</span>, <span class="string">&quot;_blank&quot;</span> ,<span class="string">&quot;width=100,height=100,left=100,right=100&quot;</span> )</span><br></pre></td></tr></table></figure>

<p>一些浏览器出于安全考虑没有实现，也不适用于移动端浏览器，这部分你仅需简单了解即可。下面我们来了解一下滚动 API。</p>
<h4 id="滚动-API"><a href="#滚动-API" class="headerlink" title="滚动 API"></a>滚动 API</h4><p>要想理解滚动，首先我们必须要建立一个概念，在 PC 时代，浏览器可视区域的滚动和内部元素的滚动关系是比较模糊的，但是在移动端越来越重要的今天，两者必须分开看待，两者的性能和行为都有区别。</p>
<h4 id="视口滚动-API"><a href="#视口滚动-API" class="headerlink" title="视口滚动 API"></a>视口滚动 API</h4><p>可视区域（视口）滚动行为由 window 对象上的一组 API 控制，我们先了解一下。</p>
<ul>
<li>srollX 是视口的属性，标识 X 方向的当前滚动距离，有别名 pageXOffset</li>
<li>scrollY 是视口的属性，标识 Y 方向的当前滚动距离，有别名 pageYOffset</li>
<li>scroll(x, y) 使得页面滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 {top, left}</li>
<li>scrollBy(x, y) 使得页面滚动特定的距离，支持传入配置型参数 {top, left}</li>
</ul>
<p>通过这些属性和方法，我们可以读取视口的滚动位置和操作视口的滚动，不过，要想监听视口的滚动事件，我们需要 document 对象上绑定事件监听函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>视口滚动 API 是页面的顶层容器的滚动，大部分移动端浏览器都会采用一些性能优化，它和元素滚动不完全一样，请大家一定建立这个区分的意识</p>
<h4 id="元素滚动"><a href="#元素滚动" class="headerlink" title="元素滚动"></a>元素滚动</h4><p>接下来我们认识一下元素滚动 API，在 Element 类（参见 DOM 部分），为了支持滚动，加入了以下 API。</p>
<ul>
<li>scrollTop 元素的属性，表示 Y 方向上的当前滚动距离。</li>
<li>scrollLeft 元素的属性，表示 X 方向上的当前滚动距离。</li>
<li>scrollWidth 元素的属性，表示元素内部的滚动内容的宽度，一般来说会大于等于元素宽度。</li>
<li>scrollHeight 元素的属性，表示元素内部的滚动内容的高度，一般来说会大于等于元素高度。</li>
<li>scroll(x, y) 使得元素滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 {top, left}。</li>
<li>scrollBy(x, y) 使得元素滚动到特定的位置，支持传入配置型参数 {top, left}。</li>
<li>scrollIntoView(arg) 滚动元素所在的父元素，使得元素滚动到可见区域，可以通过 arg 来指定滚到中间、开始或者就近。</li>
</ul>
<p>除此之外，可滚动的元素也支持 scroll 事件。我们在元素上监听它的事件即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&quot;scroll&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里你需要注意一点，元素部分的 API 设计与视口滚动命名风格上略有差异，你在使用的时候不要记混</p>
<h4 id="布局-API"><a href="#布局-API" class="headerlink" title="布局 API"></a>布局 API</h4><p>最后我们来介绍一下布局 API，这是整个 CSSOM 中最常用的部分，我们同样要分成全局 API 和元素上的 API。</p>
<h5 id="全局尺寸信息"><a href="#全局尺寸信息" class="headerlink" title="全局尺寸信息"></a>全局尺寸信息</h5><p>window 对象上提供了一些全局的尺寸信息，它是通过属性来提供的，我们来了解一下这些属性。</p>
<p><img data-src="https://static001.geekbang.org/resource/image/b6/10/b6c7281d86eb7214edf17069f95ae610.png"></p>
<ul>
<li>window.innerHeight, window.innerWidth 这两个属性表示视口的大小。</li>
<li>window.outerWidth, window.outerHeight 这两个属性表示浏览器窗口占据的大小，很多浏览器没有实现，一般来说这两个属性无关紧要。</li>
<li>window.devicePixelRatio 这个属性非常重要，表示物理像素和 CSS 像素单位的倍率关系，Retina 屏这个值是 2，后来也出现了一些 3 倍的 Android 屏。</li>
<li>window.screen （屏幕尺寸相关的信息）<ul>
<li>window.screen.width, window.screen.height 设备的屏幕尺寸。</li>
<li>window.screen.availWidth, window.screen.availHeight 设备屏幕的可渲染区域尺寸，一些 Android 机器会把屏幕的一部分预留做固定按钮，所以有这两个属性，实际上一般浏览器不会实现的这么细致。</li>
<li>window.screen.colorDepth, window.screen.pixelDepth 这两个属性是固定值 24，应该是为了以后预留。</li>
</ul>
</li>
</ul>
<p>虽然 window 有这么多相关信息，在我看来，我们主要使用的是 innerHeight、innerWidth 和 devicePixelRatio 三个属性，因为我们前端开发工作只需要跟视口打交道，其它信息大概了解即可。</p>
<h5 id="元素的布局信息"><a href="#元素的布局信息" class="headerlink" title="元素的布局信息"></a>元素的布局信息</h5><p>最后我们来到了本节课一开始提到的问题，我们是否能够取到一个元素的宽（width）和高（height）呢？</p>
<p>实际上，我们首先应该从脑中消除“元素有宽高”这样的概念，我们课程中已经多次提到了，有些元素可能产生多个盒，事实上，只有盒有宽和高，元素是没有的。</p>
<p>所以我们获取宽高的对象应该是“盒”，于是 CSSOM View 为 Element 类添加了两个方法：</p>
<ul>
<li>getClientRects()。</li>
<li>getBoundingClientRect()。</li>
</ul>
<p>getClientRects 会返回一个列表，里面包含元素对应的每一个盒所占据的客户端矩形区域，这里每一个矩形区域可以用 x, y, width, height 来获取它的位置和尺寸。</p>
<p>getBoundingClientRect ，这个 API 的设计更接近我们脑海中的元素盒的概念，它返回元素对应的所有盒的包裹的矩形区域，需要注意，这个 API 获取的区域会包括当 overflow 为 visible 时的子元素区域。</p>
<p>根据实际的精确度需要，我们可以选择何时使用这两个 API。</p>
<p>这两个 API 获取的矩形区域都是相对于视口的坐标，这意味着，这些区域都是受滚动影响的。</p>
<p>如果我们要获取相对坐标，或者包含滚动区域的坐标，需要一点小技巧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> offsetX = <span class="built_in">document</span>.documentElement.getBoundingClientRect().x - element.getBoundingClientRect().x;</span><br></pre></td></tr></table></figure>

<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>今天我们一起学习了 CSSOM 这一类型的 API。我们首先就说到了，就像 HTML 和 CSS 分别承担了语义和表现的分工，DOM 和 CSSOM 也有语义和表现的分工。</p>
<p>CSSOM 是 CSS 的对象模型，在 W3C 标准中，它包含两个部分：描述样式表和规则等 CSS 的模型部分（CSSOM），和跟元素视图相关的 View 部分（CSSOM View）。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 中的高级类型</title>
    <url>/2020/09/13/ts%E9%AB%98%E7%BA%A7%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型，这让我们可以把现有的多种类型叠加到一起作为一种类型，它包含了所需的所有类型的特性，例如<code>Person &amp; Serializable &amp; Loggable </code>同时是 <code>Person</code> 和 <code>Serializable</code> 和 <code>Loggable</code>。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>
<p>我们大多是在混入或其他不适合经典面向对象的地方看到交叉类型的使用，（在<code>JavaScript</code>中发生这种情况的场合会很多）下面是如何创建混入的一个简单的例子:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">    (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Loggable &#123;</span><br><span class="line">  log(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</span><br><span class="line">  log() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">&quot;Jim&quot;</span>), <span class="keyword">new</span> ConsoleLogger());</span><br><span class="line"><span class="keyword">var</span> n = jim.name;</span><br><span class="line">jim.log();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型与交叉类型很有关联，但是使用上却完全不同，偶尔你会遇到这种情况，一个代码库希望传入<code>number</code>或<code>string</code>类型作为参数，例如下面的函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Takes a string and adds &quot;padding&quot; to the left.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a string, then &#x27;padding&#x27; is appended to the left side.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a number, then that number of spaces is added to the left side.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">padLeft(<span class="string">&quot;Hello world&quot;</span>, <span class="number">4</span>); <span class="comment">// returns &quot;    Hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在 <code> padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定为了 <code>any</code> ，这就是说我们可以传入一个既不是<code>number</code> 也不是 <code>string</code> 类型的参数，但是<code>typescript</code>却不报错，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">&quot;Hello world&quot;</span>, <span class="literal">true</span>); <span class="comment">// 编译阶段通过，运行时报错</span></span><br></pre></td></tr></table></figure>

<p>在传统的面向对象语言里，我们可能会将这两种抽象成底层的类型，这么做显然是非常清晰的，但同时也存在了过度设计，<code>padleft</code> 原始版本的好处之一就是允许我们呢出传入原始类型，这样做的话用起来简单又方便，如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。</p>
<p>代替<code>any</code>，我们可以使用联合类型作为 <code>padding</code> 的参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Takes a string and adds &quot;padding&quot; to the left.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a string, then &#x27;padding&#x27; is appended to the left side.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a number, then that number of spaces is added to the left side.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">&quot;Hello world&quot;</span>, <span class="literal">true</span>); <span class="comment">// errors during compilation</span></span><br></pre></td></tr></table></figure>

<p>联合类型表示一个值可以是几种类型之一，我们用竖线（<code>|</code>）分割每个类型，所以<code>number|string|boolean</code>，表示值可以是<code>number</code> <code>string</code> 或 <code>boolean</code></p>
<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  fly();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  swim();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line">pet.layEggs(); <span class="comment">// okay</span></span><br><span class="line">pet.swim(); <span class="comment">// errors</span></span><br></pre></td></tr></table></figure>

<p>这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是 <code>A | B</code>，我们能够 确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。 这个例子里， <code>Bird</code>具有一个 <code>fly</code>成员。 我们不能确定一个 <code>Bird | Fish</code>类型的变量是否有 <code>fly</code>方法。 如果变量在运行时是 <code>Fish</code> 类型，那么调用 <code>pet.fly()</code> 就出错了。</p>
<h3 id="类型保护与区分类型"><a href="#类型保护与区分类型" class="headerlink" title="类型保护与区分类型"></a>类型保护与区分类型</h3><p>联合类型适合于那些值可以作为不同类型的情况，但当我们想确切的了解是否为 <code>Fish</code> 时怎么办？ <code>JavaScript</code> 里常用来区分两个可能的值的方法是检查成员是否存在，如之前提及的，我们只能访问联合类型中共同拥有的成员</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个成员访问都会报错</span></span><br><span class="line"><span class="keyword">if</span> (pet.swim) &#123;</span><br><span class="line">  pet.swim();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet.fly) &#123;</span><br><span class="line">  pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让这段代码工作，我们需要使用类型断言</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((&lt;Fish&gt;pet).swim) &#123;</span><br><span class="line">  (&lt;Fish&gt;pet).swim();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  (&lt;Bird&gt;pet).fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用户自定义的类型保护</strong></p>
<p>这里可以注意到，我们不得不多次使用类型断言，假如我们一旦检查过类型，就能在之后的每个分支里清楚的知道 <code>pet</code> 的类型的话就好了</p>
<p>这样 <code>TypeScript</code> 里的 类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 _类型谓词_：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里， <code>pet is Fish</code>就是类型谓词。 谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p>
<p>每当使用一些变量调用 <code>isFish</code> 时，<code>TypeScript</code> 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#x27;swim&#x27; 和 &#x27;fly&#x27; 调用都没有问题了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</span><br><span class="line">  pet.swim();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>typescript</code>不仅知道在<code>if</code>分支里 <code>pet</code> 是 <code>Fish</code> 类型的，它还清楚在 <code>else</code> 分支里，一定不是 <code>Fish</code> 类型的，一定是 <code>Bird</code> 类型的</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>一般命令式编程语言</title>
    <url>/2020/11/16/%E4%B8%80%E8%88%AC%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>一般的命令式语言的一种设计方式</p>
<p>一般来说我们的命令式语言它可能有一些细微的结构上的不一致，但是总体上来讲，它的结构都分成 5 个层级</p>
<ol>
<li>Atom（原子级）：原子级是一个语言的最小组成单位，它通常包含一些关键字包含着一些直接量包含着一些变量名这样的一些基本单位，典型的就是我们的变量名，字符串直接量，数字直接量</li>
<li>Expression（表达式）：原子级的结构通过运算符相连接，然后加上一些辅助的符号，那么它就会构成一个表达式的结构，表达式它通常是一个可以级联的结构，比如说我们的 JavaScript 有四则运算，按位与，移位运算，比较运算，或，非，等</li>
<li>Statement（语句）：表达式加上一些特定的标识符和一些特定的关键字和一些特定的符号形成一种结构我们把它叫做语句，大家比较熟悉的可能有 if（条件语句），while，for（循环语句），一个有语句的语言其实已经是一个可以达成图灵完备并且去执行的语言了，</li>
<li>Structure（结构化）：一般的语言还会有结构化的层级比如我们 JavaScript 里就会有 Function，Class 这样的一些设计，它可以我们组织代码，把代码分成不同的块，分成不同的可复用的结构，同样他也会使用关键字来形成结构化的结构</li>
<li>组织代码，有点语言有，有的不在语言里面在一些辅助性的设施里面，</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>人类将成为人工智能的宠物？</title>
    <url>/2020/11/09/%E4%BA%BA%E7%B1%BB%E5%B0%86%E6%88%90%E4%B8%BA%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%AE%A0%E7%89%A9%EF%BC%9F/</url>
    <content><![CDATA[<p>前面几篇文章从图灵说到图灵机，再到人工智能，其实对于人工智能有很多话题。其中包括对人工智能的定义、人工智能技术实现、人工智能是使用场景和范围、人工智能是否会取代人类甚至屠杀人类等等。今天我们就“人工智能是否会取代人类？”这个很有争议性话题进行解读，希望大家对人工智能有更多的思考维度。</p>
<p>现实版钢铁侠的马斯克（特斯拉 CEO），2017 年在社交平台回怼 Facebook 创始人扎克伯格，原因是扎克伯格不认为人工智能是末日，马斯克回怼：他对人工智能的理解很有限。</p>
<p>马斯克多次在不同场合表示自己对人工智能发展的担忧，认为工人智能是人类文明的最大威胁，甚至发出警告：人工智能可能引发第三次世界大战。</p>
<h1 id="一、人工智能威胁论"><a href="#一、人工智能威胁论" class="headerlink" title="一、人工智能威胁论"></a>一、人工智能威胁论</h1><p>2016 年阿尔法狗战胜了世界围棋冠军李世石，一时间整个世界哗然，围棋一直被冠以人类智力游戏的最后一高地，就这样突然被占领。 人工智能经过几十年的发展，特别在近几年大数据的共同发展，已经取得了不少的进展，人工智能在很多方面远超了人类。</p>
<p>在全世界范围内，很多科技大佬表示对人工智能的担心，上面已经提到了特斯拉 CEO 马斯克，还有今年（2018 年）刚去世的著名物理学家，天文学家霍金也提出对人工智能的担心：“我真的害怕人工智能取代人类，成为新的物种。”、“我们已经拥有原始形式的人工智能，但我认为人工智能的完全发展会导致人类的终结”等等言论。</p>
<p>对于普通民众来讲，很多人担心人工智能抢了自己的工作而丢了饭碗。在第一次工业期间，由于蒸汽机的发明，机器代替了人工在英国掀起了捣毁纺织机械为手段的工人罢工。但是其实机器大规模使用不但没有减少工作岗位，反而是增多了。</p>
<h1 id="二、人工智能有意识吗？"><a href="#二、人工智能有意识吗？" class="headerlink" title="二、人工智能有意识吗？"></a>二、人工智能有意识吗？</h1><p>计算机在非离散数学计算、存储等方面已经远超于人类，也真是因为计算机，因为信息互联网给人类带来了巨大的便利，更创造了超之前几千年之和的财富。从最广义的角度看，传统软件也应属于人工智能的范畴：实际上很多早期的计算机科学家，比如图灵，就是以人工智能为动力展开对计算机科学的研究。从这个意义上来看，人工智能是一种为人类工作的工具或机器。</p>
<p>如果人工智能只是一种可以代替人类工作的机器，它的出现并不足以让人们恐惧。 终极问题是：<strong>人工智能会有人一样，甚至超出人类的意识吗？</strong></p>
<p>现在机器（人工智能）是被人类奴役着，如果人工智能得到长足发展后，在未来，人类奴役机器的剧情将得到反转，未来，人类才是那个被“奴役”的物种！这种情节我们在很多的电影中都看到过。</p>
<p>从现在的人工智能发展水平来看，现在的人工智能其实还非常初级，只能算做弱人工智能，其实在我们有生之年估计看不到超级人工智能的存在。</p>
<h1 id="三、人工智能是生命-3-0？"><a href="#三、人工智能是生命-3-0？" class="headerlink" title="三、人工智能是生命 3.0？"></a>三、人工智能是生命 3.0？</h1><p>最近在看人工智能专家，麻省理工终身教授泰格马克的《生命 3.0》，这本书题目是生命，但是其实一本讲人工智能的书，作者对人工智能的发展、人类的终极命运将会是什么，进行了预测，脑洞非常大。</p>
<p>我们现在思考人工智能，动不动就担心机器会不会有人类的意识，人类的喜怒哀乐，情感都是因为意识。机器会自动驾驶，会人脸识别，会翻译等只不过是一种机械运动而已。但是实际上，图灵和现代生物学家都认为，人在做事的时候，本质上也是机械的，也就是可以用图灵机来进行表达，只是我们还没有找到表达的算法而已。</p>
<p>在我们都在担心意识问题的时候，泰格马克教授从生命的角度进行了解读。他把生命分成了三个阶段：生命 1.0、生命 2.0 和生命 3.0</p>
<p>生命是什么？这个问题争议很大，就像意识一样难以定义。</p>
<blockquote>
<p>泰格马克对生命进行了广阔的定义：生命是一个能够进行复制和保持自我复杂性的过程。</p>
</blockquote>
<p>1，生命 1.0 的有生之年都无法重新设计自己的硬件和软件，二者由基因 DNA 来决定，只有进化才能带来改变，而进行则需要许多代才能有很小的改变，因此生命 1.0 的进化是非常非常非常缓慢的，生命 1.0 典型的是细菌。</p>
<p>2，生命 2.0 则能够重新设计自身大部分的软件，比如人类，人类可以学习复杂的新技能、语言、知识和职业技能，并且能够从认知上更新自己的目标，自己对世界的认识。</p>
<p>3，生命 3.0 现在在地球上还没有出现，他不仅能够最大限度的重新设计自己的软件，还是重新设计自己的硬件，而不需要等待许多代进行缓慢的进化。</p>
<p>当然，我们会问，那其他的动物算生命几点 0 呢？如果细菌是 1.0，人类是 2.0，老鼠可以看做 1.1，虽然它们可以学习许多知识，但是不足以进化出语言，所以许多的东西死亡就会消失，不能积累传承。</p>
<p>那么问题来了，生命 3.0 什么时候出现？出现后，作为生命 2.0 的人类怎么共存呢？ 不知道大家有没有一个感觉？人工智能技术，特别是语音识别技术就是在近 5 年才突然爆发的，其实人工智的能力增长是指数级的，是爆发式的。超级人工智能的出现也许就需要一个契机，一个突破，比如量子计算机，他的出现肯定是爆发式的，突然出现的。</p>
<p>如果有一天人类造出了超级人工智能，即生命 3.0，就可能触发一场智能革命，将人类远远甩在后面，就像我们人类对比细菌一样，甚至更大。 如果这场智能革命由某一小撮人类控制，那他们讲可能在短短几年内控制整个世界。 如果人类没有控制这场智能革命，那么，人工智能可能以更快的速度控制世界。 因为生命 3.0 比我们高一个维度，人类将成为人工智能的宠物。</p>
<h1 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h1><p>有个图灵机、人工智能的话题差不多写完了，这些话题太大，很难写。在看了《生命 3.0》这本书，对人工智能有了更多的理解和想法，其实心情既兴奋也很担忧。在我们所做的宇宙，从宇宙大爆发那一刻开始，各种参数其实已经决定了整个宇宙发展的过程。图灵的结论告诉我们，即使未来是注定的，我们也没有一种算法去预测它，除非模拟它运行一遍。但是，要想模拟这个宇宙的运行，需要的计算量必然超出了这个宇宙自身的所有资源。运行这个宇宙的唯一方式，就是运行这个宇宙本身，或者参与其中才能知道最终的答案！</p>
<p>除非有麦克斯韦妖修改宇宙大爆炸的时候的参数，生命 3.0，超级人工智能一定会把人类甩在后面，而不仅仅是取代，人类将成为人工智能的宠物。</p>
]]></content>
      <categories>
        <category>大话说</category>
      </categories>
      <tags>
        <tag>大话说</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是图灵完备？</title>
    <url>/2020/11/09/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%EF%BC%9F/</url>
    <content><![CDATA[<p>这是一篇旨在帮助理解图灵机及相关概念是什么，而非证明其正确性的回答，它包含以下内容：</p>
<ol>
<li>什么是图灵机</li>
<li>图灵机可以解决什么问题</li>
<li>什么是图灵完备</li>
<li>直观理解图灵完备——Brainfuck 语言</li>
</ol>
<hr>
<h3 id="什么是图灵机"><a href="#什么是图灵机" class="headerlink" title="什么是图灵机"></a>什么是图灵机</h3><p>图灵机（Turing Machine）是图灵在 1936 年发表的 “On Computable Numbers, with an Application to the Entscheidungsproblem”（《论可计算数及其在判定性问题上的应用》）中提出的 <strong>数学模型</strong>。既然是数学模型，它就并非一个实体概念，而是架空的一个想法。在书中图灵描述了它是什么，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算问题</p>
<p>图灵机的结构包括以下几个部分：</p>
<ol>
<li>一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。</li>
<li>一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。</li>
<li>一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。</li>
<li>一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解有限状态机，它便对应着有限状态机里的状态。</li>
<li>一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号 53 的格子并看到其内容为 0 时，擦除，改写为 1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。</li>
</ol>
<p><img data-src="https://pic1.zhimg.com/80/v2-6d57f9001041416d43e886f14fd43f84_720w.jpg?source=1940ef5c"></p>
<p>在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：</p>
<ul>
<li>当前所处位置</li>
<li>当前格子内容</li>
</ul>
<p>来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“…011001…”）便作为输出，由人来解码为自然语言。</p>
<p>要重申一下，以上只是图灵机模型的内容，而非具体的实现。所谓的纸带和读写头都只是图灵提出的抽象概念。为便于理解打一个比方。算盘虽然不是图灵机（因为它没有无限长的纸带，即无限的存储空间），但它的行为与图灵机一致。每一串算珠都是纸带上的一格，一串算珠上展示的数字便记录着当前格中的字符（可以是空白，可以是 12345 ）。人类的手即是读写头，可以更改每串算珠的状态。算盘的运行遵循人脑中的算法，当算法结束，算盘停机。</p>
<hr>
<h3 id="图灵机可以解决什么问题"><a href="#图灵机可以解决什么问题" class="headerlink" title="图灵机可以解决什么问题"></a>图灵机可以解决什么问题</h3><p>在文章中，图灵所做的事是证明了， <strong>假设</strong>上述模型里所说的功能都能被以某种形式物理实现，<strong>那么</strong>任意可计算问题都可以被解决。这里所说的可计算问题，涉及到计算理论（Computation Theory）的概念。这个领域的概念很繁杂，先简单梳理一下。在计算机领域，或者说自动机领域，我们研究的一切问题都是计算问题（Computational Problem）。它泛指一切与计算相关的问题。</p>
<p>计算问题的一些举例：</p>
<ul>
<li>给定一个正整数 n，判断它是否是质数</li>
<li>给定一个 01 序列，把它们按位取反</li>
<li>给定一个字符串，判断某个字符是否存在，及查找存在位置</li>
<li>给定一个逻辑蕴含的命题，求它的逆否命题</li>
</ul>
<p>非计算问题的例子：</p>
<ul>
<li>今晚吃什么</li>
<li>为什么太阳从东边升起</li>
</ul>
<p>计算问题有的可以解决，有的不可解决。这就引出了计算问题的可计算性（Computability）。它可以被理解为“是否存在一个算法，能解决在任何输入下的此计算问题”。如上面的问题 1，我们当然可以找到一个算法来解决判断任意正整数 n 是否为质数的问题（比如从 2 遍历到 n-1，看 n 是否可以整除它）。所以，问题 1 就是可计算的。</p>
<p>也有一些不可计算的计算问题，比如著名的停机问题（Halting Problem）。它的表述是这样的：给定一段程序的描述和该程序的一个有效输入，运行此程序，那么程序最终是会终止，还是会死循环下去？</p>
<p>这个问题很绕人，有点像那个著名的理发师悖论，但它确实是一个计算问题。更具体的，它是一个不可判定问题（Undecidable Problem）。即不存在一个<strong>通用</strong>算法，可以在任意输入下解决此问题。图灵在文章里很优雅的用反证法推翻了假设“假设有这么一个算法可以解决任何停机问题”，从而证明了这样的算法并不存在。具体证明过程网上的资料非常丰富，我就不再花篇幅了。</p>
<p>回到这一节的主题。简而言之，对于一个问题，对于任意输入，只要人类可以保证算出结果（不管花多少时间），那么图灵机就可以保证算出结果（不管花多少时间）。</p>
<hr>
<h3 id="什么是图灵完备"><a href="#什么是图灵完备" class="headerlink" title="什么是图灵完备"></a>什么是图灵完备</h3><p>图灵完备性（Turing Completeness）是针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性。直白一点说，图灵完备性就是我给你一工具箱的东西，包括无限内存、if/else 控制流、while 循环……那么你现在图灵完备了吗？</p>
<p>概念本身倒是非常直观，但整件事似乎还是让人云里雾里。我曾经一直不懂的就是为什么图灵给出的那个命题是正确的。换句话说，凭什么有了纸带以及其他的那一套东西，就可以自信解决任意可计算问题呢？尽管我不能通读他的那篇论文里的证明，但是通过一门叫做 Brainfuck 的编程语言，还是可以获得一些直觉。</p>
<h3 id="直观理解图灵完备——Brainfuck-语言"><a href="#直观理解图灵完备——Brainfuck-语言" class="headerlink" title="直观理解图灵完备——Brainfuck 语言"></a>直观理解图灵完备——Brainfuck 语言</h3><p>如今主流的编程语言（C++，Java，Python，以及等等等等）都是图灵完备的语言。关于语言优劣之争也只是在其封装、优化等方面，以及因为这些区别而产生的“不同语言适用于不同情况”的争执。如果我们回到最底层，就会发现它们可以实现的功能其实完全一样，并且本质上就是一个图灵机。</p>
<p>在 1993 年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令。语言虽然极致轻量，它却是一门图灵完备的编程语言。如果能理解它的工作原理，那么对于理解图灵机是有很大帮助的。</p>
<p>先贴上一段 BF 的代码，体验一下它的画风：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++</span><br><span class="line">.------.--------.&gt;&gt;+.&gt;++.</span><br></pre></td></tr></table></figure>

<p>这个程序编译运行后，控制台打印 “Hello World!”。</p>
<p>BF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。</p>
<p>语言里的 8 个有效字符分别是：</p>
<ul>
<li><code>&gt;</code>：指针向右移动一格</li>
<li><code>&lt;</code>：指针向左移动一格</li>
<li><code>+</code>：使指针当前格数值加一</li>
<li><code>-</code>：使指针当前格数值减一</li>
<li><code>.</code>：把当前格数值按 ASCII 表输出到终端</li>
<li><code>,</code>：从终端接受一 byte 的数据，存储其 ASCII 数值到当前格</li>
<li><code>[</code>：当指针当前值为 0 时，程序跳转至与之对应的 <code>]</code> 之后；否则程序正常执行</li>
<li><code>]</code>：程序跳转回与之对应的 <code>[</code> 处</li>
</ul>
<p>有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 ‘A’ 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 ‘A’。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+++++</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">&gt;+++++++++++++</span><br><span class="line">&lt;-</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&gt;.</span><br></pre></td></tr></table></figure>

<p>把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 ‘A’。</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-6dc2cf6ed68844fa4fdc8a555dba3576_720w.jpg?source=1940ef5c"></p>
<p>我写这个例子的目的是演示只用图灵机的模型，就可以确实计算出乘法的结果。那么自然更加复杂的计算也可以被拆解成图灵机操作（尽管可能非常琐碎）。此外，这个语言因为简洁，也是第一次练习写编译器的一个非常好的选择。</p>
]]></content>
      <categories>
        <category>图灵</category>
      </categories>
      <tags>
        <tag>图灵</tag>
        <tag>图灵完备</tag>
      </tags>
  </entry>
  <entry>
    <title>分支界限法</title>
    <url>/2020/11/07/%E5%88%86%E6%94%AF%E7%95%8C%E9%99%90%E6%B3%95/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>类似于回溯法，也是一种在问题的空间树 T 上搜索问题的解的算法，但在一般情况下，分支界限方与回溯法的求解目标不同，回溯法的求解目标是找出 T 中满足约束条件的所有解，而分支界限发的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一个目标函数值达到极大或极小的解，即在某种意义上的最优解</p>
<h4 id="分支搜索法"><a href="#分支搜索法" class="headerlink" title="分支搜索法"></a>分支搜索法</h4><p>所谓 “分支” 就是采用广度优先搜索策略，依次搜索 E-结点的所有分支，也就是所有相邻节点，抛弃不满足约束条件的节点，其余节点加入活节点表，然后从表中选择一个节点作为下一个 E-节点，继续搜索</p>
<p>选择一个 E-节点的方式不同，则会有几种不同的分支搜索方式，</p>
<ul>
<li>FIFO 搜索</li>
<li>LIFO 搜索</li>
<li>优先队列式搜索</li>
</ul>
<h4 id="分支界限搜索法"><a href="#分支界限搜索法" class="headerlink" title="分支界限搜索法"></a>分支界限搜索法</h4><h3 id="分支界限搜索法的一般过程"><a href="#分支界限搜索法的一般过程" class="headerlink" title="分支界限搜索法的一般过程"></a>分支界限搜索法的一般过程</h3><p>由于求解目标不同，导致分支限界法与回溯法在解空间树 T 上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树 T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树 T。</p>
<p>分支限界法的搜索策略是：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p>
<p>分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p>
<h3 id="回溯法和分支限界法的一些区别"><a href="#回溯法和分支限界法的一些区别" class="headerlink" title="回溯法和分支限界法的一些区别"></a>回溯法和分支限界法的一些区别</h3><p>有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p>
<p>回溯法和分支限界法的一些区别：</p>
<ul>
<li>方法对解空间树的搜索方式</li>
<li>存储结点的常用数据结构</li>
<li>结点存储特性常用应用</li>
</ul>
<p>回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</p>
<p>分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>五大常用经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/2020/11/05/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在计算机科学中，分治法是一种很重要的算法，字面上的解释是 “分而治之”，就是把一个复杂问题分成两个或更多的相同或类似的子问题，再把子问题分成更小的子问题……直到最后的子问题可以简单的直接求解，原问题的解即是子问题的解的合并，这个技巧是很多高效算法的基础，如排序算法（快速排序，归并排序）,傅立叶变换(快速傅立叶变换)……</p>
<p>任何一个可以用计算机求解的问题所需的计算时间都与其规模有关，问题的规模越小，越容易直接求解，解题所需的计算时间越少，例如，对于 n 个元素的排序问题，当 n=1 时，不需任何计算。n=2 时，只要作一次比较即可排好序。n=3 时只要作 3 次比较即可，…。而当 n 较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。</p>
<h3 id="基本思想及策略"><a href="#基本思想及策略" class="headerlink" title="基本思想及策略"></a>基本思想及策略</h3><p>分治法的设计思想是：将一个难以直接求解的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之</p>
<p>分治策略是：对于一个规模为 n 的问题，若该问题可以容易地解决（比如说规模 n 较小）则直接解决，否则将其分解为 k 个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>如果原问题可分割成 k 个子问题，<code>1&lt;k≤n</code>，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<h3 id="分治法适用的情况"><a href="#分治法适用的情况" class="headerlink" title="分治法适用的情况"></a>分治法适用的情况</h3><p>分治法所能解决的问题一般具有以下几个特征：</p>
<ol>
<li>该问题的规模缩小到一定的程度就可以容易地解决</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解；</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</li>
</ol>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加。</p>
<p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用。</p>
<p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p>
<p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p>
<h3 id="分治法的基本步骤"><a href="#分治法的基本步骤" class="headerlink" title="分治法的基本步骤"></a>分治法的基本步骤</h3><p>分治法在每一层递归上都有三个步骤： Divide-and-Conquer(P)</p>
<ol>
<li>if |P|≤n0</li>
<li>then return(ADHOC(P))</li>
<li>将 P 分解为较小的子问题 P1 ,P2 ,…,Pk</li>
<li>for i←1 to k</li>
<li>do yi ← Divide-and-Conquer(Pi) 递归解决 Pi</li>
<li>T ← MERGE(y1,y2,…,yk) 合并子问题</li>
<li>return(T)</li>
</ol>
<p>其中|P|表示问题 P 的规模；n0 为一阈值，表示当问题 P 的规模不超过 n0 时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题 P。因此，当 P 的规模不超过 n0 时直接用算法 ADHOC(P)求解。算法 MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将 P 的子问题 P1 ,P2 ,…,Pk 的相应的解 y1,y2,…,yk 合并为 P 的解。</p>
<h3 id="可使用分治法求解的经典问题"><a href="#可使用分治法求解的经典问题" class="headerlink" title="可使用分治法求解的经典问题"></a>可使用分治法求解的经典问题</h3><ol>
<li>二分搜索</li>
<li>大整数乘法</li>
<li>Strassen 矩阵乘法</li>
<li>棋盘覆盖</li>
<li>合并排序</li>
<li>快速排序</li>
<li>线性时间选择</li>
<li>最接近点对问题</li>
<li>循环赛日程表</li>
<li>汉诺塔</li>
</ol>
<h3 id="依据分治法设计程序时的思维过程"><a href="#依据分治法设计程序时的思维过程" class="headerlink" title="依据分治法设计程序时的思维过程"></a>依据分治法设计程序时的思维过程</h3><p>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。</p>
<ol>
<li>一定是先找到最小问题规模时的求解方法</li>
<li>然后考虑随着问题规模增大时的求解方法</li>
<li>找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>五大常用经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前端测试开篇</title>
    <url>/2020/09/19/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="什么是自动化测试"><a href="#什么是自动化测试" class="headerlink" title="什么是自动化测试"></a>什么是自动化测试</h3><blockquote>
<p>在软件测试中，测试自动化（英语：Test automation）是一种测试方法，使用特定的软件，去控制测试流程，并比较实际的结果与预期结果之间的差异。通过将测试自动化，可以让正式的测试过程中的必要测试，可以反复进行；通过这种方法，也可以将难以手动进行的测试，交由软件来做。测试自动化的最大优势就是可以快速而且反复的进行测试。</p>
</blockquote>
<p>简单理解，自动化测试是指软件测试的自动化，让软件代替人工测试，可以快速，反复进行</p>
<p>关于自动化测试有一个金字塔理论，把测试从上到下分为 /UI（用户界面测试）/Service（服务测试） /Unit（单元测试 ）。如图所示，越往金字塔底层，测试的效率越高，测试质量保障程度越高，测试的成本越低。怎么理解这句话呢？前端项目通常 UI 变化频繁，一旦发生变化，UI 测试用例就无法执行且难以维护，所以 UI 自动化测试的成本高，收益小；相比 UI 测试，Service 测试更加简单直接且变化不会很频繁；单元测试主要对公共函数、方法进行测试，测试用例复用度高且更能保证代码质量。</p>
<a id="more"></a>

<img data-src='https://pic4.zhimg.com/80/v2-99fbbe6203ee75133178cdd5b131b4ac_720w.jpg'>

<h3 id="实现自动化测试有什么好处"><a href="#实现自动化测试有什么好处" class="headerlink" title="实现自动化测试有什么好处"></a>实现自动化测试有什么好处</h3><p>测试最重要的目的是验证代码正确性，确保项目质量。举个例子，某一天我写了一个逻辑复杂的函数，这个函数被很多地方调用，过了一个月之后，我可能忘记这里面的具体逻辑了，出于某种原因需要为这个函数增加一些功能，修改这个函数的代码，那我要怎么做才能保证修改代码后不影响其他的调用者呢，或者说，我要怎么做，才能快速的知道哪些地方受影响，哪些地方不受影响呢？答案就是实施自动化测试，跑测试用例。</p>
<p>如果不进行自动化测试，我们会如何验证代码的正确性？通常 FE 使用的方法是手动测试：console、alert、打断点、点点点。但手动测试是一次性的，如果下次有人对代码功能做了修改，我们不得不再次重复手动测试的工作，并且很难保证测试的全覆盖。但如果编写测试用例进行自动化测试，第一次写完的测试用例是可以重复使用的，一次编写，多次运行。如果测试用例写的完善、语义化，开发人员还可以通过看测试用例快速了解项目需求。实施自动化测试可以驱动开发人员在代码的设计中做更好的抽象，写可测试的代码，以测试公用方法为例，要确保被测试的方法无副作用，既对外部变量没有依赖，也不会改变全局原本的状态。</p>
<p>总结一下，实施自动化测试有四个好处：</p>
<ul>
<li>可以验证代码正确性，保证项目质量</li>
<li>测试用例可以复用，一次编写，多次运行</li>
<li>通过看测试用例可以快速了解需求</li>
<li>驱动开发，指导设计，保证写的代码可测试</li>
</ul>
<h3 id="什么样的项目适合自动化测试"><a href="#什么样的项目适合自动化测试" class="headerlink" title="什么样的项目适合自动化测试"></a>什么样的项目适合自动化测试</h3><p>自动化测试如此优秀，那是不是所有项目都适合进行自动化测试？答案是否定的，因为有成本。在实施自动化测试之前需要对软件开发过程进行分析，基于投入产出来判断是否适合实施自动化测试。实施自动化测试的项目通常需要同时满足以下条件：</p>
<ul>
<li>需求变动不频繁</li>
<li>项目周期足够长</li>
<li>自动化测试脚本可重复使用</li>
<li>代码规范可测试</li>
</ul>
<p>如果需求变动过于频繁，维护测试脚本的成本太高；如果项目周期比较短，没有足够的时间去支持自动化测试的过程；如果测试脚本重复使用率低，耗费的精力大于创造的价值，不值得；如果代码不规范，可测试性差，那自动化测试实施起来会比较困难。</p>
<hr>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>ATDD： Acceptance Test Driven Development（验收测试驱动开发）</strong></p>
<p>这是一种在编码开始之前将客户带入测试设计过程的技术。它也是一个协作实践，用户，测试人员和开发人员定义了自动验收标准。 ATDD 有助于确保所有项目成员准确理解需要完成和实施的内容。如果系统未通过测试可提供快速反馈，说明未满足要求。验收测试以业务领域术语进行指定。每个功能都必须提供真实且可衡量的业务价值，事实上，如果您的功能没有追溯至至少一个业务目标，那么您应该想知道为什么您要首先实施它。</p>
<p><strong>TDD：Test-driven development （测试驱动开发）</strong></p>
<p>是一种使用自动化单元测试来推动软件设计并强制依赖关系解耦的技术。使用这种做法的结果是一套全面的单元测试，可随时运行，以提供软件可以正常工作的反馈。TDD 重点是培养整个研发过程的节奏感，就像跳踢踏舞一样，“ti-ta-ti”。在编写真正实现功能的代码之前先编写测试，每次测试之后，重构完成，然后再次执行相同或类似的测试。该过程根据需要重复多次，直到每个单元根据所需的规格运行。</p>
<p><strong>BDD：Behavior-Driven Development (行为驱动开发)</strong></p>
<p>BDD 将 TDD 的一般技术和原理与领域驱动设计(DDD)的想法相结合。 BDD 是一个设计活动，您可以根据预期行为逐步构建功能块。BDD 的重点是软件开发过程中使用的语言和交互。行为驱动的开发人员使用他们的母语与领域驱动设计的语言相结合来描述他们的代码的目的和好处。使用 BDD 的团队应该能够以用户故事的形式提供大量的“功能文档”，并增加可执行场景或示例。 BDD 通常有助于领域专家理解实现而不是暴露代码级别测试。它通常以 GWT 格式定义：GIVEN WHEN＆THEN。</p>
<blockquote>
<p>小结：TDD 的原理是在开发功能代码之前，先编写单元测试用例代码（先写测试再开发，一般都是单元测试，白盒测试）；BDD 的原理是系统业务专家、开发者、测试人员一起合作，分析软件的需求，然后将这些需求写成一个个的故事。开发者负责填充这些故事的内容，保证程序实现效果与用户需求一致。也就是 BDD 是按照用户的行为来开发，再根据用户的行为编写测试用例 （一般都是集成测试，黑盒测试）</p>
</blockquote>
<h3 id="黑盒测试和白盒测试"><a href="#黑盒测试和白盒测试" class="headerlink" title="黑盒测试和白盒测试"></a>黑盒测试和白盒测试</h3><ul>
<li>黑盒测试一般也被称为功能测试，黑盒测试要求测试人员将程序看作一个整体，不考虑其内部结构和特性，只是按照期望验证程序是否能正常工作</li>
<li>白盒测试是基于代码本身的测试，一般指对代码逻辑结构的测试。</li>
</ul>
<h3 id="测试分类（部分）"><a href="#测试分类（部分）" class="headerlink" title="测试分类（部分）"></a>测试分类（部分）</h3><p>单元测试(Unit Testing)</p>
<ul>
<li>对软件中的最小可测试单元进行检查和验证。例如测试一个函数、一个模块、一个组件…，前端所说的单元测试就是对一个模块进行测试。也就是说前端测试的时候，你测试的东西一定是一个模块。</li>
</ul>
<p>集成测试(Integration Testing)</p>
<ul>
<li>将已测试过的单元测试函数进行组合集成暴露出的高层函数或类的封装，对这些函数或类进行的测试</li>
</ul>
<p>端到端测试(E2E Testing)</p>
<ul>
<li>打开应用程序模拟输入，检查功能以及界面是否正确</li>
</ul>
]]></content>
      <categories>
        <category>前端自动化测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>工程体系</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法</title>
    <url>/2020/11/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程叫做动态规划</p>
<h3 id="基本思想与决策"><a href="#基本思想与决策" class="headerlink" title="基本思想与决策"></a>基本思想与决策</h3><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<p>与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<h3 id="适用的情况"><a href="#适用的情况" class="headerlink" title="适用的情况"></a>适用的情况</h3><p>能采用动态规划求解的问题的一般要具有 3 个性质：</p>
<ol>
<li>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</li>
<li>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</li>
<li>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</li>
</ol>
<h3 id="求解的基本步骤"><a href="#求解的基本步骤" class="headerlink" title="求解的基本步骤"></a>求解的基本步骤</h3><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p>
<blockquote>
<p>初始状态 →│ 决策１ │→│ 决策２ │→…→│ 决策ｎ │→ 结束状态</p>
</blockquote>
<ol>
<li>划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</li>
<li>确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</li>
<li>确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</li>
<li>寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。实际应用中可以按以下几个简化的步骤进行设计： 1. 分析最优解的性质，并刻画其结构特征。 2. 递归的定义最优解。 3. 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 4. 根据计算最优值时得到的信息，构造问题的最优解</li>
</ol>
<h3 id="算法实现的说明"><a href="#算法实现的说明" class="headerlink" title="算法实现的说明"></a>算法实现的说明</h3><p>动态规划的主要难点在于理论上的设计，也就是上面 4 个步骤的确定，一旦设计完成，实现部分就会非常简单。</p>
<p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p>
<ol>
<li>问题的阶段</li>
<li>每个阶段的状态</li>
<li>从前一个阶段转化到后一个阶段之间的递推关系。</li>
</ol>
<p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p>
<p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从 1 行 1 列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p>
<blockquote>
<p>f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>五大常用经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2020/09/22/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>假设有一个快餐店，而我是快餐店的点餐服务员，那么我一天的工作应该是这样的，当某位客人点餐或者打来订餐电话后，我会把它的需求都写在清单上，然后提交给厨房，客人不同关心是那些厨师帮他炒菜，我们餐厅还可以满足可客人的需要的定时服务，比如客人可能当前正在回家的路上，要求一个小时后才开始炒他的菜，只要订单还在，厨师就不会忘记，客人也可以很方便的打电话来撤销订单，另外如果有太多的客人点单，厨师可以按照订单的顺序排队炒菜</p>
<p>这些记录着订餐信息的清单，便是命令模式中的命令对象</p>
<h2 id="命令模式的用途"><a href="#命令模式的用途" class="headerlink" title="命令模式的用途"></a>命令模式的用途</h2><p>命令模式是最简单的优雅模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令</p>
<p>命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么，此时希望有一种松耦合的方式来设计程序的，使得请求送者和请求接收者能够消除彼此间的耦合关系</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法</title>
    <url>/2020/11/05/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现以不满足条件时，就 “回溯” 返回，尝试别的路径。</p>
<p>回溯法是一种优先搜索法，按选优条件向前搜索，但当探索到某一步时，发现原先选择并不优或达不到目标，就返回一步重新选择，这种走走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。</p>
<p>许多复杂的，规模较大的问题都可以适用回溯法，有 “通用解提方法” 的美称</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在包含问题的所有解的空间树中，按照深度优先搜索的策略，从根节点出发深度探索解空间树，当探索到某一节点的时候，要先判断该节点是否包含问题的解，就从该节点继续探索下去，如果该节点不包含问题的解，则逐层向其祖先节点回溯，（其实回溯法就是对隐式图的深度优先搜索算法）</p>
<p>若用回溯法求问题的所有解时，要回溯到根，其根节点的所有可行的子树都要以被搜索遍才结束</p>
<p>而若使用回溯法求任一解时，只要搜索到问题的第一个解就可以结束</p>
<h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol>
<li>针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</li>
<li>确定结点的扩展搜索规则</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>五大常用经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>声明合并</title>
    <url>/2020/09/20/%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Typescript 中有些独特的概念可以在类型层面上描述 JavaScript 对象类型，这其中有其独特的有一个例子是“声明合并”的概念，理解了这个概念，将有助于操作现有的 JavaScript 代码，同时，也会有助于理解更多高级抽象的概念，</p>
<p>对本文来说，“声明合并”是指编译器将针对同一个名字的两个独立声明合并为一个声明，合并后的声明同时拥有原先两个声明的特性，任何数量的声明都可以被合并；并不局限于两个</p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>typescript 的声明会创建以下三种实体之一：命名空间，类型或值，创建命名空间的声明会新建一个命名空间，它包含了（.）符号来方式时使用的名字，创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上，最后，创建值的声明会创建在 JavaScript 输出中看到的值</p>
<blockquote>
<p>创建一个命名空间其实就是创建了一个对象，命名空间中用 export 导出的值都会成为兑现的属性</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Declaration Type</th>
<th align="center">Namespace</th>
<th align="center">Type</th>
<th align="center">Value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Namespace（命名空间）</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">Class（类）</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">Enum（枚举）</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">Interface（接口）</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Type Alias（类型别名）</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Function（函数）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">Variable（值）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>理解每个声明创建了什么，有助于理解当声明合并时有哪些东西被合并了</p>
<h3 id="合并接口"><a href="#合并接口" class="headerlink" title="合并接口"></a>合并接口</h3><p>最简单也最常见的声明合并是接口合并，从根本上说，合并的机制是把双方的成员放到一个同名的接口里</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Box &#123;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Box &#123;</span><br><span class="line">  scale: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> box: Box = &#123; height: <span class="number">5</span>, width: <span class="number">6</span>, scale: <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>接口的非函数成员应该是唯一的，如果他们不是唯一的，那么他们必须是相同的类型，如果两个接口同时声明了同名的非函数成员且他们的类型不同，则编译器会报错</p>
<p>对于函数成员，每个同名的函数声明都会被当成函数的一个重载，同时需要注意，当接口 A 与后来的接口 A 合并的时候，后面的接口具有更高的优先级</p>
<p>如下例所示</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Animal): Animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Sheep): Sheep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Dog): Dog;</span><br><span class="line">  clone(animal: Cat): Cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个接口会合并成一个声明</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Dog): Dog;</span><br><span class="line">  clone(animal: Cat): Cat;</span><br><span class="line">  clone(animal: Sheep): Sheep;</span><br><span class="line">  clone(animal: Animal): Animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前位置。</p>
<p>这个规则有一个例外是当出现特殊的函数签名时。 如果签名里有一个参数的类型是 <em>单一</em>的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。</p>
<p>比如，下面的接口会合并到一起：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">  createElement(tagName: <span class="built_in">any</span>): Element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;div&quot;</span>): HTMLDivElement;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;span&quot;</span>): HTMLSpanElement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">  createElement(tagName: <span class="built_in">string</span>): HTMLElement;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;canvas&quot;</span>): HTMLCanvasElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并后的 <code>Document</code>将会像下面这样：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;canvas&quot;</span>): HTMLCanvasElement;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;div&quot;</span>): HTMLDivElement;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;span&quot;</span>): HTMLSpanElement;</span><br><span class="line">  createElement(tagName: <span class="built_in">string</span>): HTMLElement;</span><br><span class="line">  createElement(tagName: <span class="built_in">any</span>): Element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并命名空间"><a href="#合并命名空间" class="headerlink" title="合并命名空间"></a>合并命名空间</h3><p>与接口类似，同名的命名空间也会合并其成员，命名空间创建出命名空间和值，我们需要知道这两者是怎们合并的</p>
<p>对于命名空间的合并，模块导出的同名接口进行合并，</p>
<p>对于命名空间里值的合并，如果当前已经存在的给定名字的命名空间，那么后来的命名空间的导出成员会被加到以存在的那个模块里</p>
<p><code>Animals</code>声明合并示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animals &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Zebra &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Animals &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Legged &#123;</span><br><span class="line">    numberOfLegs: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Dog &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animals &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Legged &#123;</span><br><span class="line">    numberOfLegs: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Zebra &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Dog &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这些合并外，你还需要了解非导出成员是如何处理的，非导出成员仅在其原有（合并前）命名空间内可以，这就是说合并之后，从其他命名空间合并进来的成员无法访问非导出成员</p>
<p>看下面例子</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animal &#123;</span><br><span class="line">  <span class="keyword">let</span> haveMuscles = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">animalsHaveMuscles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> haveMuscles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Animal &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doAnimalsHaveMuscles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> haveMuscles; <span class="comment">// Error, because haveMuscles is not accessible here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>haveMuscles</code>并没有导出，只有 <code>animalsHaveMuscles</code>函数共享了原始未合并的命名空间可以访问这个变量。 <code>doAnimalsHaveMuscles</code>函数虽是合并命名空间的一部分，但是访问不了未导出的成员。</p>
<h3 id="命名空间与类和函数和枚举类型合并"><a href="#命名空间与类和函数和枚举类型合并" class="headerlink" title="命名空间与类和函数和枚举类型合并"></a>命名空间与类和函数和枚举类型合并</h3><p>命名空间可以与其他类型的声明进行合并，只要命名空间的定义符合将要合并类型的定义，合并结果包含两者的声明类型，typescript 使用这个功能去实现一些 JavaScript 里的设计模式</p>
<h4 id="合并命名空间和类"><a href="#合并命名空间和类" class="headerlink" title="合并命名空间和类"></a>合并命名空间和类</h4><p>这让我们可以表示内部类</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Album &#123;</span><br><span class="line">  label: Album.AlbumLabel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Album &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> AlbumLabel &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并规则与上面 <code>合并命名空间</code>小节里讲的规则一致，我们必须导出 <code>AlbumLabel</code>类，好让合并的类能访问。 合并结果是一个类并带有一个内部类。 你也可以使用命名空间为类增加一些静态属性。</p>
<p>除了内部类的模式，你在 JavaScript 里，创建一个函数稍后扩展它增加一些属性也是很常见的。 TypeScript 使用声明合并来达到这个目的并保证类型安全。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildLabel</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildLabel.prefix + name + buildLabel.suffix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> buildLabel &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> suffix = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> prefix = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buildLabel(<span class="string">&quot;Sam Smith&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>相似的，命名空间可以用来扩展枚举型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  red = <span class="number">1</span>,</span><br><span class="line">  green = <span class="number">2</span>,</span><br><span class="line">  blue = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Color &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixColor</span>(<span class="params">colorName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (colorName == <span class="string">&quot;yellow&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Color.red + Color.green;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorName == <span class="string">&quot;white&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Color.red + Color.green + Color.blue;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorName == <span class="string">&quot;magenta&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Color.red + Color.blue;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorName == <span class="string">&quot;cyan&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Color.green + Color.blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非法的合并"><a href="#非法的合并" class="headerlink" title="非法的合并"></a>非法的合并</h3><p>TypeScript 并非允许所有的合并。 目前，类不能与其它类或变量合并。 想要了解如何模仿类的合并，请参考 <a href="https://www.tslang.cn/docs/handbook/mixins.html">TypeScript 的混入</a>。</p>
<h3 id="模块扩展"><a href="#模块扩展" class="headerlink" title="模块扩展"></a>模块扩展</h3><p>虽然 JavaScript 不支持合并，但你可以为导出的对西昂打补丁以更新他们，让我们考察以下这个玩具性的示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// observable.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Observable&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ... implementation left as an exercise for the reader ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">&quot;./observable&quot;</span>;</span><br><span class="line">Observable.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... another exercise for the reader</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它也可以很好地工作在 TypeScript 中， 但编译器对 <code>Observable.prototype.map</code>一无所知。 你可以使用扩展模块来将它告诉编译器：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// observable.ts stays the same</span></span><br><span class="line"><span class="comment">// map.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">&quot;./observable&quot;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;./observable&quot; &#123;</span><br><span class="line">  <span class="keyword">interface</span> Observable&lt;T&gt; &#123;</span><br><span class="line">    map&lt;U&gt;(f: <span class="function">(<span class="params">x: T</span>) =&gt;</span> U): Observable&lt;U&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Observable.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... another exercise for the reader</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// consumer.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">&quot;./observable&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./map&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> o: Observable&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">o.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x.toFixed());</span><br></pre></td></tr></table></figure>

<p>模块名的解析和用 <code>import</code>/ <code>export</code>解析模块标识符的方式是一致的。 更多信息请参考 <a href="https://www.tslang.cn/docs/handbook/modules.html">Modules</a>。 当这些声明在扩展中合并时，就好像在原始位置被声明了一样。 但是，你不能在扩展中声明新的顶级声明－仅可以扩展模块中已经存在的声明。</p>
<h4 id="全局扩展"><a href="#全局扩展" class="headerlink" title="全局扩展"></a>全局扩展</h4><p>你也以在模块内部添加声明到全局作用域中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; observable.ts</span><br><span class="line">export class Observable&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; ... still no implementation ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare global &#123;</span><br><span class="line">    interface Array&lt;T&gt; &#123;</span><br><span class="line">        toObservable(): Observable&lt;T&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.toObservable &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局扩展与模块扩展的行为和限制是相同的。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>声明式编程和命令式编程有什么区别？</title>
    <url>/2020/11/16/%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<p>计算机系统是分层的，也就是下层做一些支持的工作暴露接口给上层用。</p>
<blockquote>
<p>注意：语言的本质是一种接口。</p>
</blockquote>
<p>计算机的最下层是 CPU 指令，其本质就是用“变量定义+顺序执行+分支判断+循环”所表达的逻辑过程。计算机应用的最上层是实现人类社会的某种功能。所以所有计算机编码的过程，就是用逻辑表达现实的过程。层与层之间定义的借接口，越接近现实的表达就叫越“声明式”（declarative），越接近计算机的执行过程就叫越“命令式”（imperative）。注意这不是绝对的概念，而是相对的概念。</p>
<p>当接口越是在表达“要什么”，就是越声明式；越是在表达“要怎样”，就是越命令式。SQL 就是在表达要什么（数据），而不是表达怎么弄出我要的数据，所以它就很“声明式”。C++就比 C 更声明式，因为面向对象本身就是一种声明式的体现。HTML 也很声明式，它只描述我要一张什么样的表，并不表达怎么弄出一张表。</p>
<p>简单的说，接口的表述方式越接近人类语言——词汇的串行连接（一个词汇实际上是一个概念）——就越“声明式”；越接近计算机语言——“顺序+分支+循环”的操作流程——就越“命令</p>
<p>越是声明式，意味着下层要做更多的东西，或者说能力越强。也意味着效率的损失。越是命令式，意味着上层对下层有更多的操作空间，可以按照自己特定的需求要求下层按照某种方式来处理。</p>
<p>实际上，这对概念应该叫做“声明式接口”和“命令式接口”。可能是因为它大部分时候是在谈论“语言”这种接口方式时才会用到，所以会叫做“声明式编程”和“命令式编程”。</p>
<p>当然，你也可以把它当成一种编程思想，也就是说，在构建自己的代码时，为了结构的清晰可读，把代码分层，层之间的接口尽量声明式。这样你的代码自然在一层上主要描述从人的角度需要什么；另一层上用计算机逻辑实现人的需要。</p>
<p>另外，这组概念总让人迷惑，可能一个原因是翻译问题。如果翻译成”说明式“和”指令式“应该容易理解的多。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>带你深入理解图灵机-什么是人工智能AI？</title>
    <url>/2020/11/09/%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%BE%E7%81%B5%E6%9C%BA-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BDAI%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="一、什么是机器？"><a href="#一、什么是机器？" class="headerlink" title="一、什么是机器？"></a>一、什么是机器？</h1><p>为了方便大家回忆和理解，我们简单做下回顾希尔伯特提出的第十数学问题：</p>
<blockquote>
<p>随便给一个不确定的方程，是否通过有限的步骤运算，判断这个方程是否存在整数解？</p>
</blockquote>
<p>对于这个问题，大家普遍认为，这样的一套步骤是不存在的，也就是说我们没有一种判断一个数学命题是否为真的通用方法。其实这里最关键的问题是：<strong>什么叫做“一系列有限的步骤”</strong>？</p>
<p>在没有计算机的时代，人们对“一系列有限的步骤”的体会是模糊。现在大家都很清楚了，其实就是算法，是有读写、条件、循环、移动等组成的一个机械过程，对于<strong>“读写、条件、循环、移动”</strong>这几个词语还眼熟吗？没错，在图灵机组成中出现过，图灵机就是这样的一个假象的机器，第一次给“机械过程、一系列有限的步骤”一个确定的数学定义。</p>
<p>图灵机的定义其实很简单。包含 4 个部分：</p>
<ol>
<li>一个无限长的存储带</li>
<li>一个读写头，读写头可以在存储带上左右移动</li>
<li>内部状态存储器</li>
<li>控制程序指令</li>
</ol>
<p>从上一篇文章介绍的虫子的举例中，我们知道通过不同的指令，就可以实现不同的虫子移动。实际上，通过精心设计不同的指令，我们可以用图灵机打印斐波那契数列，圆周率等，实际上我们现在用电脑，手机进行文字、语音、视频交互，看图片，看电影等等这些所有的功能都是用图灵机的方式实现的。</p>
<hr>
<h1 id="二、什么是智能（Think）？"><a href="#二、什么是智能（Think）？" class="headerlink" title="二、什么是智能（Think）？"></a>二、什么是智能（Think）？</h1><p>图灵在 1950 年写过一篇论文《计算机器与智能》，有兴趣的同学可以看下，英文版论文，链接是：<a href="https://www.csee.umbc.edu/courses/471/papers/turing.pdf">https://www.csee.umbc.edu/courses/471/papers/turing.pdf</a> 图灵的这篇论文写的太棒了，我们对人工智能的异议、担心、误解图灵都已经想到了，后续笔者有时间会对该篇论文进行一次解读。所以，对于这篇论文，建议大家都去看下，笔者搜索到一版中文翻译版，有兴趣去看看：<a href="https://wenku.baidu.com/view/1e464d1a376baf1ffc4fada8.html?rec_flag=default&amp;sxts=1530772880292">https://wenku.baidu.com/view/1e464d1a376baf1ffc4fada8.html?rec_flag=default&amp;sxts=1530772880292</a></p>
<p>在开篇的 “The Imitation Game”中，图灵让我们思考：<strong>“机器能否拥有智能？（Can machines think？）</strong>”这个问题。有趣的是，作为计算理论和人工智能领域的天才，图灵成功定义了什么是计算机器（即图灵机），但却不能定义什么是智能（Think）,没有办法用机器或算法来准确定义。因此，图灵设计了一个后人称为图灵测试的模拟游戏。图灵测试的核心想法是要求计算机在没有直接物理接触的情况下接受人类的询问，并尽可能把自己伪装成人类。这个游戏有点类似杀人游戏，这个**”模拟游戏”**大概是这样的：</p>
<blockquote>
<p>游戏参与者包括一个男人，一个女人，以及一个任意性别的询问者。 询问者与另两个人待在不同的房间里，并通过打字的方式与他们交流，以确保询问者不能通过声音和笔迹区分二者。</p>
<p>两位被询问者分别用 X 和 Y 表示，询问者用 C 表示，询问者 C 事先只知道 X 和 Y 中 有且仅有一位女性，而询问的目标是正确分辨 X 和 Y 中哪一位是女性。另一方面，两位被询问者 X 和 Y 的目标都是试图让询问者认为自己是女性。也就是说，男性被询问者需要把自己伪装成女性，而女性被询问者需要努力自证。</p>
<p>现在我们问：如果我们把“模仿游戏”中的男性被询问者换成计算机，结果会怎样？相比人类男性，计算机能否使询问者更容易产生误判？”</p>
</blockquote>
<p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/1bb628716cf805b9.webp"></p>
<p>智能行为与人类行为的关系</p>
<p>图灵测试其实对人工智能的一种充分的等价性。 如上图所示，“所有智能行为”对应的集合和“所有人类行为”对应的集合既有交集又互有不同。在全部智能行为中有一些是人类靠自身无法做到的（比如计算出国际象棋中白棋是否必胜），但人类也是有智能的，因此只要完成两个集合的交集部分—就应该被认作是“拥有智能”的。另一方面，人类行为并不总是和智能相关。图灵测试要求机器全面模拟“所有人类行为”，其中既包括了两个集合的交集，也包括了人类的“非智能”行为。</p>
<p>因此图灵测试是 “拥有智能”的一个有效的充分条件，也就是说，由于没有办法严格定义智能，图灵把智能测试的范围扩大了，即不一定要全部通过图灵测试才算是真正的人工智能。</p>
<p>在图灵看来，人的智能（不包含人的所有，比如皮肤，宫保鸡丁和鱼香肉丝哪个更好吃？）是可以用图灵机来模拟的，因为人的智能是某种模式，即一系列机械步骤形成的。</p>
<h1 id="三、现在人工智能-AI-的实现技术有哪些？"><a href="#三、现在人工智能-AI-的实现技术有哪些？" class="headerlink" title="三、现在人工智能 AI 的实现技术有哪些？"></a>三、现在人工智能 AI 的实现技术有哪些？</h1><p>近几年，人工智能 AI 是被提及的概念。阿尔法狗，苹果的 siri，google assistant，微软小冰，百度大脑，无人驾驶，AI 等等，都被冠以人工智能的概念，不说好像不好意思一样。那么 AI 的实现技术有哪些呢？</p>
<h2 id="1，传统的机器学习"><a href="#1，传统的机器学习" class="headerlink" title="1，传统的机器学习"></a>1，传统的机器学习</h2><p>传统的机器学习是一种归纳法，主要思想是通过一些特征样本，试图从样本中发现一些规律，提取特征值，然后把这些特征放到各种机器学习模型中，实现对新的数据和行为进行智能识别和预测。</p>
<p>这种实现方式的的理论基础其实就是统计学，也是人类观察世界，认识世界的一种方式。不过缺点是：<strong>需要人工整理好大量的、尽量覆盖全的样本，是无疑是一个巨大的工作。</strong></p>
<h2 id="2，深度学习"><a href="#2，深度学习" class="headerlink" title="2，深度学习"></a>2，深度学习</h2><p>传统的机器学习是要输入特征样本，而深度学习是试图从海量的数据中让机器自动提取特征，深度学习也是一种机器学习，这种方式需要输入海量的大数据，让机器从中找到弱关联关系，这种方式比传统机器学习方式减少大量人工整理样本的工作，识别准确率也提高了很多，让人工智能在语音识别、自然语言处理、图片识别等领域达到了可用的程度，是革命的进步。</p>
<p>深度学习实现方式源于多层神经网络，把特征表示和学习合二为一，特点是放弃了可解释性，寻找关联性。简单白话一下深度学习的工作原理：一个神经元就是一个分类器，神经元模型就是不停的分类，形成规模效率和网络效率，最终高质量的特征值就奇妙的产生了。不过缺点是：<strong>神经元的参数调整依然高度依赖人的经验。</strong></p>
<h2 id="3，其他更好的人工智能技术？"><a href="#3，其他更好的人工智能技术？" class="headerlink" title="3，其他更好的人工智能技术？"></a>3，其他更好的人工智能技术？</h2><p>现在很多网站要求输入验证码来验证登录，这里的目的是防止机器人模拟登录，比如 12306 要求你找出某一类物品，现在机器还不能很好的通过模式识别出来，但是人类可以。反过来来讲，如果让机器收集人类的这些验证码的识别结果，是否让机器学会人类的识别模式？目前已经很多公司开始了以人工的人工智能方法。当然还有更多更好的方法在不断探索中。</p>
<h1 id="四、人工智能-AI-能取代人吗？"><a href="#四、人工智能-AI-能取代人吗？" class="headerlink" title="四、人工智能 AI 能取代人吗？"></a>四、人工智能 AI 能取代人吗？</h1><p>2016 年阿尔法狗战胜围棋世界冠军，攻破了人类智力的引以为傲的最后一道防线，一年后，阿尔法狗升级版 master 战胜了阿尔法狗第一版，并通过和自己不断对弈，以人们不可想象的速度快速的进步，最后以全胜的绝对优势打败了世界排名第一的柯洁，甚至让柯洁产生了无力感，至此人类围棋棋手已经不可能战胜以阿尔法狗为代表人工智能机器。</p>
]]></content>
      <categories>
        <category>图灵</category>
        <category>玄学</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>带你深入理解图灵机-图灵机,图灵完备</title>
    <url>/2020/11/09/%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%BE%E7%81%B5%E6%9C%BA-%E5%9B%BE%E7%81%B5%E6%9C%BA,%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/</url>
    <content><![CDATA[<p>上一篇介绍了天才图灵所做的时代背景，我们了解那个时代对于数学逻辑，可计算理论的发展。站在更大的时间和空间维度来看，我们看问题的角度会有更高的视角。</p>
<p><strong>这篇我们来具体看下图灵机到底是什么？</strong></p>
<h2 id="一、图灵机的组成"><a href="#一、图灵机的组成" class="headerlink" title="一、图灵机的组成"></a>一、图灵机的组成</h2><p>网上有一张经典的图片来表达图灵机的构成，图如下：</p>
<p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/8cb735f76c4a001f.webp"></p>
<blockquote>
<p>这张图片什么意思？这么一个简单的机器/装置怎么会所有电子计算机的理论模型？</p>
</blockquote>
<p>相信大家看到这张图后都有这样的疑问，下面笔者带来由浅入深去理解图灵机的组成。 图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，它运算过程看作下列两种简单的动作：</p>
<ul>
<li>在纸上写上或擦除某个符号；</li>
<li>把注意力从纸的一个位置移动到另一个位置；</li>
</ul>
<p>逻辑结构上图灵机有四个部分组成</p>
<ol>
<li>一个无限长的存储带，带子有一个个连续的存储格子组成，每个格子可以存储一个数字或符号</li>
<li>一个读写头，读写头可以在存储带上左右移动，并可以读、修改存储格上的数字或符号</li>
<li>内部状态存储器，该存储器可以记录图灵机的当前状态，并且有一种特殊状态为<strong>停机状态</strong></li>
<li>控制程序指令，指令可以根据当前状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作（左移还是右移），并改变状态存储器的值，令机器进入一个新的状态或保持状态不变。</li>
</ol>
<p>当然这些只是理想的图灵机，因为现实中不存在无限长的存储带，更加图灵的理论这样的一台装置就能模拟人类所能进行的任何计算过程。是不是很神奇？我相信你肯定不相信，不过图灵是经过严格的数学证明，下面我们来看看图灵机的计算过程。</p>
<h2 id="二、图灵机的运行机制"><a href="#二、图灵机的运行机制" class="headerlink" title="二、图灵机的运行机制"></a>二、图灵机的运行机制</h2><p><strong>图灵机工作步骤</strong></p>
<ol>
<li><p>准备</p>
<ul>
<li>存储带子上的格子初始话</li>
<li>设置内部状态存储器当前状态</li>
<li>读写头设置初始在存储带上所做的格子位置</li>
<li>准备好控制指令，即控制程序。</li>
</ul>
</li>
<li><p>反复执行以下步骤，直到停机</p>
<ul>
<li>读写头读出当前格子的数字或符号</li>
<li>根据当前状态和读到的字母或符号找到对应的控制指令</li>
<li>根据控制指令，执行以下三个动作<ol>
<li>读写头在格子上擦除或写入一个数字或符号</li>
<li>变更状态到一个新状态</li>
<li>读写头向左或向右移动一格</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>估计你还是不明白，别急。看过《三体》的同学都知道三体人把地球人看做<strong>“虫子”</strong>，三体人的维度比地球三维世界高，就好像我们人类把看虫子一样。 下面，我们把虫子放到一个二维的世界中，以虫子为例，给大家来说明最简单的图灵机模型（注：该例子非原创）。</p>
<h4 id="假设理想的情况一："><a href="#假设理想的情况一：" class="headerlink" title="假设理想的情况一："></a>假设理想的情况一：</h4><ol>
<li>虫子所处的二维世界是一个无限长的纸带，这个纸带上被分成了若干小的方格，而每个方格都仅仅只有黑和白两种颜色。纸带的片段为：</li>
</ol>
<p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/42a1a69153b1d912.webp"></p>
<ol start="2">
<li><p>假设虫子的感官只有眼睛，并且它的视力短的可怜，只能看到当前所处格子的颜色</p>
</li>
<li><p>虫子可以向前爬一个格子或向后爬一个格子</p>
</li>
<li><p>虫子的操作系统、程序为：我们假设黑色是食物区，虫子吃到食物后前移一格，白色是空白区，没有食物后退一格，</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>输入</th>
<th align="right">输出</th>
</tr>
</thead>
<tbody><tr>
<td>黑色</td>
<td align="right">前移一格</td>
</tr>
<tr>
<td>白色</td>
<td align="right">后移一格</td>
</tr>
</tbody></table>
<p>在这个情况中格子的颜色是虫子的输入信息，集合为 IN={黑色，白色}，输出集合为 OUT= {前移一格，后移一格} 从开始位置开始，虫子会怎么移动呢？</p>
<ol>
<li>开始是黑色，虫子前移一格，到达第 2 格</li>
<li>第 2 还是黑色，虫子前移一格，到达第 3 格</li>
<li>第 3 格还是黑色，虫子前移一格，到达第 4 格</li>
<li>第 4 格为白色，虫子后移一格，回到第 3 格</li>
<li>可见，这条带子上，虫子在第 4 格和第 3 格来回移动循环不止。</li>
</ol>
<h5 id="假设理想的情况二"><a href="#假设理想的情况二" class="headerlink" title="假设理想的情况二"></a>假设理想的情况二</h5><p>现实中虫子肯定不可能傻到无线循环，虫子会有饥饿、吃饱的感受，食物吃了后也会消失。因此我们在情况下中改进下模型。</p>
<ol>
<li>虫子在黑色的格子时，如果是饥饿状态，吃掉食物把格子变成白色；如果是吃饱状态，后移一格</li>
<li>虫子在白色的格子时，如果是饥饿状态，停下来等食物长出来涂黑；如果是吃饱状态，前移一格</li>
<li>虫子的操作系统、程序为：</li>
</ol>
<table>
<thead>
<tr>
<th>输入</th>
<th align="right">当前状态</th>
<th align="right">输出</th>
<th align="right">下一个状态</th>
</tr>
</thead>
<tbody><tr>
<td>黑色</td>
<td align="right">吃饱</td>
<td align="right">后移一格</td>
<td align="right">饥饿</td>
</tr>
<tr>
<td>黑色</td>
<td align="right">饥饿</td>
<td align="right">吃完食物格子变白（不移动）</td>
<td align="right">吃饱</td>
</tr>
<tr>
<td>白色</td>
<td align="right">吃饱</td>
<td align="right">前移一格</td>
<td align="right">饥饿</td>
</tr>
<tr>
<td>白色</td>
<td align="right">饥饿</td>
<td align="right">等待食物长出来涂黑（不移动）</td>
<td align="right">吃饱</td>
</tr>
</tbody></table>
<p>在这种情况中，输入集合为 IN={黑色，白色}，输出集合为 OUT= {前移一格，后移一格，吃掉食物涂白，等待食物长出来涂黑}，内部状态 S={吃饱，饥饿}</p>
<p>二维纸带不变，从开始位置开始，<strong>虫子初始是饥饿状态</strong>，虫子会怎么移动呢？</p>
<ol>
<li>第 1 格是黑色，虫子饥饿，吃掉食物格子变白，虫子新状态为吃饱</li>
<li>第 1 格为白色，虫子吃饱，虫子前移一格，到达第 2 格，虫子新状态为饥饿</li>
<li>第 2 格为黑色，虫子饥饿，吃掉食物格子变白，虫子新状态为吃饱</li>
<li>第 2 格为白色，虫子吃饱，虫子前移一格，到达第 3 格，虫子新状态为饥饿</li>
<li>第 3 格为黑色，虫子饥饿，吃掉食物格子变白，虫子新状态为吃饱</li>
<li>第 3 格为白色，虫子吃饱，虫子前移一格，到达第 4 格，虫子新状态为饥饿</li>
<li>第 4 格为白色，虫子饥饿，等待食物长出来涂黑，虫子新状态为吃饱</li>
<li>第 4 格为黑色，虫子吃饱，虫子后退一格，到达第 3 格，虫子新状态为饥饿</li>
<li>这时，第 3 格已经长出来食物，是黑色，因此流程和第 5 步的情况一样了</li>
</ol>
<p>情况二，小虫的行为比情况以复杂了一些，但小虫最后仍然会落入无限循环当中。</p>
<blockquote>
<p>到此，如果你已经彻底搞懂了二维虫子是怎么移动的，那么你已经明白了图灵机的工作原理了！因为从本质上讲，最后的小虫模型就是一个图灵机！</p>
</blockquote>
<h3 id="三、如何理解图灵机"><a href="#三、如何理解图灵机" class="headerlink" title="三、如何理解图灵机"></a>三、如何理解图灵机</h3><p>刚才用二维虫子说明了图灵机的工作原理，相信你的第一个反映就是，这样的模型太简单了！ 他根本说明不了现实世界中的任何问题！下面，我就要试图说服你，图灵机这个模型是伟大的！</p>
<p>其实虫子的所有决策和行为都可以抽象成一个图灵机模型。</p>
<p>为什么可以做这种抽象呢？ 其实可以把二维虫子的模型进行更多扩展，以和现实世界基本或完全一致。因为二维虫子模型是以一切都简化的前提开始的，所以它的确是太太简单了。</p>
<p>然而，我们可以把二维虫子的输入集合、输出行动集合、内部状态集合进行扩大，这个模型就一下子实用多了。</p>
<ol>
<li>二维虫子完全可以处于一个三维的空间中而不是简简单单的纸带。</li>
<li>二维虫子的视力很好，它一下子能读到方圆 500 米的信息。</li>
<li>二维虫子也可以拥有其他的感觉器官，比如嗅觉、听觉等等，而这些改变都仅仅是扩大了输入集合的维数和范围，并没有其他更本质的改变。</li>
<li>二维虫子可能的输出集合也是异常的丰富，它不仅仅能移动自己，还可以尽情的改造它所在的自然界。</li>
<li>进一步的，二维虫子的内部状态可能非常的多，而且控制它行为的程序可能异常复杂</li>
</ol>
<p>那么二维虫子会有什么本事呢？这就很难说了，因为随着小虫内部的状态数的增加，随着它所处环境的复杂度的增加，我们正在逐渐失去对二维虫子行为的预测能力。</p>
<blockquote>
<p>但是所有这些改变仍然没有逃出图灵机的模型： <strong>“输入集合、输出集合、内部状态、固定的程序指令！”</strong> 就是这四样东西抓住了二维虫子信息处理的根本。</p>
</blockquote>
<h3 id="四、-什么是图灵完备"><a href="#四、-什么是图灵完备" class="headerlink" title="四、 什么是图灵完备"></a>四、 什么是图灵完备</h3><p>维基百科解释：</p>
<blockquote>
<p>可图灵指在可计算性理论中，编程语言或任意其他的逻辑系统如具有等用于通用图灵机的计算能力。换言之，此系统可与通用图灵机互相模拟。</p>
</blockquote>
<p>上面的解释比较抽象，通过上面的例子理解了什么是图灵机，图灵完备其实就很很简单理解了。</p>
<blockquote>
<p>简单来说，能够抽象成图灵机的系统或编程语言就是图灵完备的；一切可计算的问题图灵机都能计算，因此满足这样要求的逻辑系统、装置或者编程语言就叫图灵完备的。</p>
</blockquote>
<p>因此可见，二维虫子是图灵完备的。</p>
<p>Bitcoin 的脚本由于没有条件分支，循环等控制指令，回到上面的虫子的例子，虫子就不能根据当前状态，判断选择移动还是吃食物等一系列的动作，因此不满足图灵机的模型，不是图灵完备的。</p>
<h3 id="五、人也是图灵机？"><a href="#五、人也是图灵机？" class="headerlink" title="五、人也是图灵机？"></a>五、人也是图灵机？</h3><p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/eaa00245c0f4f8d0.webp"></p>
<p>我们人能不能也被这样的抽象呢？<strong>显然是可以的。</strong></p>
<p>其实我们每一个会决策、会思考的人就可以被抽象的看成一个图灵机，也就是笑来老师一直说：每个人都有自己的操作系统，因为有元认知能力，还可以自己升级操作系统。</p>
<p>输入状态集合就是你所处的环境中能够看到、听到、闻到、感觉到的所有一起，可能的输出集合就是你的每一言每一行，以及你能够表达出来的所有表情动作。内部状态集合则要复杂得多。因为我们可以把任意一个神经细胞的状态组合看作是一个内部状态，那么所有可能的神经细胞的状态组合将是天文数字！这就是人类的记忆。只要图灵机具有了内部状态，它就相应的具有了记忆。</p>
<p>这样理解的话，还有两个问题：</p>
<ol>
<li>图灵机的程序指令是固定的。但是人类有学习能力，也就是说人的大脑会进化，操作系统会升级，所以大脑的实际程序规则是不固定，似乎图灵机模型包含不了。</li>
<li>人类的很多现象似乎都能被图灵机包括：情绪、情感等</li>
</ol>
<p>这个问题，其实图灵也已经考虑过了，其实就是我们现在一个大热门：AI，人工智能，计算机是否真的能实现人工智能。下一篇我们讲和大家聊聊这个话题。</p>
]]></content>
      <categories>
        <category>图灵</category>
        <category>玄学</category>
      </categories>
      <tags>
        <tag>图灵机</tag>
      </tags>
  </entry>
  <entry>
    <title>带你深入理解图灵机-天才所在的时代</title>
    <url>/2020/11/09/%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%BE%E7%81%B5%E6%9C%BA-%E5%A4%A9%E6%89%8D%E6%89%80%E5%9C%A8%E7%9A%84%E6%97%B6%E4%BB%A3/</url>
    <content><![CDATA[<p>这几年由于区块链的大热，以太坊独特的 solidity 语言实现智能合约功能，<strong>图灵完备</strong>这个词走进大家的视线。</p>
<p>没有计算机专业知识的同学其实很难理解这个词的意思，其实计算机专业的同学都没有深入理解图灵机，图灵完备，图灵测试等概念包含的内涵。为了方便理解区块链技术，理解智能合约，笔者准备分几篇文章来带大家从浅入深，一步一步带你深入理解图灵机，相信通过这几篇文章能就能够理解什么是图灵完备。</p>
<blockquote>
<p>大家知道任何伟大艺术的诞生背后都有迷人的时代背景，伟大的科学思想也是一样。从达芬奇到蒙拉丽莎的微笑；从牛顿到万有引力；从爱因斯坦到相对论；伟大的天才图灵和这些大师一样有同样让人着迷的时代和故事。</p>
</blockquote>
<h3 id="图灵的生平"><a href="#图灵的生平" class="headerlink" title="图灵的生平"></a>图灵的生平</h3><p>艾伦·麦席森·图灵（Alan Mathison Turing，1912 年 6 月 23 日－1954 年 6 月 7 日），英国数学家、逻辑学家，<strong>被称为计算机科学理论之父，人工智能之父。</strong></p>
<p>1931 年，图灵考入剑桥大学国王学院，由于成绩优异而获得数学奖学金。</p>
<p>1936 年 5 月，年仅 24 岁的图灵发表一篇题为《论数字计算在决断难题中的应用》的论文，论文中提出一种计算装置，后被称为<strong>“图灵机”</strong>，图灵机不是具体的计算机，而是一种计算概念、计算理论。</p>
<p>1938 年在普林斯顿获博士学位，其论文题目为“以序数为基础的逻辑系统”，在数理逻辑研究中产生了深远的影响；同年图灵回到英国，在剑桥大学国王学院任研究员。</p>
<p>第二次世界大战期间，1939 年图灵到英国外交部通信处从事军事工作，主要是破译敌方密码的工作。由于破译工作的需要，他参与了世界上最早的电子计算机的研制工作。他的工作取得了极好的成就，破译了德国人 Enigma 密码，于 1945 年获政府的最高奖——大英帝国荣誉勋章。</p>
<p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/10096448-17f4b1ad3b7968f3.png"></p>
<p>图灵破解密码</p>
<p>1945 年，图灵结束了在外交部的工作，他试图恢复战前在理论计算机科学方面的研究，具体研制出新的计算机来。</p>
<p>1950 年他发表论文《计算机器与智能》（ Computing Machinery and Intelligence），为后来的人工智能科学提供了开创性的构思。提出著名的<strong>图灵测试</strong>。</p>
<p>1950 年，1950 年 10 月，图灵发表论文《机器能思考吗》。这一划时代的作品，使图灵赢得了“人工智能之父”的桂冠。此时，人工智能也进入了实践研制阶段。随着这几年 AI 技术的不断成熟，人们越来越认识到图灵思想的深刻性：它们至今仍然是人工智能的主要思想之一。</p>
<p>1954 年 6 月 7 日，年仅 41 岁的图灵被发现死于家中的床上，床头还放着一个被咬了一口有毒的苹果。这就是现在大名鼎鼎的苹果电脑公司 logo 的来源。</p>
<h3 id="时代背景"><a href="#时代背景" class="headerlink" title="时代背景"></a>时代背景</h3><p>从图灵的生平中，我们知道，他出生在 20 世纪初，1912 年。 在世界国家格局上，这个时候刚刚爆发第一次世界大战（1913~1921），紧接着 1939 年至 1945 年第二次世界大战，大家知道，这两次世界大战倒逼了很多科技的发展，二战期间恰好是图灵青年时代。</p>
<p>在科技文明发展上，由于逻辑的数学化，促使了数理逻辑学科的诞生和发展。但同时这个时期数学上发生了第三次数学危机，具体介绍在下方。图灵在剑桥读大学期间，修读了“数学基础”课程，授课人是纽曼，纽曼整个课程包含对哥德尔不完备性定理的证明和尚未解决的判定性问题。</p>
<p>这些科技事件的背后，其实是人们在认知上，对<strong>可计算性理论</strong>的研究，图灵正是这个问题终结者。</p>
<p>随便提一下，爱因斯坦 1905 年提出狭义相对论，1927 年年仅 15 岁的图灵为了帮助母亲理解相对论，还写过论文的摘要。</p>
<h4 id="可计算性理论"><a href="#可计算性理论" class="headerlink" title="可计算性理论"></a>可计算性理论</h4><p>在 20 世纪以前，人们普遍认为，所有的问题类都是有算法的，人们的计算研究就是找出算法来。1900 年，当时著名的大数学家希尔伯特在世纪之交的数学家大会上给国际数学界提出了著名的 23 个数学问题。 其中第十问题是这样的：</p>
<blockquote>
<p>存在不存在一种有限的、机械的步骤能够判断“丢番图方程”是否存在解？</p>
</blockquote>
<p>“丢番图方程”指：有一个或者几个变量的整系数方程，它们的求解仅仅在整数范围内进行。 上面这个问题简单点解释是：随便给一个不确定的方程，是否通过有限的步骤运算，判断这个方程是否存在整数解。</p>
<p>这个问题在 1970 年，苏联一个数学家证明了其实很多数学问题，是没有答案，甚至没有答案的问题比有答案的问题还要多。</p>
<p>这里就提出来了有限的、机械的证明步骤的问题，其实就是算法。但在当时，人们还不知道“算法”是什么。实际上，当时数学领域中已经有很多问题都是跟“算法”密切相关的，因而，科学的 “算法” 定义呼之欲出。之后到了 30 年代的时候，终于有两个人分别提出了精确定义算法的方法，一个人是图灵，一个人是丘奇。而其中图灵提出来的图灵机模型直观形象。</p>
<p>图灵思考这个问题的方式和常人不一样，在写前面提到的论文《论可计算数及其在判定性问题上的应用》的时候，图灵在思考三个问题</p>
<blockquote>
<ol>
<li>世界上是否所有的数学问题都有明确的答案？</li>
<li>如果有明确的答案，是否可以通过有限步骤的计算得到答案？</li>
<li>对于那些有可能在有限步骤计算出来的学习问题，是否有一种假想的机械，让它不断运行，最后机器停下来的时候，那个数学答案就计算出来了？</li>
</ol>
</blockquote>
<p>图灵这样的天才考虑问题的认知是高屋建瓴的。 图灵首先考虑的是是否所有数学问题都用解，如果这个问题不解决，辛辛苦苦解题，最后发现无解，一切的努力都是浪费时间和精力。</p>
<p>对于存在答案的数学问题，只有部分是可以在有限步骤内完成，这样把计算机的边界确定下来了。</p>
<p>确定了边界之后，就要设计一种通用、有效、等价的机器，保证可以按照这个方法做事，最后得到答案。而图灵机就是图灵设计出来的这样的一个机器，严格来讲是一种数学模型、计算理论模型。</p>
<p>从图灵机提出到现在已经过去了 80 多年，今天所有的计算机，包括量子计算机都没有超出图灵机的理论范畴。</p>
<h4 id="第三次数学危机与停机问题"><a href="#第三次数学危机与停机问题" class="headerlink" title="第三次数学危机与停机问题"></a>第三次数学危机与停机问题</h4><p>第三次数学危机产生于十九世纪末和二十世纪初，当时正是数学空前兴旺发达的时期。首先是逻辑的数学化，促使了数理逻辑这门学科诞生。</p>
<p>早在 19 世纪末的时候，康托尔为集合论做了奠基性的研究。人们发现，运用集合这个概念可以概括所有的数学，也就是说集合是一切数学的基础。然而就当这座大厦即将完工的时候，一件可怕的事情发生了，罗素提出来的罗素悖论粉碎了数学家的梦想。</p>
<p>关于罗素悖论的一个通俗化版本是：</p>
<blockquote>
<p>“村子里有一个理发师，他给自己定了一条规矩：‘不给那些所有给自己理发的人理发’。 现在就要问，这个理发师该不该给自己理发？”。 如果你尝试回答这个问题就会发现奇怪的事情：这个问题本身似乎是不可能的！</p>
</blockquote>
<p>为什么要第三次数学危机呢？ 因为有个很重要的概念：<strong>停机问题</strong>，停机问题是逻辑数学中可计算性理论中很重要的问题，也是第三次数学危机的解决方案。 <strong>停机问题</strong>通俗地说，停机问题就是判断任意一个程序是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序 P，对于任意输入的程序 w，能够判断 w 会在有限时间内结束或者死循环。</p>
<p>有人猜测图灵机模型是图灵在思考<strong>停机问题</strong>而顺带设计出来的，是很有道理的。</p>
<h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>图灵在剑桥大学国王学院期间，研究过一本叫做《量子力学的数学基础》的新书，这本书由年轻的匈牙利数学家约翰·冯·诺依曼所著。图灵意识到计算可以用确定性的机械运动来进行表示。其实我们现在的电子计算机虽然不是我们传统意义上的机械，但是 CPU 内部的电子运动等价于机械运动。</p>
<p>同时图灵也意识到人的思想、意识来自于量子力学中的测不准原理，这不光是微观世界，同时也是这个宇宙本身的规律。所以图灵意识到计算是确定性的，可判定的，而意识是不定的，不可计算的。</p>
<p>在 AI 人工智能有巨大发展的今天，很多人担心计算机是否会和人一样有意识，其实图灵在 80 多年前已经考虑过这个问题了。</p>
<p>前面提到，图灵在 1950 年写过一篇论文《计算机器与智能》，在这篇论文中，图灵测试一词被提出来：</p>
<blockquote>
<p>指测试者与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。进行多次测试后，如果有超过 30%的测试者不能确定出被测试者是人还是机器，那么这台机器就通过了测试，并被认为具有人类智能</p>
</blockquote>
<p>这个测试有多难？目前我们所有的人工智能都没有完成这个测试。最近 2018 年 3 月份的谷歌 I/O 大会上演示的 AI 产品，据说“部分通过图灵测试”。这个部分到底有多少也未可知。</p>
<h3 id="总结与启示"><a href="#总结与启示" class="headerlink" title="总结与启示"></a>总结与启示</h3><p>从人类科技发展的历史上来看，19 世纪末到 20 世纪中期，是第二次工业革命和第三工业革命过渡的时期。第二次工业革命主要电和磁、内燃机的发明和使用，发展到这个时候科学家对世界的认知越来越多，越来越清晰，物理学和数学等自然科学发展迅速。这个时候的数学家发现很多现象可以用数学模型来表示，从物体的运动到星球的运动、从热能到动能的转换、从电到磁的转换等等。那问题来了是否所有的现象都可以用数学模型来表达呢？真是这个问题，让人们对数学很多根本性问题进行思考和研究。</p>
<p>中国有句古话说：乱世出英雄。在图灵的时代，在科学历史上出了很多的科学英雄，包括爱因斯坦、冯诺依曼、图灵、哥德尔等等，一方面是时代背景使然，一方面真是他们的天赋和努力让以信息化为代表的第三次工业革命的进程大大加快了。</p>
<p>从这些巨匠的思考问题，解决问题的方法和认知来看是超出常人的。从对<strong>可计算性理论</strong>的思考，给了我们很大的启示：</p>
<ol>
<li>要学会抽象，看问题高屋建瓴，学会从上帝视角看问题</li>
<li>知道做事情的边界是非常重要的，可以指导人们在正确的范围内做事情，可以减少很多无谓的付出。</li>
<li>做事情要有方法论，理解计算的等价性</li>
<li>要学好数学</li>
</ol>
]]></content>
      <categories>
        <category>图灵</category>
        <category>玄学</category>
      </categories>
      <tags>
        <tag>人物</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/11/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>假设我们有一个没有任何排列顺序的电话号码簿，当需要添加联络人和电话的时候，你只能将其写在下一个空位上，假定你的联系人列表有很多人，某天，你要找到每个人的联系方式，但是由于联系人列表没有按照任何顺序来组织，你只能逐个查找，知道找到那个你想的联系人为止，这个方法太吓人了，</p>
<p>还有许多诸如此类的问题，因此我们需要组织信息集，比如哪些存储在数据结构里的信息，排序和搜索算法广泛的运用在待解决的日常问题中，</p>
<p>冒泡排序</p>
<p>人们开始排序算法的时候，通常会先学习冒泡排序，因为它是所有排序算法中最简单最容易理解的，然而从运行时角度来看，冒泡排序是最差的一个，接下来你会知晓原因</p>
<p>冒泡排序比较所有相邻的两个项，如果第一个比第二个大，则交换它们，元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名</p>
<p>让我们实现下冒泡排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array,compareFn = </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总结</title>
    <url>/2020/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="数据结构总结"><a href="#数据结构总结" class="headerlink" title="数据结构总结"></a>数据结构总结</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>几乎所有的编程语言都原生支持数组，因为数组是最简单的内存数据结构，数组是一种线性结构，用于储存多个类型相同的元素，元素允许重复，数组内的每个元素都对应一个唯一的下标值(元素在数组中的位置值)，我们可以在数组的任意位置添加删除元素，查询的时候我们可以通过元素的下标值获取元素，通过下标访问内部元素的时候效率很高。但是在数组内部增加或删除元素的时候效率很低，因为这种操作会使数组内的其他元素发生位移(下标值的改变)，数组的的长度一般是在数组定义的时候就已经固定了，当数组内的元素到达数组的最大长度时，再次向数组插入元素的时候你可能需要新建一个更大长度的数组，将现有数组中的元素以及待添加的元素添加到新数组中，数组在创建的时候会申请一整块的内存中间，对内存的不够灵活，JavaScript 中的数组和其他编程语言中的数组还有些不同，JavaScript 中的数组中可以存储不同类型的元素，JavaScript 中的数组长度是动态变化的</p>
<blockquote>
<p>百科定义: 数组（Array）是有序的元素序列。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。 这些有序排列的同类数据元素的集合称为数组。</p>
</blockquote>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>虽然有了数组，然而在某些情况下我们更加需要一种能在添加或删除元素时进行更多的控制的数据结构，这时我们可能就需要用到栈了, 栈是一种遵从<strong>后进先出</strong>原则的有序集合，新添加或待删除的元素都保存在栈的同一端，另一端叫做栈底，新元素都靠近栈顶,旧元素都接近栈底，在现实生活中也能发现很多栈的例子餐厅里叠放的盘子，栈也被用在编程语言的遍历器和内存中保存变量，方法调用等，也被用于浏览器历史记录(浏览器的返回按钮)</p>
<blockquote>
<p>百科定义: 栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>
</blockquote>
<h4 id="队列和双端队列"><a href="#队列和双端队列" class="headerlink" title="队列和双端队列"></a>队列和双端队列</h4><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限的线性表，进行插入操作的端成为队尾，进行删除操作的成为队头。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><h4 id="字典和散列表"><a href="#字典和散列表" class="headerlink" title="字典和散列表"></a>字典和散列表</h4><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h4 id="二叉堆和堆排序"><a href="#二叉堆和堆排序" class="headerlink" title="二叉堆和堆排序"></a>二叉堆和堆排序</h4><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>有限状态机是什么</title>
    <url>/2020/11/17/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>有限状态机，（英语：Finite-state machine, FSM），又称有限状态自动机，简称状态机， 是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。</p>
<p>其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。在计算机科学中， 有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。</p>
<p>有限状态机（Finite-state machine）是一个非常有用的模型，可以模拟世界上大部分事物。它是一个数学模型。是一个抽象机器，在任何时候都可以处于有限数量的状态之一。响应某些外部输入， FSM 可以从一个状态转换到另一个状态; 从一种状态到另一种状态的变化称为过渡。 状态机的行为可以在现代社会中的许多设备中观察到，这些设备根据它们呈现的事件序列执行预定的一系列行为。 例如自动售货机，当存放适当的硬币组合时分配产品，当车辆等待时改变顺序的交通灯等。</p>
<p>在我们前端开发中，我们可以套用有限状态机模型，将业务流程状态化，划分状态和相应的触发事件与动作，利用生命周期事件进行控制与执行</p>
<h3 id="知识剖析"><a href="#知识剖析" class="headerlink" title="知识剖析"></a>知识剖析</h3><p>我们来看一下阮一峰大神对有限状态机的描述</p>
<p>它有三个特征：</p>
<ul>
<li>状态总数（state）是有限的。</li>
<li>任一时刻，只处在一种状态之中。</li>
<li>某种条件下，会从一种状态转变（transition）到另一种状态。</li>
</ul>
<p>有限状态机一般都有以下特点：</p>
<ul>
<li>可以用状态来描述事物，并且任一时刻，事物总是处于一种状态；</li>
<li>事物拥有的状态总数是有限的；</li>
<li>通过触发事物的某些行为，可以导致事物从一种状态过渡到另一种状态；</li>
<li>事物状态变化是有规则的，A 状态可以变换到 B，B 可以变换到 C，A 却不一定能变换到 C；</li>
<li>同一种行为，可以将事物从多种状态变成同种状态，但是不能从同种状态变成多种状态。</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h3 id="编码演示"><a href="#编码演示" class="headerlink" title="编码演示"></a>编码演示</h3>]]></content>
  </entry>
  <entry>
    <title>泛用语言分类方法</title>
    <url>/2020/11/17/%E6%B3%9B%E7%94%A8%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>从这节课开始我们进入到重学 JavaScript 的内容，在所有的重学系列的课程中，我们都是回假设大家已经对，JavaScript，Css，html 有了一定的了解，而我们重学的过程其实是在帮助我们在这些过去的知识里面建立一个新的秩序，也就是建立知识体系的过程，重学 JavaScript 部分，将会带着大家以 js 的语法为线索，从细到粗的跟大家完成学习一遍 JavaScript 的语言知识，第一节课我们回先讲一点编程语言的基本知识</p>
<h3 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a>语言分类</h3><ul>
<li><p>自然语言</p>
<p>  自然语言（Natural Language）就是人类讲的语言，比如汉语、英语和法语。这类语言不是人为设计（虽然有人试图强加一些规则）而是自然进化的。</p>
</li>
<li><p>形式语言</p>
<p>  形式语言（Formal Language）是为了特定应用而人为设计的语言。例如数学家用的数字和运算符号、化学家用的分子式等。编程语言也是一种形式语言，是专门设计用来表达计算过程的形式语言。形式语言有严格的语法（Syntax）规则，例如，3+3=6是一个语法正确的数学等式，而3=+6$则不是，H2O是一个正确的分子式，而2Zz则不是。语法规则是由关于符号（Token）和结构（Structure）的规则所组成的。Token的概念相当于自然语言中的单词和标点、数学式中的数和运算符、化学分子式中的元素名和数字。关于Token的规则称为词法（Lexical）规则，而关于语句结构的规则称为语法（Grammar）规则。</p>
</li>
</ul>
<h3 id="形式语言的表示方法"><a href="#形式语言的表示方法" class="headerlink" title="形式语言的表示方法"></a>形式语言的表示方法</h3><p>一个形式语言可以通过多种方法来限定自身，比如：</p>
<ul>
<li>枚举出各个字串（只适用于有限字串集合）。-</li>
<li>通过形式文法来产生（参见<strong>乔姆斯基谱系</strong>）。</li>
<li>通过正则表达式来产生。</li>
<li>通过某种自动机来识别，比如图灵机、有限状态自动机。</li>
</ul>
<h3 id="形式语言编程方面的应用"><a href="#形式语言编程方面的应用" class="headerlink" title="形式语言编程方面的应用"></a>形式语言编程方面的应用</h3><p>主要：语法（编程语言和编译器）<br>编译器通常有两个不同的部分组成。</p>
<p>一个词法分析器，由一个像lex的工具形成。识别编程语言的语法标记。例如：标识符或关键字，在一个简单的语言表达形式中，通常是正则表达式工具。在最基本的概念，</p>
<p>一个解析器由一个类似Yacc的解析生成器构成。试图判断源程序是否有效。当然，编译器做的不仅仅是解析源代码，他们通常把它翻译成一些可执行格式。因此，一个解析器通常输出多是或否的回答，一个典型的抽象语法树，这是由编译器后续阶段用于最终生成机器代码，包含直接运行在硬件执行，或一些中间代码需要虚拟机执行。</p>
<h3 id="乔姆斯基谱系"><a href="#乔姆斯基谱系" class="headerlink" title="乔姆斯基谱系"></a>乔姆斯基谱系</h3><p>乔姆斯基体系是由诺·乔姆斯基于1956年提出的，是刻画形式文法表达能力的一个分类谱系。</p>
<p>太深奥看不懂，以后再说，，，，</p>
]]></content>
  </entry>
  <entry>
    <title>浏览器DOM API</title>
    <url>/2020/09/26/%E6%B5%8F%E8%A7%88%E5%99%A8DOM%20API/</url>
    <content><![CDATA[<p>DOM API 是最早被设计出来的一批 API，也是用途最广的 API，所以早年的技术社区，常常用 DOM 来泛指浏览器中所有的 API。不过今天这里我们要介绍的 DOM，指的就是狭义的文档对象模型。</p>
<h3 id="DOM-API-介绍"><a href="#DOM-API-介绍" class="headerlink" title="DOM API 介绍"></a>DOM API 介绍</h3><p>首先我们先来讲一讲什么叫做文档对象模型，</p>
<p>顾名思义，文档对象模型是用来描述文档，这里的文档，是特指 HTML 文档（也用于 XML 文档，但是本课不讨论 XML）。同时它又是一个“对象模型”，这意味着它使用的是对象这样的概念来描述 HTML 文档。</p>
<p>说起 HTML 文档，这是大家最熟悉的东西了，我们都知道，HTML 文档是一个由标签嵌套而成的树形结构，因此，DOM 也是使用树形的对象模型来描述一个 HTML 文档。</p>
<p>DOM API 大致会包含四个部分。</p>
<ul>
<li>节点：DOM 树形结构中的节点相关 API</li>
<li>事件：触发和监听事件相关 API</li>
<li>Range：操作文字范围相关 API</li>
<li>遍历：遍历 DOM 需要的工具 API</li>
</ul>
<p>事件相关 API 和事件模型，我们会用单独的文章讲解，所以我们本篇文章重点会为你介绍节点和遍历相关 API。</p>
<p>DOM API 数量很多，我希望给你提供一个理解 DOM API 设计的思路，避免单靠机械的方式去死记硬背。</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>DOM 的树形结构所有的节点由统一的接口 Node，我们按照继承关系，介绍一下节点的类型</p>
<p><img data-src="https://static001.geekbang.org/resource/image/6e/f6/6e278e450d8cc7122da3616fd18b9cf6.png"></p>
<p>在这些节点中，除了 Document 和 DocumentFrangment，都有与之对应的 HTML 写法，我们可以看一下。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Element: &lt;tagname&gt;...&lt;/tagname&gt;</span><br><span class="line">Text: text</span><br><span class="line">Comment: &lt;!-- comments --&gt;</span><br><span class="line">DocumentType: &lt;!Doctype html&gt;</span><br><span class="line">ProcessingInstruction: &lt;?a 1?&gt;</span><br></pre></td></tr></table></figure>

<p>我们在编写 HTML 代码并且运行后，就会在内存中得到这样一棵 DOM 树，HTML 的写法会被转化成对应的文档模型，而我们则可以通过 JavaScript 等语言去访问这个文档模型。</p>
<p>这里我们每天都需要用到，要重点掌握的是：Document、Element、Text 节点。</p>
<p>DocumentFragment 也非常有用，它常常被用来高性能地批量添加节点。因为 Comment、DocumentType 和 ProcessingInstruction 很少需要运行时去修改和操作，所以有所了解即可。</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node 是 DOM 树继承关系的根节点，它定义了 DOM 节点在 DOM 树上的操作，首先，Node 提供了一组属性，来表示它在 DOM 树中的关系，它们是：</p>
<ul>
<li>parentNode</li>
<li>childNodes</li>
<li>firstChild</li>
<li>lastChild</li>
<li>nextSibling</li>
<li>previousSibling</li>
</ul>
<p>从命名上，我们可以很清晰地看出，这一组属性提供了前、后、父、子关系，有了这几个属性，我们可以很方便地根据相对位置获取元素。当然，Node 中也提供了操作 DOM 树的 API，主要有下面几种。</p>
<ul>
<li>appendChild</li>
<li>insertBefore</li>
<li>removeChild</li>
<li>replaceChild</li>
</ul>
<p>这个命名跟上面一样，我们基本可以知道 API 的作用。这几个 API 的设计可以说是饱受诟病。其中最主要的批评是它不对称——只有 before，没有 after，而 jQuery 等框架都对其做了补充。</p>
<p>实际上，appendChild 和 insertBefore 的这个设计，是一个“最小原则”的设计，这两个 API 是满足插入任意位置的必要 API，而 insertAfter，则可以由这两个 API 实现出来。</p>
<p>我个人其实不太喜欢这个设计，对我而言，insertAt(pos) 更符合审美一些。当然，不论喜不喜欢，这个标准已经确定，我们还是必须要掌握它。</p>
<p>这里从设计的角度还想要谈一点，那就是，所有这几个修改型的 API，全都是在父元素上操作的，比如我们要想实现“删除一个元素的上一个元素”，必须要先用 parentNode 获取其父元素。</p>
<p>这样的设计是符合面向对象的基本原则的。还记得我们在 JavaScript 对象部分讲的对象基本特征吗？“拥有哪些子元素”是父元素的一种状态，所以修改状态，应该是父元素的行为。这个设计我认为是 DOM API 中好的部分。</p>
<p>到此为止，Node 提供的 API 已经可以很方便（大概吧）地对树进行增、删、遍历等操作了。</p>
<p>除此之外，Node 还提供了一些高级 API，我们来认识一下它们。</p>
<ul>
<li>compareDocumentPosition 是一个用于比较两个节点中关系的函数。</li>
<li>contains 检查一个节点是否包含另一个节点的函数。</li>
<li>isEqualNode 检查两个节点是否完全相同。</li>
<li>isSameNode 检查两个节点是否是同一个节点，实际上在 JavaScript 中可以用“===”。</li>
<li>cloneNode 复制一个节点，如果传入参数 true，则会连同子元素做深拷贝。</li>
</ul>
<p>DOM 标准规定了节点必须从文档的 create 方法创建出来，不能够使用原生的 JavaScript 的 new 运算。于是 document 对象有这些方法。</p>
<ul>
<li>createElement</li>
<li>createTextNode</li>
<li>createCDATASection</li>
<li>createComment</li>
<li>createProcessingInstruction</li>
<li>createDocumentFragment</li>
<li>createDocumentType</li>
<li>上面的这些方法都是用于创建对应的节点类型。你可以自己尝试一下。</li>
</ul>
<h3 id="Element-与-Attribute"><a href="#Element-与-Attribute" class="headerlink" title="Element 与 Attribute"></a>Element 与 Attribute</h3><p>Node 提供了树形结构上节点相关的操作。而大部分时候，我们比较关注的是元素。Element 表示元素，它是 Node 的子类。</p>
<p>元素对应了 HTML 中的标签，它既有子节点，又有属性。所以 Element 子类中，有一系列操作属性的方法。</p>
<p>我们需要注意，对 DOM 而言，Attribute 和 Property 是完全不同的含义，只有特性场景下，两者才会互相关联（这里在后面我会详细讲解，今天的文章里我就不展开了）。</p>
<p>首先，我们可以把元素的 Attribute 当作字符串来看待，这样就有以下的 API：</p>
<ul>
<li>getAttribute</li>
<li>setAttribute</li>
<li>removeAttribute</li>
<li>hasAttribute</li>
</ul>
<p>如果你追求极致的性能，还可以把 Attribute 当作节点：</p>
<ul>
<li>getAttributeNode</li>
<li>setAttributeNode</li>
</ul>
<p>此外，如果你喜欢 property 一样的访问 attribute，还可以使用 attributes 对象，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.attributes.class = “a”</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(“<span class="class"><span class="keyword">class</span>”, “<span class="title">a</span>”)。</span></span><br></pre></td></tr></table></figure>

<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>document 节点提供了查找元素的能力。比如有下面的几种。</p>
<ul>
<li>querySelector</li>
<li>querySelectorAll</li>
<li>getElementById</li>
<li>getElementsByName</li>
<li>getElementsByTagName</li>
<li>getElementsByClassName</li>
</ul>
<p>我们需要注意，getElementById、getElementsByName、getElementsByTagName、getElementsByClassName，这几个 API 的性能高于 querySelector。</p>
<p>而 getElementsByName、getElementsByTagName、getElementsByClassName 获取的集合并非数组，而是一个能够动态更新的集合。</p>
<p>我们看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;winter&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(collection.length);</span><br><span class="line"><span class="keyword">var</span> winter = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">winter.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;winter&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.documentElement.appendChild(winter)<span class="built_in">console</span>.log(collection.length);</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们先获取了页面的 className 为 winter 的元素集合，不出意外的话，应该是空。</p>
<p>我们通过 console.log 可以看到集合的大小为 0。之后我们添加了一个 class 为 winter 的 div，这时候我们再看集合，可以发现，集合中出现了新添加的元素。</p>
<p>这说明浏览器内部是有高速的索引机制，来动态更新这样的集合的。所以，尽管 querySelector 系列的 API 非常强大，我们还是应该尽量使用 getElement 系列的 API。</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>前面已经提到过，通过 Node 的相关属性，我们可以用 JavaScript 遍历整个树。实际上，DOM API 中还提供了 NodeIterator 和 TreeWalker 来遍历树。</p>
<p>比起直接用属性来遍历，NodeIterator 和 TreeWalker 提供了过滤功能，还可以把属性节点也包含在遍历之内。</p>
<p>NodeIterator 的基本用法示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(<span class="built_in">document</span>.body, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> node;</span><br><span class="line"><span class="keyword">while</span> ((node = iterator.nextNode())) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 API 的设计非常老派，这么讲的原因主要有两点，一是循环并没有类似“hasNext”这样的方法，而是直接以 nextNode 返回 null 来标志结束，二是第二个参数是掩码，这两个设计都是传统 C 语言里比较常见的用法。</p>
<p>放到今天看，这个迭代器无法匹配 JavaScript 的迭代器语法，而且 JavaScript 位运算并不高效，掩码的设计就徒增复杂性了。</p>
<p>这里请你注意一下这个例子中的处理方法，通常掩码型参数，我们都是用按位或运算来叠加。而针对这种返回 null 表示结束的迭代器，我使用了在 while 循环条件中赋值，来保证循环次数和调用 next 次数严格一致（但这样写可能违反了某些编码规范）。</p>
<p>我们再来看一下 TreeWalker 的用法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> walker = <span class="built_in">document</span>.createTreeWalker(<span class="built_in">document</span>.body, NodeFilter.SHOW_ELEMENT, <span class="literal">null</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> node;</span><br><span class="line"><span class="keyword">while</span>(node = walker.nextNode())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.tagName === <span class="string">&quot;p&quot;</span>)</span><br><span class="line">        node.nextSibling();</span><br><span class="line">    <span class="built_in">console</span>.log(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比起 NodeIterator，TreeWalker 多了在 DOM 树上自由移动当前节点的能力，一般来说，这种 API 用于“跳过”某些节点，或者重复遍历某些节点。</p>
<p>总的来说，我个人不太喜欢 TreeWalker 和 NodeIterator 这两个 API，建议需要遍历 DOM 的时候，直接使用递归和 Node 的属性。</p>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>Range API 是一个比较专业的领域，如果不做富文本编辑类的业务，不需要太深入。这里我们就仅介绍概念和给出基本用法的示例，你只要掌握即可。</p>
<p>Range API 表示一个 HTML 上的范围，这个范围是以文字为最小单位的，所以 Range 不一定包含完整的节点，它可能是 Text 节点中的一段，也可以是头尾两个 Text 的一部分加上中间的元素。</p>
<p>我们通过 Range API 可以比节点 API 更精确地操作 DOM 树，凡是 节点 API 能做到的，Range API 都可以做到，而且可以做到更高性能，但是 Range API 使用起来比较麻烦，所以在实际项目中，并不常用，只有做底层框架和富文本编辑对它有强需求。</p>
<p>创建 Range 一般是通过设置它的起止来实现，我们可以看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> range = <span class="keyword">new</span> Range(),</span><br><span class="line">  firstText = p.childNodes[<span class="number">1</span>],</span><br><span class="line">  secondText = em.firstChild;</span><br><span class="line">range.setStart(firstText, <span class="number">9</span>); <span class="comment">// do not forget the leading space</span></span><br><span class="line">range.setEnd(secondText, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>此外，通过 Range 也可以从用户选中区域创建，这样的 Range 用于处理用户选中区域:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.getSelection().getRangeAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>更改 Range 选中区段内容的方式主要是取出和插入，分别由 extractContents 和 insertNode 来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = range.extractContents();</span><br><span class="line">range.insertNode(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;aaaa&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>最后我们看一个完整的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> range = <span class="keyword">new</span> Range(),</span><br><span class="line">  firstText = p.childNodes[<span class="number">1</span>],</span><br><span class="line">  secondText = em.firstChild;</span><br><span class="line">range.setStart(firstText, <span class="number">9</span>); <span class="comment">// do not forget the leading space</span></span><br><span class="line">range.setEnd(secondText, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fragment = range.extractContents();</span><br><span class="line">range.insertNode(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;aaaa&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这个例子展示了如何使用 range 来取出元素和在特定位置添加新元素。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在今天的文章中，我们一起了解了 DOM API 的内容。DOM API 大致会包含 4 个部分。</p>
<ul>
<li>节点：DOM 树形结构中的节点相关 API。</li>
<li>事件：触发和监听事件相关 API。</li>
<li>Range：操作文字范围相关 API。</li>
<li>遍历：遍历 DOM 需要的 API。</li>
</ul>
<p>DOM API 中还提供了 NodeIterator 和 TreeWalker 来遍历树。比起直接用属性来遍历，NodeIterator 和 TreeWalker 提供了过滤功能，还可以把属性节点也包含在遍历之内。</p>
<p>除此之外，我们还谈到了 Range 的一些基础知识点，这里你掌握即可。</p>
<h3 id="补充阅读：命名空间"><a href="#补充阅读：命名空间" class="headerlink" title="补充阅读：命名空间"></a>补充阅读：命名空间</h3><p>我们本课介绍的所有 API，特意忽略了命名空间。</p>
<p>在 HTML 场景中，需要考虑命名空间的场景不多。最主要的场景是 SVG。创建元素和属性相关的 API 都有带命名空间的版本：</p>
<ul>
<li>document<ul>
<li>createElementNS</li>
<li>createAttributeNS</li>
</ul>
</li>
<li>Element<ul>
<li>getAttributeNS</li>
<li>setAttributeNS</li>
<li>getAttributeNodeNS</li>
<li>setAttributeNodeNS</li>
<li>removeAttributeNS</li>
<li>hasAttributeNS</li>
<li>attributes.setNamedItemNS</li>
<li>attributes.getNamedItemNS</li>
<li>attributes.removeNamedItemNS</li>
</ul>
</li>
</ul>
<p>若要创建 Document 或者 Doctype，也必须要考虑命名空间问题。DOM 要求从 document.implementation 来创建。</p>
<ul>
<li>document.implementation.createDocument</li>
<li>document.implementation.createDocumentType</li>
</ul>
<p>除此之外，还提供了一个快捷方式，你也可以动手尝试一下。</p>
<ul>
<li>document.implementation.createHTMLDocument</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器工作流程-CSS解析</title>
    <url>/2020/11/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-CSS%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>在上一节课中，我已经讲了浏览器的 DOM 构建过程，但是这个构建的 DOM，实际上信息是不全的，它只有节点和属性，不包含任何的样式信息。</p>
<p>我们这一节课就来讲讲：浏览器是如何把 CSS 规则应用到节点上，并给这棵朴素的 DOM 树添加上 CSS 属性的。</p>
<h3 id="整体过程"><a href="#整体过程" class="headerlink" title="整体过程"></a>整体过程</h3><p>首先我们还是要感性地理解一下这个过程。</p>
<p>首先 CSS 选择器这个名称，可能会给你带来一定的误解，觉得好像 CSS 规则是 DOM 树构建好了以后，再进行选择并给它添加样式的。实际上，这个过程并不是这样的。</p>
<p>我们回忆一下我们在浏览器第一节课讲的内容，浏览器会尽量流式处理整个过程。我们上一节课构建 DOM 的过程是：从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上的，那么这个过程中，我们是否能同步把 CSS 属性计算出来呢？</p>
<p>答案是肯定的。</p>
<p>在这个过程中，我们依次拿到上一步构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。所以，从这个角度看，所谓的选择器，应该被理解成“匹配器”才更合适。</p>
<p>我在 CSS 语法部分，已经总结了选择器的各种符号，这里再把它列出来，我们回顾一下。</p>
<ul>
<li><code>空格</code>: 后代，选中它的子节点和所有子节点的后代节点。</li>
<li><code>&gt;</code>: 子代，选中它的子节点。</li>
<li><code>+</code>：直接后继选择器，选中它的下一个相邻节点。</li>
<li><code>~</code>：后继，选中它之后所有的相邻节点。</li>
<li><code>||</code>：列，选中表格中的一列。</li>
</ul>
<p>关于选择器的知识，我会在 CSS 的部分继续讲解。这里我们主要介绍浏览器是如何实现这些规则的。</p>
<p>不知道你有没有发现，这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。这是一个 CSS 设计的原则，即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。</p>
<p>也就是说，未来也不可能会出现“父元素选择器”这种东西，因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，而父节点会先于子节点构建。</p>
<p>理解了 CSS 构建的大概过程，我们下面来看看具体的操作。</p>
<p>首先，我们必须把 CSS 规则做一下处理。作为一门语言，CSS 需要先经过词法分析和语法分析，变成计算机能够理解的结构。</p>
<p>这部分具体的做法属于编译原理的内容，这里就不做赘述了。我们这里假设 CSS 已经被解析成了一棵可用的抽象语法树。</p>
<p>我们在之前的 CSS 课程中已经介绍过 compound-selector 的概念，一个 compound-selector 是检查一个元素的规则，而一个复合型选择器，则是由数个 compound-selector 通过前面讲的符号连接起来的。</p>
<h3 id="后代选择器-“空格”"><a href="#后代选择器-“空格”" class="headerlink" title="后代选择器 “空格”"></a>后代选择器 “空格”</h3><p>我们先来分析一下后代选择器，我们来一起看一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-id">#b</span> <span class="selector-class">.cls</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把一个 CSS 选择器按照 compound-selector 来拆成数段，每当满足一段条件的时候，就前进一段。</p>
<p>比如，在上面的例子中，当我们找到了匹配 a#b 的元素时，我们才会开始检查它所有的子代是否匹配 .cls。</p>
<p>除了前进一段的情况，我们还需要处理后退的情况，比如，我们这样一段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">cls</span>&gt;</span>2<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">cls</span>&gt;</span>3<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当遇到 时，必须使得规则 a#b .cls 回退一步，这样第三个 span 才不会被选中。后代选择器的作用范围是父节点的所有子节点，因此规则是在匹配到本标签的结束标签时回退。</p>
<h3 id="后继选择器“-”"><a href="#后继选择器“-”" class="headerlink" title="后继选择器“ ~ ”"></a>后继选择器“ ~ ”</h3><p>接下来我们看下后继选择器，跟后代选择器不同的地方是，后继选择器只作用于一层，我们来看一个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.cls</span>~* &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span><span class="selector-pseudo">:solid</span> 1<span class="selector-tag">px</span> <span class="selector-tag">green</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">cls</span>&gt;</span>2<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">        3</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里 .cls 选中了 span 2 然后 span 3 是它的后继，但是 span 3 的子节点 span 4 并不应该被选中，而 span 5 也是它的后继，因此应该被选中。</p>
<p>按照 DOM 树的构造顺序，4 在 3 和 5 中间，我们就没有办法像前面讲的后代选择器一样通过激活或者关闭规则来实现匹配。</p>
<p>但是这里有个非常方便的思路，就是给选择器的激活，带上一个条件：父元素。</p>
<p>注意，这里后继选择器，当前半段的 .cls 匹配成功时，后续 * 所匹配的所有元素的父元素都已经确定了（后继节点和当前节点父元素相同是充分必要条件）。在我们的例子中，那个 div 就是后继节点的父元素。</p>
<h3 id="子代选择器“-gt-”"><a href="#子代选择器“-gt-”" class="headerlink" title="子代选择器“ &gt;”"></a>子代选择器“ &gt;”</h3><p>我们继续看，子代选择器是如何实现的。</p>
<p>实际上，有了前面讲的父元素这个约束思路，我们很容易实现子代选择器。区别仅仅是拿当前节点作为父元素，还是拿当前节点的父元素作为父元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">div</span>&gt;<span class="selector-class">.cls</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span><span class="selector-pseudo">:solid</span> 1<span class="selector-tag">px</span> <span class="selector-tag">green</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">cls</span>&gt;</span>2<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">        3</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们看这段代码，当 DOM 树构造到 div 时，匹配了 CSS 规则的第一段，因为是子代选择器，我们激活后面的 .cls 选择条件，并且指定父元素必须是当前 div。于是后续的构建 DOM 树构建过程中，span 2 就被选中了。</p>
<h3 id="直接后继选择器“-”"><a href="#直接后继选择器“-”" class="headerlink" title="直接后继选择器“ +”"></a>直接后继选择器“ +”</h3><p>直接后继选择器的实现是上述中最为简单的了，因为它只对唯一一个元素生效，所以不需要像前面几种一样反复激活和关闭规则。</p>
<p>一个最简单的思路是，我们可以把它当作检查元素自身的选择器来处理。即我们把 #id+.cls 都当做检查某一个元素的选择器。</p>
<p>另外的一种思路是：给后继选择器加上一个 flag，使它匹配一次后失效。你可以尝试一下，告诉我结果。</p>
<h3 id="列选择器“-”"><a href="#列选择器“-”" class="headerlink" title="列选择器“ || ”"></a>列选择器“ || ”</h3><p>列选择器比较特别，它是专门针对表格的选择器，跟表格的模型建立相关，我们这里不详细讲了。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>我们不要忘记，CSS 选择器还支持逗号分隔，表示“或”的关系。这里最简单的实现是把逗号视为两条规则的一种简易写法。</p>
<p>比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-id">#b</span>,</span><br><span class="line"><span class="selector-class">.cls</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们当作两条规则来处理：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-id">#b</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个情况，就是选择器可能有重合，这样，我们可以使用树形结构来进行一些合并，来提高效率：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#a</span> <span class="selector-class">.cls</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#a</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#a</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实际上可以把选择器构造成一棵树：</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这一节我们讲解了 CSS 计算的过程。CSS 计算是把 CSS 规则应用到 DOM 树上，为 DOM 结构添加显示相关属性的过程。在这一节中，我们主要介绍了选择器的几种复合结构应该如何实现。</p>
<p>在这一步骤之后，我们得到了一棵带有 CSS 属性的树，为我们后续打下了基础。</p>
<p>最后留一个问题，你认为 CSS 语法解析成什么结构，最适合我们进行 CSS 计算。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器工作流程</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器工作流程-排版</title>
    <url>/2020/11/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E6%8E%92%E7%89%88/</url>
    <content><![CDATA[<p>我们书接上文。浏览器进行到这一步，我们已经给 DOM 元素添加了用于展现的 CSS 属性，接下来，浏览器的工作就是确定每一个元素的位置了。我们的基本原则仍然不变，就是尽可能流式地处理上一步骤的输出。</p>
<p>在构建 DOM 树和计算 CSS 属性这两个步骤，我们的产出都是一个一个的元素，但是在排版这个步骤中，有些情况下，我们就没法做到这样了。</p>
<p>尤其是表格相关排版、Flex 排版和 Grid 排版，它们有一个显著的特点，那就是子元素之间具有关联性。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先我们先来介绍一些基本概念，使你可以感性地认识一下我们平常说的各种术语。</p>
<p><strong>“排版”</strong>这个概念最初来自活字印刷，是指我们把一个一个的铅字根据文章顺序，放入板框当中的步骤，排版的意思是确定每一个字的位置。</p>
<p>在现代浏览器中，仍然借用了这个概念，但是排版的内容更加复杂，包括文字、图片、图形、表格等等，我们把浏览器确定它们位置的过程，叫作排版。</p>
<p>浏览器最基本的排版方案是正常流排版，它包含了顺次排布和折行等规则，这是一个跟我们提到的印刷排版类似的排版方案，也跟我们平时书写文字的方式一致，所以我们把它叫做正常流。</p>
<p>浏览器的文字排版遵循公认的文字排版规范，文字排版是一个复杂的系统，它规定了行模型和文字在行模型中的排布。行模型规定了行顶、行底、文字区域、基线等对齐方式。（你还记得小时候写英语的英语本吗？英语本上的四条线就是一个简单的行模型。）</p>
<p>此外，浏览器支持不同语言，因为不同语言的书写顺序不一致，所以浏览器的文本排版还支持双向文字系统。</p>
<p>浏览器又可以支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框、边距和留白，这个就是所谓的盒模型。</p>
<p>在正常流的基础上，浏览器还支持两类元素：绝对定位元素和浮动元素。</p>
<ul>
<li>绝对定位元素把自身从正常流抽出，直接由 top 和 left 等属性确定自身的位置，不参加排版计算，也不影响其它元素。绝对定位元素由 position 属性控制。</li>
<li>浮动元素则是使得自己在正常流的位置向左或者向右移动到边界，并且占据一块排版空间。浮动元素由 float 属性控制。</li>
</ul>
<p>除了正常流，浏览器还支持其它排版方式，比如现在非常常用的 Flex 排版，这些排版方式由外部元素的 display 属性来控制（注意，display 同时还控制元素在正常流中属于 inline 等级还是 block 等级）。</p>
<h3 id="正常流文字排版"><a href="#正常流文字排版" class="headerlink" title="正常流文字排版"></a>正常流文字排版</h3><p>我们会在 CSS 部分详细介绍正常流排版的行为，我们这里主要介绍浏览器中的正常流。正常流是唯一一个文字和盒混排的排版方式，我们先从文字来讲起。</p>
<p>要想理解正常流，我们首先要回忆一下自己如何在纸上写文章。</p>
<p>首先，纸是有固定宽度的，虽然纸有固定高度，但是我们可以通过下一页纸的方式来接续，因此我们不存在写不下的场景。</p>
<p>我们书写文字的时候，是从左到右依次书写，每一个字跟上一个字都不重叠，文字之间有一定间距，当写满一行时，我们换到下一行去继续写。</p>
<p>书写中文时，文字的上、下、中轴线都对齐，书写英文时，不同字母的高度不同，但是有一条基线对齐。</p>
<p>实际上浏览器环境也很类似。但是因为浏览器支持改变排版方向，不一定是从左到右从上到下，所以我们把文字依次书写的延伸方向称为主轴或者主方向，换行延伸的方向，跟主轴垂直交叉，称为交叉轴或者交叉方向。</p>
<p>我们一般会从某个字体文件中获取某个特定文字的相关信息。我们获取到的信息大概类似下面：</p>
<p><img data-src="https://static001.geekbang.org/resource/image/06/01/0619d38f00d539f7b6773e541ce6fa01.png"></p>
<p>纵向版本:</p>
<p><img data-src="https://static001.geekbang.org/resource/image/c3/96/c361c7ff3a11216c139ed462b9d5f196.png"></p>
<p>这两张图片来自著名开源字体解析库 freetype，实际上，各个库对字体的理解大同小异，我们注意一下，advance 代表每一个文字排布后在主轴上的前进距离，它跟文字的宽 / 高不相等，是字体中最重要的属性。</p>
<p>除了字体提供的字形本身包含的信息，文字排版还受到一些 CSS 属性影响，如 line-height、letter-spacing、word-spacing 等。</p>
<p>在正常流的文字排版中，多数元素被当作长方形盒来排版，而只有 display 为 inline 的元素，是被拆成文本来排版的（还有一种 run-in 元素，它有时作为盒，有时作为文字，不太常用，这里不详细讲了）。</p>
<p>display 值为 inline 的元素中的文字排版时会被直接排入文字流中，inline 元素主轴方向的 margin 属性和 border 属性（例如主轴为横向时的 margin-left 和 margin-right）也会被计算进排版前进距离当中。</p>
<p>注意，当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。</p>
<p>这样，即使没有元素包裹，混合书写方向的文字也可以形成一个盒结构，我们在排版时，遇到这样的双向文字盒，会先排完盒内再排盒外。</p>
<h3 id="正常流中的盒"><a href="#正常流中的盒" class="headerlink" title="正常流中的盒"></a>正常流中的盒</h3><p>在正常流中，display 不为 inline 的元素或者伪元素，会以盒的形式跟文字一起排版。多数 display 属性都可以分成两部分：内部的排版和是否 inline，带有 inline- 前缀的盒，被称作行内级盒。</p>
<p>根据盒模型，一个盒具有 margin、border、padding、width/height 等属性，它在主轴方向占据的空间是由对应方向的这几个属性之和决定的，而 vertical-align 属性决定了盒在交叉轴方向的位置，同时也会影响实际行高。</p>
<p>所以，浏览器对行的排版，一般是先行内布局，再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。块级盒比较简单，它总是单独占据一整行，计算出交叉轴方向的高度即可。</p>
<h3 id="绝对定位元素"><a href="#绝对定位元素" class="headerlink" title="绝对定位元素"></a>绝对定位元素</h3><p>position 属性为 absolute 的元素，我们需要根据它的包含块来确定位置，这是完全跟正常流无关的一种独立排版模式，逐层找到其父级的 position 非 static 元素即可。</p>
<h3 id="浮动元素排版"><a href="#浮动元素排版" class="headerlink" title="浮动元素排版"></a>浮动元素排版</h3><p>float 元素非常特别，浏览器对 float 的处理是先排入正常流，再移动到排版宽度的最左 / 最右（这里实际上是主轴的最前和最后）。移动之后，float 元素占据了一块排版的空间，因此，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。float 元素排布完成后，float 元素所在的行需要重新确定位置。</p>
<h3 id="其它的排版"><a href="#其它的排版" class="headerlink" title="其它的排版"></a>其它的排版</h3><p>CSS 的每一种排版都有一个很复杂的规定，实际实现形式也各不相同。比如如 Flex 排版，支持了 flex 属性，flex 属性将每一行排版后的剩余空间平均分配给主轴方向的 width/height 属性。浏览器支持的每一种排版方式，都是按照对应的标准来实现的。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这一部分，我们以正常流为主，介绍了浏览器的排版基本概念及一些算法。这里，我主要介绍了正常流中的文字排版、正常流中的盒、绝对定位元素、浮动元素排版这几种情况。最后，我还简单介绍了一下 Flex 排版。这属于进阶版的排版方式了，你可以了解一下。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器工作流程</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器工作流程-构建DOM树</title>
    <url>/2020/09/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E6%9E%84%E5%BB%BADOM%E6%A0%91/</url>
    <content><![CDATA[<p>在上一篇文章中，简要介绍了浏览器的工作大致可以分为六个阶段，同时也讲完了通讯部分，浏览器使用 HTTP 协议或者 HTTPS 协议，向服务器请求页面的过程</p>
<p>今天我们主要来看两个过程，如何解析请求回来的 HTML 代码，DOM 树又是如何被构建的</p>
<p><img data-src="https://static001.geekbang.org/resource/image/34/5a/34231687752c11173b7776ba5f4a0e5a.png"></p>
<h3 id="解析代码"><a href="#解析代码" class="headerlink" title="解析代码"></a>解析代码</h3><p>我们在前面讲到了 HTTP 的构成，但是我们有一个部分没有详细讲解 ，那就是 Response 的 Body 部分，这正是因为 HTTP Response 的 body ，就要交给我们今天学习的内容区处理，</p>
<p>HTML 的结构不算太复杂，我们日常开发需要的 90% 的词（指编译原理的术语 token，标识最小的有意义的单元）。种类大约只有标签开始，属性，标签结束，注释，CDATA 节点这几种</p>
<p>实际上有点麻烦的是，由于 HTML 跟 SGML 的千丝万缕的联系，我们需要做不少容错处理。</p>
<h4 id="1-词（token）是如何被拆分的"><a href="#1-词（token）是如何被拆分的" class="headerlink" title="1-词（token）是如何被拆分的"></a>1-词（token）是如何被拆分的</h4><p>首先我们来看看一个非常标准的标签会被如何拆分成词</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>text text text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我们从最小有意义单元来定义拆分系统，第一个词（token）是什么呢？显然，作为一个词（token），整个 p 标签确实是过大了（它甚至可以嵌套）</p>
<p>那么，只有 p 标签的开头是不是合适？，我们考虑到起始标签也会包含属性的，最小有意义单元其实应该是 “&lt;p”，所以 “&lt;p” 就是我们的第一个词（token）</p>
<p>我们继续拆分，可以把这段代码一次拆成词（token）</p>
<ul>
<li>&lt;p：开始标签的开始；</li>
<li>class=“a”：属性；</li>
<li>&gt;：开始标签的结束；</li>
<li>text text text：文本；</li>
<li></p> ：标签结束。

</li>
</ul>
<p>这是一段最简单的例子，类似的还有什么呢，现在我们可以来看看这些词（token）长成啥样子：</p>
<p><img data-src="https://static001.geekbang.org/resource/image/f9/84/f98444aa3ea7471d2414dd7d0f5e3a84.png"></p>
<p>根据这样的分析，现在我们讲讲浏览器是如何用代码实现，我们设想，代码开始从 HTTP 协议收到的字符流读取字符。</p>
<p>在接受第一个字符之前，我们完全无法判断这是哪一个词（token），不过，随着我们接受的字符越来越多，拼出其他的内容可能性就越来越少。</p>
<p>比如假设我们接受了一个字符“ &lt; ” 我们一下子就知道这不是一个文本节点啦。</p>
<p>之后我们再读一个字符，比如就是 x，那么我们一下子就知道这不是注释或 CDATA 了，接下来我们就一直读，直到遇到“&gt;”或者空格，这样就得到了一个完整的词（token）了。</p>
<p>实际上，我们每读入一个字符，其实都要做一次决策，而且这些决定是跟“当前状态”有关的。在这样的条件下，浏览器工程师要想实现把字符流解析成词（token），最常见的方案就是使用状态机。</p>
<h4 id="2-状态机"><a href="#2-状态机" class="headerlink" title="2-状态机"></a>2-状态机</h4><p>绝大多数语言的语法部分都是用状态机实现的，那么我们把部分词（token）的解析画成一个状态机看看</p>
<p><img data-src="https://static001.geekbang.org/resource/image/8b/b0/8b43d598bc1f83a8a1e7e8f922013ab0.png"></p>
<p>当然了，我们这里的分析比较粗略，真正完整的 HTML 语法状态机，比我们描述的要复杂的多，有关更详细的内容，你可以参考 HTML 官方文档，HTML 官方文档规定了 80 个状态</p>
<p>这里我们为了了解原理， 用这个简单的状态机足够说明问题了</p>
<p>状态机的初始状态，我们仅仅区分“&lt;”和非“&lt;”；</p>
<ul>
<li>如果获得的是一个 非 &lt; 字符，那么可以认为进入了一个文本节点</li>
<li>如果获得的是一个 &lt; 字符，那么进入一个标签状态</li>
</ul>
<p>不过当我们在标签状态时，则会面临一些可能性</p>
<ul>
<li>比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。</li>
<li>如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。</li>
<li>如果下一个字符是字母，那么可以确定进入了一个开始标签。</li>
<li>如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。</li>
</ul>
<p>我们可以看到，用状态机做词法分析，其实正是把每个词的“特殊字符”逐个拆开成独立状态，然后再把所有的词的特征字符链合起来，形成一个联通图结构</p>
<p>由于状态机设计属于编译原理的基本知识，这里我们仅作一个简要的介绍</p>
<p>接下来就是代码实现的事情了，在 C/C++和 JavaScript 中，实现状态机的方式大同小异，我们把每个函数当作一个状态，参数是接受的字符，返回值是一个状态函数，（这里我希望再次强调下，状态机真的是一种没有办法封装的东西，所以我们永远不要试图封装一个状态机）</p>
<p>为了方便理解和实验，我们这里用 JavaScript 来讲解，图上的 data 状态大概就像下面这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&quot;&amp;&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> characterReferenceInData;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&quot;&lt;&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> tagOpen;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&quot;\0&quot;</span>) &#123;</span><br><span class="line">    error();</span><br><span class="line">    emitToken(c);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == EOF) &#123;</span><br><span class="line">    emitToken(EOF);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    emitToken(c);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> tagOpenState = <span class="function"><span class="keyword">function</span> <span class="title">tagOpenState</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> endTagOpenState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c.match(<span class="regexp">/[A-Z]/</span>)) &#123;</span><br><span class="line">    token = <span class="keyword">new</span> StartTagToken();</span><br><span class="line">    token.name = c.toLowerCase();</span><br><span class="line">    <span class="keyword">return</span> tagNameState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c.match(<span class="regexp">/[a-z]/</span>)) &#123;</span><br><span class="line">    token = <span class="keyword">new</span> StartTagToken();</span><br><span class="line">    token.name = c;</span><br><span class="line">    <span class="keyword">return</span> tagNameState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&quot;?&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bogusCommentState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    error();</span><br><span class="line">    <span class="keyword">return</span> dataState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//……</span></span><br></pre></td></tr></table></figure>

<p>这段代码给出了状态机的两个状态示例，data 即为初始状态，tagOpenStart 是接受了个“&lt;”字符，来判断标签类型的状态</p>
<p>这里的状态机，每一个状态是一个函数，通过 “if else”来区分下一个字符做状态迁移，这里的所谓的状态迁移，就是当前状态函数返回下一个状态函数</p>
<p>这样，我们的状态迁移代码非常的简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> state = data;</span><br><span class="line"><span class="keyword">var</span> char;</span><br><span class="line"><span class="keyword">while</span> ((char = getInput())) state = state(char);</span><br></pre></td></tr></table></figure>

<p>这段代码的关键一句是“start = start(char)”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流</p>
<p>状态函数通过代码中 emitToken 函数来输出解析好的 token（词），我们只需要覆盖 emitToken，即可对指定对解析结果的处理方式</p>
<p>词法分析器接收字符的方式很简单，就像下面这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HTMLLexicalParser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//状态函数们……</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">data</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tagOpen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">  <span class="keyword">var</span> state = data;</span><br><span class="line">  <span class="built_in">this</span>.receiveInput = <span class="function"><span class="keyword">function</span> (<span class="params">char</span>) </span>&#123;</span><br><span class="line">    state = state(char);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就把字符流拆成了词（token）了。</p>
<h3 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h3><p>接下来我们要把这些简单的词编程 DOM 树，这个过程我们是使用栈来实现的，任何语言几乎都有栈，下面我们还是用 JavaScript 来实现，JavaScript 中的栈只要用数组就好了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HTMLSyntaticalParser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> stack = [<span class="keyword">new</span> HTMLDocument()];</span><br><span class="line">  <span class="built_in">this</span>.receiveInput = <span class="function"><span class="keyword">function</span> (<span class="params">token</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.getOutput = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这样来设计 HTML 的语法分析器，receiveInput 负责接收此法部分产生的词（token），通常由 emitToken 来调用</p>
<p>在接收的同时，即开始构建 Dom 树，所以我们主要构建 DOM 树的算法就写在 receiveInput 当中，当接收完所有的输入，栈顶就是最后的的根节点，我们 DOM 树的产出就是这个 stack 的第一项</p>
<p>为了构建 DOM 树，我们需要一个 Node 类，接下来我们所有的节点都会在这个 Node 类的实例</p>
<p>在完全符合标准的浏览器中，不一样的 HTML 节点对应了不同的 Node 子类，我们为了简化，就不完整实现这个继承体系了，我们仅仅把 Node 分为 Element 和 Text（如果是基于类的 OOP 的话，我们还需要抽象工厂来创建对象）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.childNodes = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Text</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.value = value || <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们的词（token）中，以下两个是需要成对匹配的：</p>
<ul>
<li>tag start</li>
<li>tag end</li>
</ul>
<p>根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案</p>
<p>对于 Text 节点，我们则需要把相邻的 Text 节点组合起来，我们的做法是当词（token）入栈时，检查栈顶是否是 Text 节点，如果是的话就合并 Text 节点</p>
<p>同样我们来看看直观的解析过程</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">maaa</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>cool<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;a&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过这个栈，我们可以构建 DOM 树</p>
<ul>
<li><p>栈顶元素就是当前节点；</p>
</li>
<li><p>遇到属性，就添加到当前节点；</p>
</li>
<li><p>遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；</p>
</li>
<li><p>遇到注释节点，作为当前节点的子节点；</p>
</li>
<li><p>遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；</p>
</li>
<li><p>遇到 tag end 就出栈一个节点（还可以检查是否匹配）。</p>
</li>
</ul>
<p>这里由一个视频可以让你直观的感受到这个过程</p>
<p>当我们的源代码完全遵循 XHTML（这是一种比较严谨的 HTML 语法）时，这是非常简单的问题，然后 HTML 具有很强的容错能力，奥妙在于当 tag end 跟栈顶的 start tag 不匹配的时候如何处理</p>
<p>于是，这又有一个极其复杂的规则，幸好 W3C 又一次很贴心地把全部规则都整理地很好，我们只要翻译成对应的代码就好了，以下这个网站呈现了全部规则。你可以点击查看。</p>
<ul>
<li><a href="http://www.w3.org/html/wg/drafts/html/master/syntax.html#tree-construction">http://www.w3.org/html/wg/drafts/html/master/syntax.html#tree-construction</a></li>
</ul>
<blockquote>
<p>PS：<a href="https://github.com/aimergenge/toy-html-parser">https://github.com/aimergenge/toy-html-parser</a></p>
</blockquote>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>好了，总结一下。在今天的文章中，我带你继续探索了浏览器的工作原理，我们主要研究了解析代码和构建 DOM 树两个步骤。在解析代码的环节里，我们一起详细地分析了一个词（token）被拆分的过程，并且给出了实现它所需要的一个简单的状态机。</p>
<p>在构建 DOM 树的环节中，基本思路是使用栈来构建 DOM 树为了方便你动手实践，我用 JavaScript 实现了这一过程。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器工作流程</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器工作流程-渲染</title>
    <url>/2020/11/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>在之前的几篇文章中，我们已经经历了把 URL 变成字符流，把字符流变成词（token）流，把词（token）流构造成 DOM 树，把不含样式信息的 DOM 树应用 CSS 规则，变成包含样式信息的 DOM 树，并且根据样式信息，计算了每个元素的位置和大小。</p>
<p>那么，我们最后的步骤，就是根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。</p>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>首先我们来谈谈渲染这个词，渲染也是个外来词，它是英文词 render 的翻译，render 这个词在英文里面，有“导致”“变成”的意思，也有“粉刷墙壁”的意思。</p>
<p>在计算机图形学领域里，英文 render 这个词是一个简写，它是特指把模型变成位图的过程。我们把 render 翻译成“渲染”，是个非常有意思的翻译，中文里“渲染”这个词是一种绘画技法，是指沾清水把墨涂开的意思。</p>
<p>所以，render 翻译成“渲染”，我认为是非常高明的，对 render 这个过程，用国画的渲染手法来概括，是颇有神似的。</p>
<p>我们现在的一些框架，也会把“从数据变成 HTML 代码的过程”称为 render，其实我觉得这是非常具有误导性的，我个人是非常不喜欢这种命名方式，当然了，所谓“文无第一”，在自然语言的范围里，我们很难彻底否定这种用法的合理性。</p>
<p>不过，在本篇文章中，我们可以约定一下，本文中出现的“渲染”一词，统一指的是它在图形学的意义，也就是把模型变成位图的过程。</p>
<p>这里的位图就是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去（位图信息也是 DOM 树中占据浏览器内存最多的信息，我们在做内存占用优化时，主要就是考虑这一部分）。</p>
<p>浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 HTML 元素和伪元素，一个元素可能对应多个盒（比如 inline 元素，可能会分成多行）。每一个盒对应着一张位图。</p>
<p>这个渲染过程是非常复杂的，但是总体来说，可以分成两个大类：图形和文字。</p>
<p>盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类。这就像我们实现 HTTP 协议必须要基于 TCP 库一样，这一部分，我们</p>
<p>一般的操作系统会提供一个底层库，比如在 Android 中，有大名鼎鼎的 Skia，而 Windows 平台则有 GDI，一般的浏览器会做一个兼容层来处理掉平台差异。</p>
<p>这些盒的特性如何绘制，每一个都有对应的标准规定，而每一个的实现都可以作为一个独立的课题来研究，当年圆角 + 虚线边框，可是难倒了各个浏览器的工程师。考虑到这些知识互相都比较独立，对前端工程师来说也不是特别重要的细节，我们这里就不</p>
<p>盒中的文字，也需要用底层库来支持，叫做字体库。字体库提供读取字体文件的基本能力，它能根据字符的码点抽取出字形。</p>
<p>字形分为像素字形和矢量字形两种。通常的字体，会在 6px 8px 等小尺寸提供像素字形，比较大的尺寸则提供矢量字形。矢量字形本身就需要经过渲染才能继续渲染到元素的位图上去。目前最常用的字体库是 Freetype，这是一个 C++ 编写的开源的字体库。</p>
<p>在最普遍的情况下，渲染过程生成的位图尺寸跟它在上一步排版时占据的尺寸相同。</p>
<p>但是理想和现实是有差距的，很多属性会影响渲染位图的大小，比如阴影，它可能非常巨大，或者渲染到非常遥远的位置，所以为了优化，浏览器实际的实现中会把阴影作为一个独立的盒来处理。</p>
<p>注意，我们这里讲的渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结果能够最大程度被缓存，减少重新渲染。</p>
<h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p>合成是英文术语 compositing 的翻译，这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。</p>
<p>我们上一小节中讲到，渲染过程不会把子元素渲染到位图上面，合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面。</p>
<p>看到这句话，我想你一定会问问题，到底是为哪些元素创建合成后的位图，把哪些子元素渲染到合成的位图上面呢？</p>
<p>这就是我们要讲的合成的策略。我们前面讲了，合成是一个性能考量，那么合成的目标就是提高性能，根据这个目标，我们建立的原则就是最大限度减少绘制次数原则。</p>
<p>我们举一个极端的例子。如果我们把所有元素都进行合成，比如我们为根元素 HTML 创建一个合成后的位图，把所有子元素都进行合成，那么会发生什么呢？</p>
<p>那就是，一旦我们用 JavaScript 或者别的什么方式，改变了任何一个 CSS 属性，这份合成后的位图就失效了，我们需要重新绘制所有的元素。那么如果我们所有的元素都不合成，会怎样呢？结果就是，相当于每次我们都必须要重新绘制所有的元素，这也不是对性能友好的选择。</p>
<p>那么好的合成策略是什么呢，好的合成策略是“猜测”可能变化的元素，把它排除到合成之外。</p>
<p>我们来举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">style</span>=<span class="string">&quot;transform:translate(0,0)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设我们的合成策略能够把 a、b 两个 div 合成，而不把 c 合成，那么，当我执行以下代码时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;c&quot;</span>).style.transform = <span class="string">&quot;translate(100px, 0)&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>我们绘制的时候，就可以只需要绘制 a 和 b 合成好的位图和 c，从而减少了绘制次数。这里需要注意的是，在实际场景中，我们的 b 可能有很多复杂的子元素，所以当合成命中时，性能提升收益非常之高。</p>
<p>目前，主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。</p>
<p>但是，这样的猜测准确性有限，所以新的 CSS 标准中，规定了 will-change 属性，可以由业务代码来提示浏览器的合成策略，灵活运用这样的特性，可以大大提升合成策略的效果。</p>
<h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。</p>
<p>一般最终位图位于显存中，也有一些情况下，浏览器只需要把内存中的一张位图提交给操作系统或者驱动就可以了，这取决于浏览器运行的环境。不过无论如何，我们把任何位图合成到这个“最终位图”的操作称为绘制。</p>
<p>这个过程听上去非常简单，这是因为在前面两个小节中，我们已经得到了每个元素的位图，并且对它们部分进行了合成，那么绘制过程，实际上就是按照 z-index 把它们依次绘制到屏幕上。</p>
<p>然而如果在实际中这样做，会带来极其糟糕的性能。</p>
<p>有一个一度非常流行于前端群体的说法，讲做 CSS 性能优化，应该尽量避免“重排”和“重绘”，前者讲的是我们上一课的排版行为，后者模糊地指向了我们本课程三小节讲的三个步骤，而实际上，这个说法大体不能算错，却不够准确。</p>
<p>因为，实际上，“绘制”发生的频率比我们想象中要高得多。我们考虑一个情况：鼠标划过浏览器显示区域。这个过程中，鼠标的每次移动，都造成了重新绘制，如果我们不重新绘制，就会产生大量的鼠标残影。</p>
<p>这个时候，限制绘制的面积就很重要了。如果鼠标某次位置恰巧遮盖了某个较小的元素，我们完全可以重新绘制这个元素来完成我们的目标，当然，简单想想就知道，这种事情不可能总是发生的。</p>
<p>计算机图形学中，我们使用的方案就是“脏矩形”算法，也就是把屏幕均匀地分成若干矩形区域。</p>
<p>当鼠标移动、元素移动或者其它导致需要重绘的场景发生时，我们只重新绘制它所影响到的几个矩形区域就够了。比矩形区域更小的影响最多只会涉及 4 个矩形，大型元素则覆盖多个矩形。</p>
<p>设置合适的矩形区域大小，可以很好地控制绘制时的消耗。设置过大的矩形会造成绘制面积增大，而设置过小的矩形则会造成计算复杂。</p>
<p>我们重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交集部分绘制即可。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在这一节课程中，我们讲解了浏览器中的位图操作部分，这包括了渲染、合成和绘制三个部分。渲染过程把元素变成位图，合成把一部分位图变成合成层，最终的绘制过程把合成层显示到屏幕上。</p>
<p>当绘制完成时，就完成了浏览器的最终任务，把一个 URL 最后变成了一个可以看的网页图像。当然了，我们对每一个部分的讲解，都省略了大量的细节，比如我们今天讲到的绘制，就有意地无视了滚动区域。</p>
<p>尽管如此，对浏览器工作原理的感性认识，仍然可以帮助我们理解很多前端技术的设计和应用技巧，浏览器的工作原理和性能部分非常强相关，我们在实践部分的性能优化部分，会再次跟你做一些探讨。</p>
<p>实际上，如果你认真阅读浏览器系列的课程，是可以用 JavaScript 实现一个玩具浏览器的，我非常希望学习课程的同学中能有人这样做，一旦你做到了，收益会非常大。这就是我今天留给你的课外作业，你可以尝试一下。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器工作流程</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器工作流程-网络部分</title>
    <url>/2020/09/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>对于前端开发来说，我们平时与浏览器打交道的时间是最多的，可浏览器对前端同学来说更像是一个神秘的黑盒，我们仅仅知道它能做什么，而不知道他是如何做到的</p>
<p>实际上，对于浏览器实现者来说，他们做的事情就是把一个 URL 变成一个屏幕上显示的网页</p>
<p>这个过程是这样的</p>
<ol>
<li><p>浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；</p>
</li>
<li><p>把请求回来的 HTML 代码经过解析，构建成 DOM 树；</p>
</li>
<li><p>计算 DOM 树上的 CSS 属性；最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；</p>
</li>
<li><p>一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；</p>
</li>
<li><p>合成之后，再绘制到界面上。</p>
</li>
</ol>
<p><img data-src="https://static001.geekbang.org/resource/image/63/4c/6391573a276c47a9a50ae0cbd2c5844c.jpg"></p>
<p>我们在开始详细介绍之前，要建立一个感性认知，我们从 HTTP 请求回来开始，这个过程并非一般想象中的一部做完再做下一步，而是一条流水线。</p>
<p>本章我们首先介绍网络通讯部分</p>
<h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>浏览器首先要做的事情就是根据 URL 把数据取回来，取回数据使用的是 HTTP 协议，实际上这个过程之前还有 DNS 查询，不过这里就不详细展开了</p>
<p>我先来了解下 HTTP 的标准</p>
<p>HTTP 标准由 IEFT 组织定制，跟它相关的标准主要由两份</p>
<ul>
<li><p>HTTP1.1 <a href="https://tools.ietf.org/html/rfc2616">https://tools.ietf.org/html/rfc2616</a></p>
</li>
<li><p>HTTP1.1 <a href="https://tools.ietf.org/html/rfc7234">https://tools.ietf.org/html/rfc7234</a></p>
</li>
</ul>
<p>HTTP 协议是基于 TCP 协议出现的，对于 TCP 协议来说，TCP 协议是一条双向的通讯管道，HTTP 在 TCP 协议的基础上，规定了 request-response 的模式，这个模式决定了通讯必定是由浏览器端首先发起的</p>
<p>大部分情况下，浏览器的实现者只需要一个 TCP 库，甚至一个现成的 HTTP 库就可以搞定浏览器的网络通讯部分，HTTP 是纯粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议</p>
<p>下面，我们试着用一个纯粹的 TCP 客户端来手工实现 HTTP</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>我们的实验需要使用 telnet 客户端，这个客户端是一个纯粹的 TCP 连接工具</p>
<p>首先我们运行 telnet，连接到极客时间主机，在命令行里输入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: time.geekbang.org</span><br></pre></td></tr></table></figure>

<p>按下两次回车，我们收到了服务器端的回复</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Date: Fri, 25 Jan 2019 13:28:12 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 182</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://time.geekbang.org/</span><br><span class="line">Strict-Transport-Security: max-age=15768000</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这就是一次完整的 HTTP 请求的过程了，我们可以看到，在 TCP 管道中传输的，完全是文本</p>
<p>在请求部分，第一行被称作 request line ，它分为三个部分 HTTP Method ，也就是请求的方法，请求的路径和请求的协议和版本</p>
<p>在响应部分，第一行被称作 response line，它也分为三个部分，协议和版本，状态码和状态文本。</p>
<p>紧随在 request line 或者 response line 之后，就是请求头/响应头，这些头由若干行组成，每行是用冒号分割的名称和值</p>
<p>在头之后，以一个空行（两个换行符）为分割，是请求体/响应体，请求体可能包含文件或者表单数据，响应体则是 HTML 代码</p>
<h3 id="HTTP-协议格式"><a href="#HTTP-协议格式" class="headerlink" title="HTTP 协议格式"></a>HTTP 协议格式</h3><p>根据上面的分析，我们可以知道 HTTP 协议，大概可以划分成如下部分</p>
<p><img data-src="https://static001.geekbang.org/resource/image/3d/a1/3db5e0f362bc276b83c7564430ecb0a1.jpg"></p>
<p>我们简单看一下，在这些部分中，path 是请求的路径完全由服务器来定义，没有很多的特别内容，而 version 几乎都是固定的字符串，response body 是我们最熟悉的 HTML，</p>
<p>下面我们来诸葛介绍其他部分</p>
<h3 id="HTTP-Method（方法）"><a href="#HTTP-Method（方法）" class="headerlink" title="HTTP Method（方法）"></a>HTTP Method（方法）</h3><p>我们首先来介绍一下 request line 里面的方法部分，这里的方法跟我们编程中的方法意义类似，表示我们此次 HTTP 请求希望执行的操作类型，方法由以下几种定义</p>
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
</ul>
<p>浏览器通过访问地址栏都是 GET 方法，表单提交产生 POST 方法</p>
<p>HEAD 则是跟 GET 类似，只返回响应头，多数由 JavaScript 发起</p>
<p>PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是一种约定，并没有强约束 CONNECT 现在多用于 HTTPS 和 WebSocket</p>
<p>OPTIONS 和 TRACE 一般用于调试，多数线上服务器都不支持</p>
<h3 id="HTTP-Status-code（状态码）和-Status-text（状态文本）"><a href="#HTTP-Status-code（状态码）和-Status-text（状态文本）" class="headerlink" title="HTTP Status code（状态码）和 Status text（状态文本）"></a>HTTP Status code（状态码）和 Status text（状态文本）</h3><p>接下来我们看看 response line 的状态和状态文本，常见的状态码有以下几种，</p>
<ul>
<li>1xx：临时回应，表示客户端请继续。</li>
<li>2xx：请求成功。200：请求成功。</li>
<li>3xx: 表示请求的目标有变化，希望客户端进一步处理。<ul>
<li>301&amp;302：永久性与临时性跳转。</li>
<li>304：跟客户端缓存没有更新。</li>
</ul>
</li>
<li>4xx：客户端请求错误。<ul>
<li>403：无权限。</li>
<li>404：表示请求的页面不存在。</li>
<li>418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议）</li>
</ul>
</li>
<li>5xx：服务端请求错误。<ul>
<li>500：服务端错误。</li>
<li>503：服务端暂时性错误，可以一会再试。</li>
</ul>
</li>
</ul>
<p>对我们来说 1xx 系列的状态码是非常陌生的，原因是 1xx 的状态码被浏览器 HTTP 库直接处理掉了，不会让上层应用知晓</p>
<p>2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码，</p>
<p>3xx 系列比较复杂，301 和 302 两个状态标识当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移，实际上 301 更接近于一种报错，提示客户端下次别来了</p>
<p>304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且 Request 中告诉了服务器，当服务器通过时间或者 Tag，发现没有更新的时候，就会返回一个包含 Body 的 304 状态</p>
<h3 id="HTTP-Head-（HTTP-头）"><a href="#HTTP-Head-（HTTP-头）" class="headerlink" title="HTTP Head （HTTP 头）"></a>HTTP Head （HTTP 头）</h3><p>HTTP 头可以看作一个键值对，原则上，HTTP 头也是一种数据，我们可以自由定义 HTTP 头和值，不过在 HTTP 规范中，规定了一些特殊的 HTTP 头，我们现在来了解以下他们</p>
<p>在 HTTP 标准中，有完整的请求/响应头规定，我们这里条几个重点的说以下</p>
<p>我们先来看看 Request Header</p>
<p><img data-src="https://static001.geekbang.org/resource/image/2b/a2/2be3e2457f08bdf624837dfaee01e4a2.png"></p>
<p>接下来看一下 Response Header</p>
<p><img data-src="https://static001.geekbang.org/resource/image/ef/c9/efdeadf27313e08bf0789a3b5480f7c9.png"></p>
<p>这里仅仅列出了比较常见的 HTTP 头，这些头我认为前端工程师应该做到不需要查询，看到就知道意思的 HTTP 头，</p>
<h3 id="HTTP-Request-Body"><a href="#HTTP-Request-Body" class="headerlink" title="HTTP Request Body"></a>HTTP Request Body</h3><p>HTTP 请求的 body 主要是用于提交表单的场景，实际上，HTTP 请求的 body 是比较自由的只要浏览器端发送的 Body 服务器端认可就行，一些常见的 body 格式是</p>
<ul>
<li>application/json</li>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/xml</li>
</ul>
<p>我们使用 html 的 form 标签提交常见的 http 请求，默认会产生 application/x-www-form-urlencoded</p>
<p>的数据格式，当有文件上传时，则会使用 multipart/form-data</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 Request-Response 模式。</p>
<p>我们首先来了解下 HTTPS。HTTPS 有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者篡改。</p>
<p>HTTPS 的标准也是由 RFC 规定的，你可以查看它的详情链接：</p>
<p><a href="https://tools.ietf.org/html/rfc2818">https://tools.ietf.org/html/rfc2818</a></p>
<p>HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。</p>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h3><p>HTTP 2 是 HTTP 1.1 的升级版本，你可以查看它的详情链接。</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7540">https://tools.ietf.org/html/rfc7540</a></li>
</ul>
<p>HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用。</p>
<p>服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。</p>
<p>TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。</p>
<blockquote>
<p>Note: 其实很多优化涉及更下层的协议。IP 层的分包情况，和物理层的建连时间是需要被考虑的。</p>
</blockquote>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在这一节内容中，我们一起学习了浏览器的第一步工作，也就是“浏览器首先使用 HTTP 协议或 HTTPS 协议，向服务端请求页面”的这一过程。</p>
<p>在这个过程中，掌握 HTTP 协议是重中之重。我从一个小实验开始，带你体验了一次完整的 HTTP 请求过程。我们一起先分析了 HTTP 协议的结构。接下来，我分别介绍了 HTTP 方法、HTTP 状态码和状态文本、HTTP Head 和 HTTP Request Body 几个重点需要注意的部分。</p>
<p>最后，我还介绍了 HTTPS 和 HTTP 2 这两个补充版本，以便你可以更好地熟悉并理解新的特性。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器工作流程</tag>
      </tags>
  </entry>
  <entry>
    <title>状态机</title>
    <url>/2020/11/18/%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<blockquote>
<p>状态机是什么？状态机应该如何去应用呢？状态机可以对业务状态进行梳理，一目了然，之后可以根据业务场景不断增加。</p>
</blockquote>
<p>在工作过程中，意外接触了一个词——“状态机”，这是个什么意思，可以为我们做产品提供怎样的用处？</p>
<p><strong>作为产品，为什么需要学习状态机呢？</strong></p>
<p>在刚进入公司的时候，根据公司产品做流程图的时候，发现自己经常会漏了这样或那样的状态，导致整体流程会有问题。后来知道了状态机这样的东西，发现用这幅图就可以很清晰的表达整个状态的流转。当然这个不是做好一款产品的必备品，但是却可以让你更加轻松的同技术等人员交流。</p>
<p>一、什么是状态机？</p>
<p>就是就是状态转移图。</p>
<p>如果流程围绕某个事物的状态变化进行，显而易见，该轮到状态机图上场了。一个状态机图中只描述一个事物，该事物有多个状态，不同的动作作用到状态上导致状态的转换。</p>
<p>举个最简单的例子：</p>
<p>人有三个状态：</p>
<ul>
<li>健康</li>
<li>感冒</li>
<li>康复中</li>
</ul>
<p>触发的条件有</p>
<ul>
<li>淋雨(t1)</li>
<li>吃药(t2)</li>
<li>打针(t3)</li>
<li>休息(t4)</li>
</ul>
<p>所以状态机就是健康-&gt;(t4)-&gt;健康；健康-&gt;(t1)-&gt;感冒；感冒-&gt;(t3)-&gt;健康；感冒-&gt;(t2)-&gt;康复中；康复中-&gt;(t4)-&gt;健康等等。就是这样状态在不同的条件下，跳转到自己或不同状态的图。</p>
<p>状态机可归纳为 4 个要素，即<strong>现态、条件、动作、次态</strong>。这样的归纳，主要是出于对状态机的内在因果关系的考虑。<strong>“现态”和“条件”是因，“动作”和“次态”是果</strong>。</p>
<p>详解如下：</p>
<ol>
<li>现态：是指当前所处的状态。</li>
<li>条件：又称为“事件”，当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。</li>
<li>动作：条件满足后执行的动作，动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。</li>
<li>次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</li>
</ol>
<p>在了解关于状态机的文章后，结合自己的平时的学习总结，我发现：<strong>在平时的业务过程中，判断即对应状态机理论中的条件，我们做什么操作改变状态即理论中的动作</strong>，同时状态必须要有始有终，否则会出现状态卡住，无法继续正常推进。</p>
<p>状态机的开始一般用空心圆表示，代表状态图的起始位置。</p>
<p><img data-src="http://5b0988e595225.cdn.sohucs.com/images/20180508/d85d69eb32524248948b04def94de314.jpeg" alt="img"></p>
<p>结尾一般用实心圆点表示，是一个状态的终止点。</p>
<p><img data-src="http://5b0988e595225.cdn.sohucs.com/images/20180508/02677f6905fd4ffdbbf5129eff72cd78.jpeg" alt="img"></p>
<p>二、那么状态机怎样去应用呢？</p>
<p>以物理课学的灯泡图为例：就是一个最基本的小型状态机，这个例子人人里的很多大神都已经举过了，这里就简单说下。</p>
<p><img data-src="http://5b0988e595225.cdn.sohucs.com/images/20180508/18bd7c123ed34779b7a987181ad226ed.jpeg" alt="img"></p>
<p>这里就是两个状态：① 打开开关，灯泡亮；② 关闭开关，灯泡灭。</p>
<p>可以画出以下的状态机图：</p>
<p><img data-src="http://5b0988e595225.cdn.sohucs.com/images/20180508/0e3c08e476844dd99026db2709c03464.jpeg" alt="img"></p>
<p>如果进度卡住，该怎么办？</p>
<p>这里有个比较形象的案例就是淘宝的自动确认收货，卖家发货后状态变为待收货，若买家迟迟不点确认收货的话，那么流程就停止在这里，卖家也迟迟收不到货款。</p>
<p>因此，在这里，淘宝做了一个条件，判断时间是否达到 15 天，如果达到 15 天，做出确认收货的动作，使得状态得到流转。</p>
<p>以小灯泡为例：假设为了节约，小灯泡开了超过 8 个小时就自动关闭，除非再次做打开开关的操作，画出此时的状态机图如下：</p>
<p><img data-src="http://5b0988e595225.cdn.sohucs.com/images/20180508/258a535c301c4c6ca40a5877f5d2707a.jpeg" alt="img"></p>
<p>同样的状态判断应用了很多场景，例如：患者购买服务或商品时，订单由待支付-已支付的状态中的通过时间条件来实现状态得到继续流转。</p>
<p>但是，判断不是状态机必要的，如：正常小灯泡的两种状态，可以不需要经过判断。起始和终止状态可能是相同的，也可能是不同的，即同一种状态可能是起始状态，也可能为终止状态。</p>
<p>在这里以外卖 app 为例：制作了一个订单的简单的状态机图，以订单的状态变更推动。</p>
<p><img data-src="http://5b0988e595225.cdn.sohucs.com/images/20180508/5dde037d12804ddabdb50f69a5080fd8.png" alt="img"></p>
<p>三、总结</p>
<p>新入门时，对状态机和业务流程图总是傻傻分不清楚，因此对于状态机和流程图进行了了解和归纳。</p>
<p>总的来说，状态机图和业务流程图有些类似，但是又有不同：</p>
<ul>
<li>两者是两种不同的思维方式；</li>
<li>两者思考的出发点不一样，因而两者所表达的目的也是不同的；</li>
<li>两者的各个节点都是不同的，流程图为动作，状态机为状态。</li>
</ul>
<p>一般情况下，我们使用的均为有限状态机。状态机可以对业务状态进行梳理，一目了然，之后可以根据业务场景不断增加。</p>
<p>同时，使用状态机和相关人员，尤其是开发，进行表达时，也可以更加清晰，提升沟通效率。</p>
]]></content>
  </entry>
  <entry>
    <title>类型兼容性</title>
    <url>/2020/09/21/%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TypeScript 里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 看下面的例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Named;</span><br><span class="line"><span class="comment">// OK, because of structural typing</span></span><br><span class="line">p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>在使用基于名义类型的语言，比如 C#或 Java 中，这段代码会报错，因为 Person 类没有明确说明其实现了 Named 接口。</p>
<p>TypeScript 的结构性子类型是根据 JavaScript 代码的典型写法来设计的。 因为 JavaScript 里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。</p>
<a id="more"></a>

<h3 id="关于可靠性的注意事项"><a href="#关于可靠性的注意事项" class="headerlink" title="关于可靠性的注意事项"></a>关于可靠性的注意事项</h3><p>TypeScript 的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript 允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>TypeScript 结构化类型系统的基本规则是，如果<code>x</code>要兼容<code>y</code>，那么<code>y</code>至少具有与<code>x</code>相同的属性。比如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Named;</span><br><span class="line"><span class="comment">// y&#x27;s inferred type is &#123; name: string; location: string; &#125;</span></span><br><span class="line"><span class="keyword">let</span> y = &#123; name: <span class="string">&quot;Alice&quot;</span>, location: <span class="string">&quot;Seattle&quot;</span> &#125;;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure>

<p>这里要检查<code>y</code>是否能赋值给<code>x</code>，编译器检查<code>x</code>中的每个属性，看是否能在<code>y</code>中也找到对应属性。 在这个例子中，<code>y</code>必须包含名字是<code>name</code>的<code>string</code>类型成员。<code>y</code>满足条件，因此赋值正确。</p>
<p>检查函数参数时使用相同的规则：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">n: Named</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello, &quot;</span> + n.name);</span><br><span class="line">&#125;</span><br><span class="line">greet(y); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>y</code>有个额外的<code>location</code>属性，但这不会引发错误。 只有目标类型（这里是<code>Named</code>）的成员会被一一检查是否兼容。</p>
<p>这个比较过程是递归进行的，检查每个成员及子成员。</p>
<h2 id="比较两个函数"><a href="#比较两个函数" class="headerlink" title="比较两个函数"></a>比较两个函数</h2><p>相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 下面我们从两个简单的函数入手，它们仅是参数列表略有不同：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// OK</span></span><br><span class="line">x = y; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>要查看<code>x</code>是否能赋值给<code>y</code>，首先看它们的参数列表。 <code>x</code>的每个参数必须能在<code>y</code>里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，<code>x</code>的每个参数在<code>y</code>中都能找到对应的参数，所以允许赋值。</p>
<p>第二个赋值错误，因为<code>y</code>有个必需的第二个参数，但是<code>x</code>并没有，所以不允许赋值。</p>
<p>你可能会疑惑为什么允许<code>忽略</code>参数，像例子<code>y = x</code>中那样。 原因是忽略额外的参数在 JavaScript 里是很常见的。 例如，<code>Array#forEach</code>给回调函数传 3 个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t force these extra arguments</span></span><br><span class="line">items.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> <span class="built_in">console</span>.log(item));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Should be OK!</span></span><br><span class="line">items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item));</span><br></pre></td></tr></table></figure>

<p>下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">() =&gt;</span> (&#123; name: <span class="string">&quot;Alice&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">() =&gt;</span> (&#123; name: <span class="string">&quot;Alice&quot;</span>, location: <span class="string">&quot;Seattle&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// OK</span></span><br><span class="line">y = x; <span class="comment">// Error, because x() lacks a location property</span></span><br></pre></td></tr></table></figure>

<p>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。</p>
<h3 id="函数参数双向协变"><a href="#函数参数双向协变" class="headerlink" title="函数参数双向协变"></a>函数参数双向协变</h3><p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多 JavaScript 里的常见模式。例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> EventType &#123;</span><br><span class="line">  Mouse,</span><br><span class="line">  Keyboard,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Event &#123;</span><br><span class="line">  timestamp: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> MouseEvent <span class="keyword">extends</span> Event &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> KeyEvent <span class="keyword">extends</span> Event &#123;</span><br><span class="line">  keyCode: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listenEvent</span>(<span class="params">eventType: EventType, handler: (n: Event) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsound, but useful and common</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> <span class="built_in">console</span>.log(e.x + <span class="string">&quot;,&quot;</span> + e.y));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Undesirable alternatives in presence of soundness</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">console</span>.log((&lt;MouseEvent&gt;e).x + <span class="string">&quot;,&quot;</span> + (&lt;MouseEvent&gt;e).y));</span><br><span class="line">listenEvent(EventType.Mouse, &lt;<span class="function">(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">void</span>&gt;(<span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> <span class="built_in">console</span>.log(e.x + <span class="string">&quot;,&quot;</span> + e.y)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Still disallowed (clear error). Type safety enforced for wholly incompatible types</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">console</span>.log(e));</span><br></pre></td></tr></table></figure>

<h3 id="可选参数及剩余参数"><a href="#可选参数及剩余参数" class="headerlink" title="可选参数及剩余参数"></a>可选参数及剩余参数</h3><p>比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。</p>
<p>当一个函数有剩余参数时，它被当做无限个可选参数。</p>
<p>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些<code>undefinded</code>。</p>
<p>有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeLater</span>(<span class="params">args: <span class="built_in">any</span>[], callback: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... Invoke callback with &#x27;args&#x27; ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span></span><br><span class="line">invokeLater([<span class="number">1</span>, <span class="number">2</span>], <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">console</span>.log(x + <span class="string">&quot;, &quot;</span> + y));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Confusing (x and y are actually required) and undiscoverable</span></span><br><span class="line">invokeLater([<span class="number">1</span>, <span class="number">2</span>], <span class="function">(<span class="params">x?, y?</span>) =&gt;</span> <span class="built_in">console</span>.log(x + <span class="string">&quot;, &quot;</span> + y));</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。比如，</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Status &#123;</span><br><span class="line">  Ready,</span><br><span class="line">  Waiting,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Blue,</span><br><span class="line">  Green,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> status = Status.Ready;</span><br><span class="line">status = Color.Green; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  feet: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, numFeet: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Size &#123;</span><br><span class="line">  feet: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">numFeet: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal;</span><br><span class="line"><span class="keyword">let</span> s: Size;</span><br><span class="line"></span><br><span class="line">a = s; <span class="comment">// OK</span></span><br><span class="line">s = a; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h3 id="类的私有成员和受保护成员"><a href="#类的私有成员和受保护成员" class="headerlink" title="类的私有成员和受保护成员"></a>类的私有成员和受保护成员</h3><p>类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>因为 TypeScript 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如，</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// OK, because y matches structure of x</span></span><br></pre></td></tr></table></figure>

<p>上面代码里，<code>x</code>和<code>y</code>是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// Error, because x and y are not compatible</span></span><br></pre></td></tr></table></figure>

<p>在这里，泛型类型在使用时就好比不是一个泛型类型。</p>
<p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成<code>any</code>比较。 然后用结果类型进行比较，就像上面第一个例子。</p>
<p>比如，</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> identity = <span class="function"><span class="keyword">function</span> &lt;<span class="title">T</span>&gt;(<span class="params">x: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reverse = <span class="function"><span class="keyword">function</span> &lt;<span class="title">U</span>&gt;(<span class="params">y: U</span>): <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">identity = reverse; <span class="comment">// OK, because (x: any) =&gt; any matches (y: any) =&gt; any</span></span><br></pre></td></tr></table></figure>

<h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="子类型与赋值"><a href="#子类型与赋值" class="headerlink" title="子类型与赋值"></a>子类型与赋值</h3><p>目前为止，我们使用了“兼容性”，它在语言规范里没有定义。 在 TypeScript 里，有两种兼容性：子类型和赋值。 它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和<code>any</code>来回赋值，以及<code>enum</code>和对应数字值之间的来回赋值。</p>
<p>语言里的不同地方分别使用了它们之中的机制。 实际上，类型兼容性是由赋值兼容性来控制的，即使在<code>implements</code>和<code>extends</code>语句也不例外。</p>
<p>更多信息，请参阅<a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md">TypeScript 语言规范</a>.</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言的一些性质</title>
    <url>/2020/11/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<h3 id="图灵完备性"><a href="#图灵完备性" class="headerlink" title="图灵完备性"></a>图灵完备性</h3><ul>
<li>命令式——图灵机<ul>
<li>goto</li>
<li>if 和 while</li>
</ul>
</li>
<li>声明式——lambda<ul>
<li>递归</li>
</ul>
</li>
</ul>
<p>图灵完备性应该是大家经常会听说的一个概念，所有的编程语言它必备的一个条件就是图灵完备性，图灵完备性最早的提出是由我们计算机界的老祖宗图灵，他在这个研究数学上的可计算性的时候提出的这样的一个概念，</p>
<p>图灵完备性有几个不同的表达方式，比如说跟图灵机完全等效的，这就是图灵完备的，当然这个定义特别的不直观，它虽然很严格，但是它并不直观，如果给大家一个直观的表述就是：“所有的可计算的问题都可用来描述的，这样的语言就是具备图灵完备性的”</p>
<p>经历了一代一代的计算机语言的发展，其实图灵完备性逐渐的收敛到了几个固定的模式。所有的命令式语言，基本上是从图灵机理论来的图灵完备性，所以它实现图灵完备的方式，要么是使用 goto 语句，要么是使用 if 语句加 while 语句，经过一些数学家的证明这两个模式都是可以实现完整的图灵完备性的，</p>
<p>然后这个声明式语言，那么他来自于另一个数学家的成果，叫做 lambda 演算，这是丘奇提出来的，lambda 演算你可以理解为它是数学上定义的一种所谓的 lambda 函数，它和我们今天的函数是比较相似的，但它的基本意思就是一种替换的关系，lambda 它可以通过递归来实现图灵完备，</p>
<p>这两位数学家都是在很早的时间相继发表的这个成果，所以在可计算性上面呢，基本上计算机语言也是有两个流派，一个是 goto 和 if 和 while，另一个是用递归来产生图灵完备性，这两个方式在很多现代语言里基本上是都支持的，所以大家在使用的时候可以去经常去判断它们的适用的场景，然后选择合适的方式去实现它，</p>
<h3 id="静态与动态"><a href="#静态与动态" class="headerlink" title="静态与动态"></a>静态与动态</h3><p>咱们经常会说这个语言是个动态语言那个语言它是静态语言，然后有的时候我们说类型这个是动态类型，那个是静态类型，那动态和静态在计算机领域里面这个术语是什么意思呢？我们给大家一些直观的印象去讲这件事情，</p>
<p>动态其实你可以理解为它一定是在用户的设备上面去运行的或者是在在线的服务器上面去运行的，那么它运行的时机就是在产品实际的应用运行时，那么它在这个动态基本上对应了一个概念叫 run time 就是运行时，运行时的这个概念反过来它也跟我们前面的两个场景是非常的相关联的，</p>
<p>静态最显著的一个特征就是在程序员的设备上运行的，那么它的运行时机也就是在产品的开发时发生的，我们一般来说会把它称作静态，比如静态类型检查就是在你编写这段代码的时候你就已经可以获得类型的检查了，静态它通常也对应着一个术语叫 compound time 就是编译时，这个也来自于非常古老的一些编译型语言的这样的一个概念啊，</p>
<p>从 C 语言时代就开始流行这个 compound time 和 run time 这样的一种对应关系了，像 JavaScript 这种解释执行的语言其实它没有 compound time 的，咱们现在虽然有的也会用 webpack 去 build 一下，但是其实它是没有真正的 compound time 的，所以说其实今天这个 run time 跟 compound time 的对应已经不准确了，但是我们仍然会愿意沿用这个 compound time 的这个习惯认为 JavaScript 它也是有一个我们在开发时的这样的一个时间</p>
<p>我们也会有时候会用 compared time 的这个词来讲 JavaScript 的里面的一些特性</p>
<p>这就是所谓的动态与静态的区分了</p>
<h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>关于类型系统其实非常的复杂，这里我还是给大家介绍一些基本的概念，首先是动态类型系统与静态类型系统，这个就是跟刚才我们去解释动态与静态是非常一致的。动态系统就是在用户的机器上，用户的内存里面能够找到的这个类型那么它就是动态类型系统，那与之相对的静态类型系统就是只在程序员编写代码的时候能够保留的类型信息，我们就叫它静态类型系统，典型的动态类型系统，比如 JavaScript 的就是动态类型系统，我们在代码里面，可以把这个类型当字符串去取出来，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="string">&quot;string&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后典型的静态类型系统就像 C++ 这种，它其实最终编译到目标机器的代码的时候，所有的类型信息都已经被丢掉了，所以说我们去区分动态和静态的，其实最简单的办法就是区分它在谁的电脑上能够保留下来啊，而像 Java 一类的语言呢，因为它提供了反射机制，所以我会更愿意把它称作一种半动态半静态的类型系统，就是在编译时主要的类型检查和这个类型的这个操作都已经在编译时被处理掉了，但是如果你想在运行时去获得这个类型的一些信息，你还是可以通过反射去获取的，这个就是一些比较新的语言会采取的一种方式，</p>
<p>然后还有一个就是强类型与弱类型，在很多时候常常跟动态与静态去混淆，其实强类型与弱类型它只是在说明在这个编程语言里类型转换发生的形式，</p>
<p>强类型的语言它的类型转化是不会默认发生的，像这个 JavaScript 就是一个典型的弱类型的语言，最著名的比如说我们的用一个 string 和一个 number 相加，那么我们的 JavaScript 引擎会默认的把 number 转换成 string 类型之后，最后给你得到 string，而像这个==这种它是 JavaScript 里面的一个臭名昭著失败的语言特性，它在 string 和 boolean 之间，如果说你去==运算的话，它还会先把这个 boolean 转成 number，然后再去跟 string 去做是否相同的对比，这是一个非常奇怪的设计</p>
<p>然后再说回这个类型，就往往会产生一些复合类型，比如说我们可以定一个结构体一个对象，那么它的这个 a 属性，它必须属于类型 T1，然后我们有一些函数，因为像 JavaScript 语言，它的函数是可以作为参数传递的，所以这个函数也有个类型，这个我们一般把它称作函数签名，函数签名里包含参数类型和返回值类型两个部分。那参数类型它又是一个列表，所以说函数类型它可能就会有这个 T1，T2，然后变成 T3 这样的一种形式，然后就是子类型典型的语言就是 C++，它会有这个字类型的一个概念，当然了，所有的基于类的面向对象的语言呢，它都会把类的结构关系变成类型的关系啊，注意类和类型，其实是两个概念，那么有了子类型的这个概念呢，所以说在做类型转换的时候它就会有一些默认的行为，比如说能用父类型的地方它都能用子类型，</p>
<p>然后还有一种就是泛型，在一些语言里面现在又多了一种范式叫做泛型编程，还可以把类型当做一个参数一样的东西去传递给我们的某一段代码结构，这个代码结构有可能是类，也有可能是函数，分别对应着泛型类和泛型函数，然后泛型跟子类型相结合就会产生什么逆变，协变这样的东西，这里呢也不给大家展开去细讲了，有兴趣的同学，可以去看 TypeScript 泛型相关的内容</p>
]]></content>
  </entry>
  <entry>
    <title>装箱转换和拆箱转换</title>
    <url>/2020/11/22/%E8%A3%85%E7%AE%B1%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%8B%86%E7%AE%B1%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>JavaScript 是弱类型的语言，所以在 JavaScript 中类型转换这样的操作时时刻刻都在发生，基本类型之间的类型转换规则大都是清晰明了符合我们的直觉的，但是涉及到对象的类型转换就会使用到两种比较复杂的规则</p>
<ul>
<li>装箱转换（基本类型 -&gt; object）</li>
<li>拆箱转换（object -&gt; 基本类型）</li>
</ul>
<h3 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h3><p>把基本类型转化为相应的对象</p>
<blockquote>
<p>《JavaScript 高级程序设计》：每当读取一个基本类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>如上所视，变量 s1 是一个基本类型值，它不是对象，所以它不应该有方法。但是 JavaScript 在内部其实会去判断点运算符之前得到是一个对象还是一个基本类型，如果是基本类型则 JavaScript 就会自动的调用指定的包装类，将基本类型临时转换为对象类型再去访问其成员，而访问过后这个临时的对象就会被销毁</p>
<p>这个过程也可以用代码来展现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>).substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>在 object 类型中对以下基础类型提供给了一个包装类</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>对象</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td>new Number(1)</td>
<td>1</td>
</tr>
<tr>
<td>String</td>
<td>new String(“a”)</td>
<td>“a”</td>
</tr>
<tr>
<td>Boolean</td>
<td>new Boolean(true)</td>
<td>true</td>
</tr>
<tr>
<td>Symbol</td>
<td>new Object(Symbol(“a”))</td>
<td>Symbol(“a”)</td>
</tr>
</tbody></table>
<p>我们使用点或者方括号去访问属性的时候，如果方括号之前的变量或者表达式得到的是一个基础类型，那么就会自动调用装箱过程，不需要我们再去调用标准里规定的这些构造器，所以大家会看到一个现象，在 Number 这个 class 上定义了什么样的值，那么我们正常的 Number 类型的值它也可以通过点运算去访问，这是 JavaScript 一个比较方便的地方 它的背后也包含了一些设计思想，但是这个过程也会往往诱导新人认为 <code>Number 类型</code>跟 <code>Number类</code>是一个东西，但其实并不是这样，我们可以通过 <code>typeOf</code> 去区分他到底是包装前的值，还是包装后的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.test = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> aaa = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aaa.test);</span><br><span class="line"><span class="comment">// test</span></span><br></pre></td></tr></table></figure>

<h3 id="拆箱转换"><a href="#拆箱转换" class="headerlink" title="拆箱转换"></a>拆箱转换</h3><p>把对象转化为相应的需要的基本类型</p>
<p>拆箱转换是指把一个 Object 转成一个基本类型，这其中一个主要的过程叫做 <code>ToPrimitive</code> , <code>ToPrimitive</code> 发生在我们表达式定义的方法面面，比如 Object + Object，或者 Object 参与运算的情况，它都会调用 <code>ToPrimitive</code> 过程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    toString() &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">&quot;toString&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">   	&#125;,</span><br><span class="line">    valueOf() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;valueOf&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;toPrimitive&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对象 o 身上的三个方法会影响到 <code>ToPrimitive</code> 过程</p>
<ul>
<li><code>toString</code></li>
<li><code>valueOf</code></li>
<li><code>[Symbol.toPrimitive]</code></li>
</ul>
<p>如果定义了 <code>Symbol.toPrimitive</code> 那么它就会忽略 <code>toString</code> 和 <code>valueOf</code>,直接调用<code>Symbol.toPrimitive</code>方法</p>
<p>否则我们在进行不同的转换的时候，它会根据提示来决定调用 <code>toString</code> 和 <code>valueOf</code> 的先后顺序，我们来看两个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如加法运算会优先调用 valueOf 如果返回了一个基本类型的数据，则终止 ToPrimitive 过程，否则继续调用 toString 方法如果依然没有返回基本类型则会抛错</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;valueOf&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;x&quot;</span> + o);</span><br><span class="line"><span class="comment">// valueOf</span></span><br><span class="line"><span class="comment">// x1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当对象作为属性名的时候会优先调用toString方法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;valueOf&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> x = &#123;&#125;;</span><br><span class="line">x[o] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2020/11/05/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>所谓贪心算法是指：在对问题求解的时候，总是做出在当前看来最好的选择，也就是说，不从整体最优上加以考虑，他所做出的进士某种意义上的局部最优解</p>
<p>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择，必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关，</p>
<p>所有对采用的贪心策略一定要仔细分析其是否满足无后效性</p>
<h3 id="贪心算法的基本思路"><a href="#贪心算法的基本思路" class="headerlink" title="贪心算法的基本思路"></a>贪心算法的基本思路</h3><ol>
<li>建立数学模型来描述问题</li>
<li>把求解的问题分成若干子问题</li>
<li>对每一个子问题求解，知道子问题的局部最优解</li>
<li>把子问题的局部最优解合成原来问题的一个解</li>
</ol>
<h3 id="贪心算法适用的问题"><a href="#贪心算法适用的问题" class="headerlink" title="贪心算法适用的问题"></a>贪心算法适用的问题</h3><p>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。 实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p>
<h3 id="贪心算法的实现框架"><a href="#贪心算法的实现框架" class="headerlink" title="贪心算法的实现框架"></a>贪心算法的实现框架</h3><p>从问题的某一初始解出发；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x； 能朝给定总目标前进一步</span></span><br><span class="line"><span class="keyword">while</span> (x) &#123;</span><br><span class="line">     <span class="comment">//利用可行的决策，求出可行解的一个解元素；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由所有解元素组合成问题的一个可行解；</p>
<h3 id="贪心算法的选择"><a href="#贪心算法的选择" class="headerlink" title="贪心算法的选择"></a>贪心算法的选择</h3><p>因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>五大常用经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符优先级</title>
    <url>/2020/11/21/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h3 id="语法树和运算符优先级的关系"><a href="#语法树和运算符优先级的关系" class="headerlink" title="语法树和运算符优先级的关系"></a>语法树和运算符优先级的关系</h3><p>我们都知道四则运算中运算符的优先级是 <code> +- 小于 */ 小于 ()</code> ，所以如果我们要构造一棵描述四则运算的语法树的时候，我们需要考虑</p>
<ul>
<li>括号会形成比乘除更小一级的语法结构</li>
<li>乘除会形成比加减更小一级的语法结构</li>
<li>加减的是更高一级的语法结构</li>
</ul>
<p>比如说我们的 <code>1+2*3</code> 的表示如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  +</span><br><span class="line"> / \</span><br><span class="line">1   *</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br></pre></td></tr></table></figure>

<p>这棵树并不严谨，它并不是一个抽象语法树，它是一个所谓的中缀树，但是它大概可以说明我们运算符优先级会影响到语法树的构成</p>
<p>所以说我们会在 JavaScript 的标准中，它是用产生式来描述运算符的优先级的（产生式更加严谨）</p>
<p>接下来我们就来从它的优先级由高到低来看看整个表达式</p>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>以下列表大概说明了 JavaScript 中表达式的优先级关系</p>
<ol>
<li><p>Member</p>
<ul>
<li>a.b</li>
<li>a[“b”]</li>
<li>foo`string`</li>
<li>super.b</li>
<li>super[b]</li>
<li>new.target</li>
<li>new Foo()</li>
</ul>
</li>
<li><p>New</p>
<ul>
<li>new Foo</li>
</ul>
</li>
<li><p>Call</p>
<ul>
<li>foo()</li>
<li>super()</li>
<li>foo()[“b”]</li>
<li>foo().b</li>
<li>foo()`abc`</li>
</ul>
</li>
<li><p>Update</p>
<ul>
<li>a++</li>
<li>a–</li>
<li>–a</li>
<li>++a</li>
</ul>
</li>
<li><p>Unary</p>
<ul>
<li>delete a.b</li>
<li>void foo()</li>
<li>typeof a</li>
<li>+a</li>
<li>-a</li>
<li>~a</li>
<li>!a</li>
<li>await a</li>
</ul>
</li>
<li><p>Exponental</p>
<ul>
<li>**</li>
</ul>
</li>
<li><p>Multiplicative</p>
<ul>
<li>*，/，%</li>
</ul>
</li>
<li><p>Additive</p>
<ul>
<li>+，-</li>
</ul>
</li>
<li><p>Shift</p>
<ul>
<li>&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;</li>
</ul>
</li>
<li><p>Relationship</p>
<ul>
<li>&lt;，&gt;，&lt;=，&gt;=，instanceof，in</li>
</ul>
</li>
<li><p>Equality</p>
<ul>
<li>==</li>
<li>!=</li>
<li>===</li>
<li>!==</li>
</ul>
</li>
<li><p>Bitwise</p>
<ul>
<li>&amp;，^，|</li>
</ul>
</li>
<li><p>Logical</p>
<ul>
<li>&amp;&amp;</li>
<li>||</li>
</ul>
</li>
<li><p>Conditiional</p>
<ul>
<li>? :</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/09/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<p>单例模式是一种常用的模式，有一些对象我们往往只需要一个比如，线程池，全局缓存，浏览器中的 window 对象等，在 JavaScript 开发中，单例模式的用途同样非常广泛，试想一下，当我们点击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗只会被创建一次，那么这个登录浮窗就是和使用单例模式来创建</p>
<h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><p>要实现一个单例模式其实并不复杂，无非是用一个变量来标指当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Stingleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Stingleton.prototype.instance = <span class="literal">null</span>;</span><br><span class="line">Stingleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">Stingleton.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.instance)&#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = <span class="keyword">new</span> Stingleton(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = Stingleton.getInstance(<span class="string">&quot;sven1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = Stingleton.getInstance(<span class="string">&quot;sven2&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a === b)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span>  instance = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">           instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>我们通过<code>Singleton.getInstance</code>来获取 <code>Singleton</code> 类的唯一对象，这种方式相对简单，但有一个问题，就是为了增加这个类的‘不透明性’，<code>Singleton</code>类的使用者必须知道这是一个单例类，根以往通过<code>new XXX</code>的方式来获取对象不同，这里偏要使用 <code>Singleton.getInstance </code>来获取对象。</p>
<p>接下来顺便进行一些小测试，来证明这个单例类是可以信赖的；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = Singleton.getInstance(<span class="string">&#x27;sven1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> b = Singleton.getInstance(<span class="string">&#x27;sven2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b)</span><br></pre></td></tr></table></figure>

<p>虽然现在已经完成了一个单例模式的编写，但这段单例模式代码的意义并不大，从下一节开始，我们将一步步编写出更好的单例模式</p>
<h3 id="透明的单例模式"><a href="#透明的单例模式" class="headerlink" title="透明的单例模式"></a>透明的单例模式</h3><p>我们现在的目标是实现一个透明的单例类，用户从这个类中创建对象的时候，可以像使用其他任何普通类一样，在下面的例子中，我们将使用<code>CreateDiv</code>单例类，它的作用是负责在页面中创建唯一的<code>div</code>节点，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 判单之前是否创建过/ 如果有则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (instances) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.html = html;</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">        instance = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(instance)</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;;</span><br><span class="line">    CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">        div.innerHTML = <span class="built_in">this</span>.html;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> CreateDiv;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> CreateDiv(<span class="string">&quot;sven1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> CreateDiv(<span class="string">&quot;sven2&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a === b)</span><br></pre></td></tr></table></figure>

<p>虽然现在已经完成了一个透明单例类的编写，但它同样有一些缺点。为了把<code>instance</code>封装起来，这增加了一些程序的复杂性，阅读起来不是很舒服</p>
<p>观察现在的<code>Singleton</code>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判单之前是否创建过/ 如果有则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.html = html;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">    instance = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(instance)</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码中，<code>CreateDiv</code> 的构造函数实际上负责了两件事情，第一是创建对象和执行初始化 init 方法，第二是保障只有一个对象，虽然我们目前还没有接触过”单一职责”的概念，但可以明确的是，这是一种不好的做法，至少这个构造函数看起来很奇怪。假设我们某天需要利用这个类，在页面上创建千千万万的 div，即要让这个类从一个单例类变成一个普通的可以生产多个实例的类，那我们必须改写 CreateDiv 的构造函数，把控制创建 唯一对象的那一段去掉，这种修改会给我们带来不必要的麻烦</p>
<h3 id="使用代理实现单例模式"><a href="#使用代理实现单例模式" class="headerlink" title="使用代理实现单例模式"></a>使用代理实现单例模式</h3><p>现在我们通过引入代理类的方式，来解决上面提到的问题</p>
<p>我们依然使用上面的代码， 首先在<code>CreateDiv</code>的构造函数中把负责管理单例的代码移除出去，使他成为一个普通的创建 div 的类，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.html=html;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    div.innerHTML = <span class="built_in">this</span>.html;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来引入代理类 ProxySingletonCreateDiv;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ProxySingletonCreateDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;;</span><br><span class="line">    <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> CreateDiv(html);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ProxySingletonCreateDiv(<span class="string">&quot;sven1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ProxySingletonCreateDiv(<span class="string">&quot;sven2&quot;</span>);</span><br><span class="line">alert(a === b)</span><br></pre></td></tr></table></figure>

<p>通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们把负责管理单例的逻辑移到了代理类 ProxySingletonCreateDiv 中，这样一来，CreateDiv 就变成了一个普普通通的类，它跟 proxySingletonCreateDiv 组合起来就可以达到单例模式的效果</p>
<p>本例是缓存代理的应用之之一，在第六章中，我们继续了解代理带来的好处</p>
<h3 id="JavaScript-中的单例模式"><a href="#JavaScript-中的单例模式" class="headerlink" title="JavaScript 中的单例模式"></a>JavaScript 中的单例模式</h3><p>前面提到的几种单例模式的实现，更多的是接近传统面向对象语言中的实现，单例对象从“类”中创建而来，在以类为中心的语言中，这是很自然的做法，比如在 java 中，如果需要某个对象，那就必须先定义类，对象总是从类中创建而来</p>
<p>但 JavaScript 其实是一门无类（class-free）语言，也正因为如此，生搬代理模式的概念并无意义，在 JavaScript 中创建对象的方法非常简单，既然我们只需要一个“唯一”的对象，为什么要为它先创建一个“类”呢，这无异于穿棉衣洗澡，传统的单例模式实现在 JavaScript 中并不适用，</p>
<p>单例模式的核心是确保只有一个实例，并提供全局访问。</p>
<p>全局变量不是单例模式，但在 JavaScript 开发中，我们经常会把全局变量当成单例来使用例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>当用这种方式创建对象 a 的时候，对象 a 确实是独一无二的，如果 a 变量声明在全局作用域下，则我们可以在代码中的任何位置使用这个变量，JavaScript 中的变量也很容易被不小心覆盖，相信每个 JavaScript 程序员都曾经经历过变量冲突的痛苦，就像上面的对象 var a = {}; 随时有可能被被人覆盖</p>
<p>作为普通开发者，我们有必要尽量减少使用全局变量的使用，即使需要，也要把它的污染降低到最小，一下几种方式可以相对降低全局变量带来的命名污染</p>
<p>使用命名空间</p>
<p>适当的使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量最简单的方法依然是对象字面的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> namespace1 = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把<code>a</code>和<code>b</code>都定义为 <code>namespace1</code> 的属性，这样就可以减少变量和全局作用域打交道的机会，另外我们还可以动态的创建命名空间， 代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> myApp = &#123;&#125;;</span><br><span class="line">myApp.namespace = funcqqtion (name) &#123;</span><br><span class="line">  <span class="keyword">let</span> parts = name.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> current = myApp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> parts) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!current[parts[i]]) &#123;</span><br><span class="line">      current[parts[i]] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current[parts[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myApp.namespace(<span class="string">&quot;event&quot;</span>);</span><br><span class="line">myApp.namespace(<span class="string">&quot;dom.style&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myApp);</span><br></pre></td></tr></table></figure>

<p>也可以使用 闭包封装私有变量这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _name = <span class="string">&#x27;sven&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> _age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _name + _age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>我们使用下划线来约定私有变量，<code>_name</code>和<code>_age</code> 它们被封装到闭包产生的作用域里，外部都是访问不到这两个变量的，这就避免了对全局的命令污染</p>
<h3 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h3><p>前面我们了解了单例模式的一些实现方法，本节我们来了惰性单例。惰性单例指的是在需要的时候才创建对象的实例，惰性单例是单例模式的重点，这种技术在实际开发中非常有用， 有用程度可能超出我们的想像，实际上在本章开头就使用过这种技术了，<code>instance</code>实例对象总是在我们调用<code>Singleton.getInstance</code>的时候才被创建，而不是在页面加载好的时候就创建，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(name)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>不过这是基于“类”的单例模式，前面说过，基于“类”的单例模式在 JavaScript 中并不适用，下面我们将以 webQQ 的登录浮窗为例，介绍与全局变量结合实现惰性的单例</p>
<p>假设我们设计 webqq 的开发人员，当点击导航上的 qq 头像的时候，会出现一个登录弹窗，很明显这个浮窗在页面中总是唯一的，不可能出现同时存在两个登录弹窗的情况</p>
<p>第一种解决方案是在页面加载完成的时候，便创建好这个 div 浮窗，这个浮窗一开始肯定是隐藏的，只有当用户点击登录的时候他才会出现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> loginLayer = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="javascript">      div.innerHTML = <span class="string">&quot;我是登录弹窗&quot;</span>;</span></span><br><span class="line"><span class="javascript">      div.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.appendchild(div);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div;</span></span><br><span class="line">    &#125;)();</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      loginLayer.style = <span class="string">&quot;block&quot;</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方式有一个问题，也许我们进入 qq 这是为了玩玩游戏或者看看天气，根本不需要进行登录操作，因为登录弹窗总是一开始就被创建好，那么可能白白浪费一些 dom 节点现在我们改写一下代码，使用户点击登录按钮的时候才开始创建该弹窗</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="javascript">      div.innerHTML = <span class="string">&quot;我是登录弹窗&quot;</span>;</span></span><br><span class="line"><span class="javascript">      div.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.appendchild(div);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div;</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> loginLayer = createLoginLayer();</span></span><br><span class="line"><span class="javascript">      loginLayer.style = <span class="string">&quot;block&quot;</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在我们达到了惰性的目的，但是也失去了单例的效果，当我们每次点击登录按钮的时候，都会创建一个新的登录浮窗 div 虽然我们可以点击浮窗上的关闭按钮，把这个节点从页面中删除掉，但这样频繁的创建和删除节点明显是不合理的也是不必要的</p>
<p>也许你已经想到了，我们可以用一个变量来判断是否已经创建过登录浮窗，这也是本节第一段代码中的做法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createLoginLayer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!div)&#123;</span><br><span class="line">            div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">            div.innerHTML = <span class="string">&#x27;我是登录弹窗&#x27;</span></span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> div</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loginLayer = createLoginLayer()</span><br><span class="line">    loginLayer.style = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通用单例模式"><a href="#通用单例模式" class="headerlink" title="通用单例模式"></a>通用单例模式</h3><p>上一节我们完成了一个可用的惰性单例，但是我们发现它还有如下一些问题，</p>
<ul>
<li>这段代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在 createLoginLayer 对象内部</li>
<li>如果我们下此需要创建页面中唯一的 iframe，或者 script 标签，用来跨域请求数据，就必须如法炮制，把 createLoginLayer 函数几乎照抄一遍</li>
</ul>
<p>我们现在需要把不变的部分隔离出来，先不考虑创建一个 div 和创建一个 iframe 有多少差异，管理单例的逻辑其实是可以完全抽离出来的，这个逻辑始终是一样的，用一个变量来标志是否创建过对象，如果是，则在下次直接返回这个已经创建好的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj;</span><br><span class="line"><span class="keyword">if</span>(!obj)&#123;</span><br><span class="line">    obj = xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们把管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在 getSingle 函数内部，创建对象的方法当成参数动态传入到 getSingle 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来将用于创建登录浮窗的方法用参数形式传入到 getSingle 函数中，我们不仅可以传入 createLoginLayer 还可以传入其他 createScript createIframe createXhr 等，之后再让 getSingle 返回一个新的函数，并且用变量 result 来保存 fn 的计算结果，result 变量因为身在闭包中，它永远不会被销毁，在将来的请求中，如果 result 已经被赋值了，那么它将返回这个值，代码如下，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    div.innerHTML = <span class="string">&quot;我是登录弹窗&quot;</span>;</span><br><span class="line">    div.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.appendchild(div)</span><br><span class="line">    <span class="keyword">return</span> div</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> createSingleLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loginLayer = createSingleLoginLayer()</span><br><span class="line">    loginLayer.style = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们再试试创建唯一 iframe 用于动态加载三方页面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createIframe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">    <span class="built_in">document</span>.appendchild(iframe)</span><br><span class="line">    <span class="keyword">return</span> iframe</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loginLayer = createIframe();</span><br><span class="line">    loginLayer.src = <span class="string">&#x27;http://www.baidu.com&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们把创建实例对象的职责和管理单例的职责分别放置在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能，看起来是一件挺奇妙的事情这种单例模式的用途远不止创建对象，比如我们通常渲染完页面中的一个列表之后，接下来要给这个列表绑定 click 事件，如果是通过 ajax 动态往列表里加数据，在使用事件代理的前提下 click 事件实际上只需要在第一次列表渲染的时候被便规定一次，但是我们不想去判断当前是否第一次渲染，如果借助于 jquery 我们通常选择给节点绑定 one 事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;div&quot;</span>).one(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;click&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染列表&quot;</span>)</span><br><span class="line">    bindEvent()</span><br><span class="line">&#125;</span><br><span class="line">render()</span><br><span class="line">render()</span><br><span class="line">render()</span><br></pre></td></tr></table></figure>

<p>那如果使用 getSingle 函数呢，如何达到一样的效果，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bindEvent = getSingle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染列表&quot;</span>)</span><br><span class="line">    bindEvent()</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br><span class="line">render();</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>单例模式是我们学习的第一个模式，我们先学习了传统的单例模式实现，也了解到因为语言的差异性，有更适合的方法在 JavaScript 中创建单例，第一章还提到了代理模式和单一职责原则，后面我们会对他们进行更加详细的介绍</p>
<p>在 getSingle 函数中，实际上也提到了闭包和高阶函数的概念，单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个，更奇妙的是，创建对象和管理单例的职责被划分到两个不同的方法中，这两个方法组合起来才具有单例模式的威力</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>持续集成与持续部署</title>
    <url>/2020/11/09/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>DevOps、持续集成、持续交付、持续部署、敏捷等词语大家应该都耳熟能详了，说到底就是快速交付价值，从工程上、管理上、组织上、工具上来提高效率，打造可靠的、快速的产品（项目）交付过程。本书将围绕项目管理、自动化部署、自动化发布、自动化测试、容器云来实现持续集成、持续交付及持续部署，因为它不是一本理论图书，不打算大谈道理，我们将直接谈论持续集成、持续交付、持续部署的价值，抛出问题，说思路，讲方案，讲实际操作。希望能够帮助广大读者快速在企业落地持续集成、持续交付与持续部署。</p>
<h3 id="CI-amp-CD-的价值"><a href="#CI-amp-CD-的价值" class="headerlink" title="CI&amp;CD 的价值"></a>CI&amp;CD 的价值</h3><ul>
<li>持续集成（Continuous Integration，CI）是软件开发实践，在持续集成中，团队成员频繁集成它们的工作成果，一般每人每天至少集成一次，或者多次，每次集成会经过自动构建（包括静态扫描、安全扫描、自动测试等过程）的检验，以尽快发现集成错误。许多团队发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度（以上引用自 Martin Fowler 对持续集成的定义）。</li>
<li>持续交付（Continuous Delivery）是指频繁地将软件的新版本交付给质量团队或者用户，以供评审，如果评审通过，代码就进入生产阶段。</li>
<li>持续部署（Continuous Deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境中。</li>
</ul>
<p>通过上面的定义我们不难发现，持续突出的就是一个快字，商业软件的快速落地需求推动了软件工程的发展。可持续的、快速迭代的软件过程是当今主流开发规约。尤其在互联网行业，快速响应即是生命线。从一个想法到产品落地都处在冲锋的过程中，机会稍纵即逝。响应用户反馈也是万分敏捷，早晨的反馈在当天就会上线发布，快得让用户感觉倍受重视。“快”已经成为商业竞争力。这一切都要求企业具备快速响应的能力，这正是推动持续集成、持续交付、持续部署的动力。</p>
<p>产品或者项目的参与者应该能够深刻体会到团队协作时，工作交接（系统集成）部分最容易出问题，会消耗大量的沟通成本与时间成本，直接拖慢进度。所以，一个行之有效的项目管理过程（包括沟通管理、流程管理）在大型项目中效果明显。当前敏捷开发是主流，持续集成、持续交付与持续部署正好能够帮助高效地实施敏捷过程，促进开发、运维和质量保障（QA）部门之间的沟通、协作与整合。</p>
<h3 id="CI-amp-CD-带来的变化"><a href="#CI-amp-CD-带来的变化" class="headerlink" title="CI&amp;CD 带来的变化"></a>CI&amp;CD 带来的变化</h3><p>通常把开发工作过程分为编码、构建、集成、测试、交付、部署几个阶段（见图 1-1），持续集成、持续交付、持续部署刚好覆盖这些阶段。从提高效率上来讲，对每个阶段的优化都可以缩短软件交付时间。持续集成、持续交付及持续部署的过程即是一个软件开发优化过程。</p>
<p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/v2-958984fefb4525db84839cdc619294bf_720w.jpg"></p>
<p>墨菲定律大家都不陌生，越是担心什么就越会发生什么；在多团队协作时，比如系统对接时，我们都会担心对接是否顺利，往往也不枉我们担心，时常我们会被集成折磨得焦头烂额。有很多团队只是担心，并没有拿出有效的措施去避免这种事情发生，以至于延长了交付时间。既然担心，我们何不及早集成，把问题先暴露出来？</p>
<p>目前多数公司都已经使用了版本管理工具来管理源码，比如 GitLab、SVN 等版本管理工具。在版本管理这一块，公司会根据自己的实际情况来制订版本管理办法。对于持续集成来说，业内建议只维护一个源码仓库，降低版本管理的复杂度。开发人员持续提交自己的修改，自动触发编译，自动集成，自动进行自动化的测试，及早反馈集成过程中的问题，就能更好地防止出现平时不集成、集成就出问题的现象。</p>
<p>通过自动化的持续集成，把管理流程固化；保证集成的有序性、可靠性；减少版本发布的不合规性（开发或者测试手动打包，可能一天打多个包，更新多次，测试不充分），保证版本可控，问题可追溯（至于哪个版本出现的问题，可以回溯）。</p>
<h3 id="CI-amp-CD-实施现状"><a href="#CI-amp-CD-实施现状" class="headerlink" title="CI&amp;CD 实施现状"></a>CI&amp;CD 实施现状</h3><p>在日常生活中处处都体现着一个“快”字，互联网更是对快追求到极致。持续集成、持续交付、持续部署在互联网行业更为广泛。作者没有统计哪些公司在用，只是圈子中朋友公司都实施了持续集成，具备持续交付能力。至于持续部署就没这么广泛了，毕竟持续部署不仅仅是技术问题，还涉及管理、营运等问题。尤其是一些金融企业、大型国企，开发团队外包，测试外包，运营半外包，安全要求高，很难快速实施。多数能够在测试环境中建立起 CI&amp;CD 就已经很不错了。</p>
<p>阿里云、腾讯云、网易蜂巢等国内云，都提供了从 GitLab 下拉代码、编译打包、单元测试、镜像制作、容器发布的功能。这个过程实际上就是持续集成、持续交付的过程，同时具有持续部署的能力。基本上，持续集成、持续交付、持续部署是一种服务能力，是云平台必须具备的能力。</p>
<p>下面引自 2017 年 DevOps 现状调查报告。</p>
<p>统计资料显示，DevOps 正在各个行业、各种规模的企业中落地。DevOps 团队的比例在 2014 年是 16%，在 2015 年是 19%，在 2016 年是 22%，在 2017 年已经增长到 27%，越来越多的企业和团队开始拥抱 DevOps。图 1-2 是 2017 年 DevOps 现状调查报告统计的从业分布情况。</p>
<p>完整的报告可以从 qcloudimg 网站下载。</p>
<p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/v2-b6711ac5c1f0729cf29b830bade2e49b_720w.jpg"></p>
<p>在本书撰写过程中 2018 年 DevOps 现状调查报告也已经出来，图 1-3 是精英级执行团队使用 DevOps 后的效率。精英级执行团队在以下几个方面有着突出的表现。</p>
<ul>
<li>代码发布频率高 46 倍。</li>
<li>代码从提交至发布的速度快 2555 倍。</li>
<li>故障变更率降低 1/7。</li>
<li>事故恢复时间快 2604 倍。</li>
</ul>
<p>另外，云计算持续增长（见图 1-4）。有 17%的调查者仍然没有使用云厂商的服务。AWS 最受欢迎，占比为 52%，Azure 屈居次席，占比为 34%。</p>
<p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/v2-26406fab0121c4640689dd0b59cb9c4b_720w.jpg"></p>
<h3 id="CI-amp-CD-技术栈"><a href="#CI-amp-CD-技术栈" class="headerlink" title="CI&amp;CD 技术栈"></a>CI&amp;CD 技术栈</h3><p>目前持续集成、持续交付、持续部署在开源社区都是热点，用户可以方便地利用这些开源组件来构建自己企业的持续集成、持续交付及持续部署平台。</p>
<p>持续集成工具中以 Jenkins 使用最为广泛，由 Jenkins 来作业化持续集成过程；利用 GitLab 来管理程序版本；利用 Gerrit 来做代码审核；利用 Sonar 进行代码质量扫描；利用 JUnit 进行单元测试；利用 Docker compose 来构建镜像；利用 Docker 来部署容器；利用 Kubernetes、Rancher 等进行服务编排。图 1-5 显示了常见的 CI&amp;CD 技术栈。</p>
<p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/v2-b71a61ad92b47b87bd7be277d4a99d11_720w.jpg"></p>
<p>后续讲解 CI&amp;CD 落地时会运用到其中的一些技术与工具。当然，基本上都运用开源工具，这也有助于企业在落地时节省费用。</p>
<h3 id="大规模部署的烦恼"><a href="#大规模部署的烦恼" class="headerlink" title="大规模部署的烦恼"></a>大规模部署的烦恼</h3><p>对于同样的功能，在用户量不同的系统中，工作量是完全不同的，后台为性能考虑而设计的架构完全不一样。对于 CI&amp;CD 也是如此，小规模的很容易，配几个作业就可以完成工作，但对于大规模的 CI&amp;CD，一旦系统数量、实例数量上去后各种问题就都来了。下面列举几个主要的问题。</p>
<ol>
<li><p>更新问题。更新一次要耗费大量精力，很多企业都是晚上更新，员工得通宵加班，还不能保证更新没问题，不具备快速大批量部署的能力。</p>
</li>
<li><p>部署包（jar 包、war 包、ear 包等）的管理问题。为了保证版本可追溯，出错后能够回滚，我们需要保存各个历史版本，而且方便下载。</p>
</li>
<li><p>版本的安全性。传统上以 Java 语言开发的系统多数以 jar 包、war 包、ear 包的方式发布，容易被篡改（人为修改，传输过程不完整）；通常我们用 md5 来验证完整性，但包与 md5 对应关系的管理并没有系统化，往往在出问题后人工进行 md5 验证。</p>
</li>
<li><p>主机管理问题。系统部署到哪些机器上需要进行主机管理？在部署时人工选择部署到哪台主机显然不是一种明智的方式，能否自动进行调度？同时，不会产生有些主机性能堪忧、有些主机空闲导致的负载不均情况。</p>
</li>
<li><p>端口管理问题，在部署 Java 项目时我们并不建议设置太多的 JVM 内存，因此一台主机上往往能够部署多个应用实例，同一台机器上多个实例的开放端口就必须不一致，于是端口又成了需要管理的资源。有人会说可以选用虚拟机，一台虚拟机上只部署一个实例。当然，这也是可以的。实际上，多数企业也是这么做的。这种做法也有弊端，虚拟机虽然帮助做了隔离，但会损失一些主机性能；虚拟机要使用内网 IP，这样 IP 又成了稀有资源，当部署多个实例时 IP 会不够用。</p>
</li>
<li><p>负载均衡管理问题。不管是在主机上部署多个实例，还是利用虚拟机来部署多个实例，在做集群时，都会通过代理（Nginx、Apache、LVS……）软件来做负载均衡，因此我们需要把各实例的访问地址配置到负载器的配置文件中。实例数少的时候手工配置还可以接受，多了就没法手工配置了。当然，方法也会有，比如用 Etcd+Confd+Nginx（HAProxy）来做服务发现，我们需要自己部署一套工具，并进行维护，复杂的框架提高了对运维人员的要求。</p>
</li>
<li><p>服务伸缩问题。当服务访问量上去后，要能够具备快速扩充的能力；当访问量下去后，要能够具备缩小服务规模的能力，收放自如。这种弹性的服务能力显然是通过工具来完成的，手动完成是不可能的。</p>
</li>
<li><p>IP 管理问题。当大规模部署后，IP 资源会成为稀有资源，如何用更少的 IP 来部署更多的服务？IP 的分配及管理显然不能人工完成，那样效率太过低下，这就需要一个 IP 管理工具。</p>
</li>
</ol>
<p>如果有一个系统能够一站式解决以上问题，那真是太完美了。因为没有这样的系统，所以很多公司开发了他们的运维平台，专门用来解决大规模部署问题。但对于中小公司来说，技术与人力投入往往受限，没有这个能力、精力或者财力去建立一个智能的运维平台。但是我们可以利用开源工具、开源技术来搭建一个相对完善的持续集成、持续部署体系。</p>
<h3 id="实施云平台化"><a href="#实施云平台化" class="headerlink" title="实施云平台化"></a>实施云平台化</h3><p>虚拟化、云平台化为大规模部署提供了方便，尤其是在硬件资源管理及网络管理方面。互联网的火热更是推动了云的快速发展，基本上各大互联网企业都已经完成了云平台化，生产力也在不断提升。以 Docker 为代表的容器化技术出现后，云变得更灵活，容器化已经成为大潮，Docker 也占据了容器市场的绝对份额。容器部署方式能够满足快速大批量部署的要求，充分利用物理机器资源。以 Docker 为例，Docker 容器技术让应用一次构建，到处（物理机、虚拟机、公有云、私有云、Windows 系统、Linux 系统等）可运行，加快了本地开发和构建，实现了快速交付和部署；同时还可以在操作系统层面提供资源隔离服务。</p>
<p>为了提高服务水平，企业服务需要能够快速水平扩展，在系统设计层面也大举采用 SOA 框架，这种框架天生适合使用容器大规模部署。当然，也存在一些问题，比如管理大量的服务实例成为一个挑战，运维、监控、问题分析等变得复杂。那么如何管理这些容器呢？于是就产生了大量的容器管理工具，支持 Docker 容器管理的工具使用得比较广的有 Swarm、Mesos、Kubernetes、Rancher 等工具。这些工具能够帮我们方便管理容器，虽然有一些问题的解决方式并不完美，但这也给运维开发、测试开发提供了更多的想象空间与工作机会。目前容器管理工具 Kubernetes 影响最大，但 Kubernetes 的学习与运维成本相对较高，需要专业人士的支持。目前国内大型互联网公司基本都基于 Kubernetes 来管理大量容器，包括 BAT、京东等企业。腾讯的蓝鲸（DevOps）也基于 Kubernetes，已经开始市场化；淘宝的云效也是与蓝鲸同类型的产品。</p>
<p>对于中小型企业来说，上 Kubernetes 显得有点操之过急，需要有技术储备与维护团队，学习成本相对也会高一点，因此应该选择简单的、快速能够落地的、能够满足企业要求的、有一定市场的工具。当然，最好还是开源的，社区也支持的。所以我们选择 Rancher，据说早期云效也是整合 Rancher 的，作者也在基于 Rancher 做整合，利用 Rancher 实现容器的管理，利用 Jenkins 构建，利用 GitLab 实现源码管理，再加上静态扫描、自动化测试、性能测试、日志管理等功能，整合成 DevOps，足够运行、管理上千个实例级别的容器实例。实际上，拥有 DevOps 并且已经容器化，就相当于已经拥有一个相对智能化的私有云平台（不是真正意义上的云，并没有对物理资源进行管理，抽象成服务）。图 1-6 是作者早期开发的 DevOps 静态架构。</p>
<p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/v2-d0bd916daf8680bb7b549a67dfc6752f_720w.jpg"></p>
<p>此平台类似于一个私有云平台，基本涵盖了系统的生命周期：编译、打包、发布、测试、上线、运维、下线。同时把硬件资源管理起来，这些硬件对用户透明。平台主要分 3 层。</p>
<ul>
<li>基础组件层，提供了存储、网络与运算功能。对于上层来说，硬件只是一个服务而已。</li>
<li>服务组件层，提供了运维与监控功能。对于大规模系统营运来说，系统监控、问题诊断分析变得复杂，必须在系统层面给予帮助，结合平台能力，让用户分析问题变得简单。那种从服务器上看日志的老旧方式一去不复返了。</li>
<li>DevOps 用户层，直接面向运维人员，做到持续集成、持续交付、持续部署，在平台中完成各种测试。支持多种形式的发布，减少上线风险。</li>
</ul>
<p>图 1-7 是上述平台用到的技术栈。下面对用到的部分工具进行简单说明。</p>
<p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/v2-04844cd0f7bc996f21043a601acfb1f1_720w.jpg"></p>
<ul>
<li>Rancher：一个开源的企业级容器管理平台。通过 Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher 提供了在生产环境中使用的管理 Docker 和 Kubernetes 的全栈化容器部署与管理平台。</li>
<li>Jenkins：用于构建管理，定义管理工作过程。</li>
<li>Docker compose：一种定义编排容器的工具，以 YAML 或者 XML 的格式展示编排内容。</li>
<li>Maven：源码编译工具。</li>
<li>GitLab：源码管理工具。</li>
<li>Gerrit：代码审核工具。</li>
<li>Sonar：代码静态扫描工具。</li>
<li>robot：自动化测试工具。</li>
<li>Ceph：分布式存储产品。</li>
<li>Spring Boot：DevOps 集成开发技术框架。</li>
<li>React：门户开发框架。</li>
<li>Redux：门户开发框架。</li>
<li>MySQL：数据库。</li>
<li>MyBatis：ORM 框架。</li>
<li>Kibana、Logstash、Elastic：用于统一进行日志管理、日志存储、日志分析。</li>
</ul>
<p>本书讲到的 CI&amp;CD 刚好是这个 DevOps 的一个子集，我们将围绕上述架构及技术栈展开，</p>
<p>本书不仅讲解如何实现，还会结合实例展示如何落地。这些对于大多数中小型企业来说已经足够支撑业务。企业给 CI&amp;CD 加上 Web 版本的门户、集中的账户管理体系以及运维监控体系，即可打造一个智能的 DevOps 平台。</p>
<p>图 1-8 是 CI&amp;CD 流程，后面的实例也将围绕这个流程。</p>
<p><img data-src="https://liangx-gallery.oss-cn-beijing.aliyuncs.com/v2-ce251210246218a21194dba51d686f82_720w.jpg"></p>
<p>下面先简单介绍该流程。</p>
<ol>
<li>程序员提交代码。</li>
<li>Gerrit 做代码审核，通过提交到 GitLab，能通过邮件通知相关人员。</li>
<li>Sonar 做代码静态扫描，并把结果通知相关人员。</li>
<li>在 GitLab 中贴标签（通过 WebHook 触发 Jenkins 作业）或者手动在 Jenkins 中触发作业，Maven 开始下拉代码进行编译，然后进行单元测试和打包。</li>
<li>打包完成后利用 Docker cli 构建镜像。</li>
<li>把镜像上传到镜像仓库中。</li>
<li>Jenkins 作业触发 Rancher 在测试环境中启动容器，首先下拉镜像，然后根据配置启动容器。</li>
<li>Rancher 自动或者按规则调度容器在哪台机器上运行。</li>
<li>Rancher 负责容器生命周期管理（启动、监控、健康检查、扩展等）。</li>
<li>进行自动化测试。</li>
<li>测试通过后，Jenkins 触发 Rancher 在生产环境中启动或者更新测试通过的服务，当然，也可以手动在 Rancher 中进行发布，当实例增加时只需要填写实例数量即可快速扩展，在发布时可以支持灰度发布、蓝绿发布等个性化的发布需求。</li>
</ol>
<p>注意：</p>
<ol>
<li><p>我们一直不加上云平台这个名称，是因为云平台的定义太广，我们并没有产品接入功能，比如提供数据存储服务、缓存服务，以及提供大数据运算能力。</p>
</li>
<li><p>当然，我们也具备云要提供的很多服务，所以在把下面要讲的一套东西落地后，也可以冠以云平台之名，其他的功能可以慢慢补上来。“欲立新功，行之有名；立人之先，憨享其成。”</p>
</li>
</ol>
<p>由于要用的工具比较多，这些工具多由外国人开发，译过来叫法比较多，因此为了方便讲述，下面介绍术语。</p>
<ul>
<li>服务：完成某一功能的程序。</li>
<li>服务实例：程序部署单元，比如一个订单程序由 Tomcat 启动，一个这样的部署单元（一个 JVM 实例）称为一个服务实例。</li>
<li>容器：如 Docker 容器。</li>
<li>容器实例：镜像的运行态叫容器实例，如果运行一个 Nginx 镜像，那么这就是一个容器实例，我们利用镜像运行两个 Nginx，那么实例数为 2；这些实例称为容器实例，一定语境下直接称为实例。</li>
</ul>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章简单叙述了进行 CI&amp;CD 的价值，以及通过 CI&amp;CD 的实施能够帮我们解决什么问题。结合当前的 CI&amp;CD 技术栈，我们知道要朝哪个方向去发力建立自己的私有云平台。利用当前的开源技术实现 CI&amp;CD，运行自己的私有云平台，加速企业的系统集成效率，缩短部署时间，提高成功率。</p>
]]></content>
      <categories>
        <category>工程体系</category>
      </categories>
      <tags>
        <tag>工程体系</tag>
        <tag>持续集成与部署</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度概念</title>
    <url>/2020/10/28/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>先简要介绍一下</p>
<p>算法复杂度分为时间复杂度和空间复杂度，时间复杂度是指执行这个算法所需要的计算工作量，空间复杂度是指执行这个算法所需的内存空间</p>
<p>时间和空间都是计算机资源的重要体现，而算法的复杂性就是体现在该算法执行时计算机所需的资源多少</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上很好的反映出算法的优劣与否</p>
<p>算法的执行时间需要依据该算法编制的程序在计算机上执行运行所消耗的时间来度量，度量方法有两种，事后统计方法和事前分析估算方法，因为事后统计法更多的依赖计算机的硬件，软件等环境因素，有时容易掩盖算法本身的优劣，因此常常采用事后分析估算法</p>
<p>一个算法由控制结构（顺序，分支，循环）和原操作（固有数据类型的操作）构成，而算法时间取决于两种的综合效率</p>
<p>一个算法花费的时间与算法中语句的执行次数成正比，执行次数越多，花费的时间就越多，一个算法中的执行次数称为语句频度或时间频度，记为 T(n);</p>
<p>在各种算法中，若算法中的语句执行次数为一个常数，则时间复杂度为 O(1), 同时若不同算法的时间频度不一样，但它们的时间复杂度可能时一样的<code>T(n)=n^2+2n+4 </code>与 <code>T（n）=4n^2+n+8</code> 它们的时间频度显然不一样，但他们的时间复杂度确是一样的，均为 O(n^2) 时间复杂度只关注最高数量级，且与之系数也没有关系，</p>
<p>求解算法的时间复杂度的具体步骤是：</p>
<ol>
<li><p>找出算法中的基本语句；</p>
<p>算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体</p>
</li>
<li><p>计算基本语句的执行次数的数量级</p>
<p>只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂，这样就能够简化算法分析，并且使注意力集中在最重要的一点上，增长率</p>
</li>
<li><p>用大 O 记号表示算法的时间性能</p>
<p>将基本语句执行的数量放入大 O 记号中，如果算法中包含嵌套的循环，则基本语句通常使最内层的循环体，如果算法中包含并列循环，则将并列循环的时间复杂度相加</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">    a++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个 for 循环的时间复杂度为 O(n)，第二个 for 循环时间复杂度为 O(n^2)，则整个算法的时间复杂度为 O(n^2+n)。</p>
<p>O(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，时间复杂度就为 O(1)。</p>
<hr>
<p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，比如排序就有前面的十大经典排序和几种奇葩排序，虽然结果相同，但在过程中消耗的资源和时间却会有很大的区别，比如快速排序与猴子排序：）。</p>
<p>那么我们应该如何去衡量不同算法之间的优劣呢？</p>
<p>主要还是从算法所占用的「时间」和「空间」两个维度去考量。</p>
<ul>
<li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li>
<li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li>
</ul>
<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="大-O-符号表示法"><a href="#大-O-符号表示法" class="headerlink" title="大 O 符号表示法"></a>大 O 符号表示法</h3><p>大 O 表示法：算法的时间复杂度通常用大 O 符号表述，定义为 **T[n] = O(f(n)) **。称函数 T(n)以 f(n)为界或者称 T(n)受限于 f(n)。</p>
<p>如果一个问题的规模是 n，解这一问题的某一算法所需要的时间为 T(n)。T(n)称为这一算法的“时间复杂度”。</p>
<blockquote>
<p>上面公式中用到的 Landau 符号是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其 1892 年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。Landau 符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界。在计算算法复杂度时一般只用到大 O 符号，Landau 符号体系中的小 o 符号、Θ 符号等等比较不常用。这里的 O，最初是用大写希腊字母，但现在都用大写英语字母 O；小 o 符号也是用小写英语字母 o，Θ 符号则维持大写希腊字母 Θ。</p>
</blockquote>
<p>大 O 符号是一种算法「复杂度」的「相对」「表示」方式。</p>
<p>这个句子里有一些重要而严谨的用词：</p>
<ul>
<li>相对(relative)：你只能比较相同的事物。你不能把一个做算数乘法的算法和排序整数列表的算法进行比较。但是，比较 2 个算法所做的算术操作（一个做乘法，一个做加法）将会告诉你一些有意义的东西；</li>
<li>表示(representation)：大 O(用它最简单的形式)把算法间的比较简化为了一个单一变量。这个变量的选择基于观察或假设。例如，排序算法之间的对比通常是基于比较操作(比较 2 个结点来决定这 2 个结点的相对顺序)。这里面就假设了比较操作的计算开销很大。但是，如果比较操作的计算开销不大，而交换操作的计算开销很大，又会怎么样呢？这就改变了先前的比较方式；</li>
<li>复杂度(complexity)：如果排序 10,000 个元素花费了我 1 秒，那么排序 1 百万个元素会花多少时间？在这个例子里，复杂度就是相对其他东西的度量结果。</li>
</ul>
<h3 id="常见的时间复杂度量级"><a href="#常见的时间复杂度量级" class="headerlink" title="常见的时间复杂度量级"></a>常见的时间复杂度量级</h3><p>我们先从常见的时间复杂度量级进行大 O 的理解：</p>
<ul>
<li>常数阶 O(1)</li>
<li>线性阶 O(n)</li>
<li>平方阶 O(n²)</li>
<li>对数阶 O(logn)</li>
<li>线性对数阶 O(nlogn)</li>
</ul>
<p><img data-src="https://mmbiz.qpic.cn/mmbiz_jpg/D67peceibeITdVEicwQ7T05FPwkggMR2IiaRc88PpnacPKl4xapFBz28QSu6HyGU2zpYCiaayiaKia2T2cZzEicYyXAJw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h4><p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeITdVEicwQ7T05FPwkggMR2IiaC8GtCYhYHhkZgbwSiaBvctaIZ9nZIurQMaQZyeyKKAnEh1fJ6p4vmtw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>无论代码执行了多少行，其他区域不会影响到操作，这个代码的时间复杂度都是 O(1)</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>void swapTwoInts(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)&#123;</span><br><span class="line"><span class="symbol">2 </span> <span class="keyword">int</span> temp = a;</span><br><span class="line"><span class="symbol">3 </span> a = b;</span><br><span class="line"><span class="symbol">4 </span> b = temp;</span><br><span class="line"><span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h4><p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeITdVEicwQ7T05FPwkggMR2IiawGKfic7qoiaxGt1wmZjDwlJksMAN2nvsMplZNbsa0DxKFKx1Gzo02HaA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>在下面这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此可以用 O(n)来表示它的时间复杂度。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="keyword">int</span> sum ( <span class="keyword">int</span> n )&#123;</span><br><span class="line"><span class="symbol">2 </span>  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="symbol">3 </span>  <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i ++)&#123;</span><br><span class="line"><span class="symbol">4 </span>     ret += i;</span><br><span class="line"><span class="symbol">5 </span>  &#125;</span><br><span class="line"><span class="symbol">6 </span>  <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>

<p>特别一提的是 c * O(n) 中的 c 可能小于 1 ，比如下面这段代码：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>void reverse ( string &amp;s ) &#123;</span><br><span class="line"><span class="symbol">2 </span>   <span class="keyword">int</span> n = s.size();</span><br><span class="line"><span class="symbol">3 </span>   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n/<span class="number">2</span> ; i++)&#123;</span><br><span class="line"><span class="symbol">4 </span>     <span class="keyword">swap</span> ( s[i] , s[n-<span class="number">1</span>-i]);</span><br><span class="line"><span class="symbol">5 </span>   &#125;</span><br><span class="line"><span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="O-n²"><a href="#O-n²" class="headerlink" title="O(n²)"></a>O(n²)</h4><p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeITdVEicwQ7T05FPwkggMR2IiagPTZBricA32aLO0SKJwBxg9ADp81gE4micOalibyciahExK3AP5woZzmsw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>当存在双重循环的时候，即把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>void selectionSort(<span class="built_in">int</span> arr[],<span class="built_in">int</span> n)&#123;</span><br><span class="line"> <span class="number">2</span>   <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line"> <span class="number">3</span>     <span class="built_in">int</span> minIndex = i;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; n ; j++ )</span><br><span class="line"> <span class="number">5</span>       <span class="keyword">if</span> (arr[j] &lt; arr[minIndex])</span><br><span class="line"> <span class="number">6</span>           minIndex = j;</span><br><span class="line"> <span class="number">7</span></span><br><span class="line"> <span class="number">8</span>     swap ( arr[i], arr[minIndex]);</span><br><span class="line"> <span class="number">9</span>   &#125;</span><br><span class="line"><span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单的推导一下</p>
<ul>
<li>当 i = 0 时，第二重循环需要运行 (n - 1) 次</li>
<li>当 i = 1 时，第二重循环需要运行 (n - 2) 次</li>
<li>。。。。。。</li>
</ul>
<p>不难得到公式：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>(n - <span class="number">1</span>) + (n - <span class="number">2</span>) + (n - <span class="number">3</span>) + ... + <span class="number">0</span></span><br><span class="line"><span class="number">2</span>= (<span class="number">0</span> + n - <span class="number">1</span>) * n / <span class="number">2</span></span><br><span class="line"><span class="number">3</span>= O (n ^<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>当然并不是所有的双重循环都是 O(n²)，比如下面这段输出 30n 次 <code>Hello,五分钟学算法：）</code>的代码。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>void printInformation (<span class="keyword">int</span> n )&#123;</span><br><span class="line"><span class="symbol">2 </span>  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line"><span class="symbol">3 </span>       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">30</span> ; j ++)</span><br><span class="line"><span class="symbol">4 </span>          cout&lt;&lt; <span class="string">&quot;Hello,五分钟学算法：）&quot;</span>&lt;&lt; endl;</span><br><span class="line"><span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="O-logn"><a href="#O-logn" class="headerlink" title="O(logn)"></a>O(logn)</h4><p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeITdVEicwQ7T05FPwkggMR2IiawzlTM2VDrvCp8No2l1hRoyYcB5wxMZzdSPicp4GmL80fCm0o9on1ibZQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>int binarySearch( <span class="built_in">int</span> arr[], <span class="built_in">int</span> n , <span class="built_in">int</span> target)&#123;</span><br><span class="line"> <span class="number">2</span>  <span class="built_in">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"> <span class="number">3</span>  <span class="keyword">while</span> ( l &lt;= r) &#123;</span><br><span class="line"> <span class="number">4</span>    <span class="built_in">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"> <span class="number">5</span>    <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line"> <span class="number">6</span>    <span class="keyword">if</span> (arr[mid] &gt; target ) r = mid - <span class="number">1</span>;</span><br><span class="line"> <span class="number">7</span>    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line"> <span class="number">8</span>  &#125;</span><br><span class="line"> <span class="number">9</span>  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在二分查找法的代码中，通过 while 循环，成 2 倍数的缩减搜索范围，也就是说需要经过 log2^n 次即可跳出循环。</p>
<p>同样的还有下面两段代码也是 O(logn) 级别的时间复杂度。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>  <span class="comment">// 整形转成字符串</span></span><br><span class="line"> <span class="number">2</span>  <span class="built_in">string</span> <span class="built_in">int</span>ToString ( <span class="built_in">int</span> num )&#123;</span><br><span class="line"> <span class="number">3</span>   <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> <span class="number">4</span>   <span class="comment">// n 经过几次“除以10”的操作后，等于0</span></span><br><span class="line"> <span class="number">5</span>   <span class="keyword">while</span> (num )&#123;</span><br><span class="line"> <span class="number">6</span>    s += <span class="string">&#x27;0&#x27;</span> + num%<span class="number">10</span>;</span><br><span class="line"> <span class="number">7</span>    num /= <span class="number">10</span>;</span><br><span class="line"> <span class="number">8</span>   &#125;</span><br><span class="line"> <span class="number">9</span>   reverse(s)</span><br><span class="line"><span class="number">10</span>   <span class="keyword">return</span> s;</span><br><span class="line"><span class="number">11</span>  &#125;</span><br><span class="line"><span class="number">1</span>void hello (<span class="built_in">int</span> n ) &#123;</span><br><span class="line"><span class="number">2</span>   <span class="comment">// n 除以几次 2 到 1</span></span><br><span class="line"><span class="number">3</span>   <span class="keyword">for</span> ( <span class="built_in">int</span> sz = <span class="number">1</span>; sz &lt; n ; sz += sz)</span><br><span class="line"><span class="number">4</span>     <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line"><span class="number">5</span>        cout&lt;&lt; <span class="string">&quot;Hello,五分钟学算法：）&quot;</span>&lt;&lt; endl;</span><br><span class="line"><span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h4><p>将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了 O(nlogn)。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>void hello ()&#123;</span><br><span class="line"><span class="symbol">2 </span> <span class="keyword">for</span>( m = <span class="number">1</span> ; m &lt; n ; m++)&#123;</span><br><span class="line"><span class="symbol">3 </span>   i = <span class="number">1</span>;</span><br><span class="line"><span class="symbol">4 </span>   <span class="keyword">while</span>( i &lt; n )&#123;</span><br><span class="line"><span class="symbol">5 </span>       i = i * <span class="number">2</span>;</span><br><span class="line"><span class="symbol">6 </span>   &#125;</span><br><span class="line"><span class="symbol">7 </span>  &#125;</span><br><span class="line"><span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不常见的时间复杂度"><a href="#不常见的时间复杂度" class="headerlink" title="不常见的时间复杂度"></a>不常见的时间复杂度</h3><p>下面来分析一波另外几种复杂度： 递归算法的时间复杂度（recursive algorithm time complexity），最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均时间复杂度（average case time complexity）和均摊时间复杂度（amortized time complexity）。</p>
<h4 id="递归算法的时间复杂度"><a href="#递归算法的时间复杂度" class="headerlink" title="递归算法的时间复杂度"></a>递归算法的时间复杂度</h4><p>如果递归函数中，只进行一次递归调用，递归深度为 depth；</p>
<p>在每个递归的函数中，时间复杂度为 T；</p>
<p>*<em>则总体的时间复杂度为 O(T \</em> depth)**。</p>
<p>在前面的学习中，归并排序 与 快速排序 都带有递归的思想，并且时间复杂度都是 O(nlogn) ，但并不是有递归的函数就一定是 O(nlogn) 级别的。从以下两种情况进行分析。</p>
<h5 id="①-递归中进行一次递归调用的复杂度分析"><a href="#①-递归中进行一次递归调用的复杂度分析" class="headerlink" title="① 递归中进行一次递归调用的复杂度分析"></a>① 递归中进行一次递归调用的复杂度分析</h5><h6 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h6><p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeITdVEicwQ7T05FPwkggMR2IiawzlTM2VDrvCp8No2l1hRoyYcB5wxMZzdSPicp4GmL80fCm0o9on1ibZQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>int binarySearch(<span class="built_in">int</span> arr[], <span class="built_in">int</span> l, <span class="built_in">int</span> r, <span class="built_in">int</span> target)&#123;</span><br><span class="line"> <span class="number">2</span>    <span class="keyword">if</span>( l &gt; r ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> <span class="number">3</span></span><br><span class="line"> <span class="number">4</span>    <span class="built_in">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line"> <span class="number">5</span>    <span class="keyword">if</span>( arr[mid] == target ) <span class="keyword">return</span> mid;</span><br><span class="line"> <span class="number">6</span>    <span class="keyword">else</span> <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line"> <span class="number">7</span>    <span class="keyword">return</span> binarySearch(arr, l, mid<span class="number">-1</span>, target);    <span class="comment">// 左边</span></span><br><span class="line"> <span class="number">8</span>    <span class="keyword">else</span></span><br><span class="line"> <span class="number">9</span>    <span class="keyword">return</span> binarySearch(arr, mid+<span class="number">1</span>, r, target);   <span class="comment">// 右边</span></span><br><span class="line"><span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>

<p>比如在这段二分查找法的代码中，每次在 [ l , r ] 范围中去查找目标的位置，如果中间的元素 <code>arr[mid]</code> 不是 <code>target</code>，那么判断 <code>arr[mid]</code>是比 <code>target</code> 大 还是 小 ，进而再次调用 <code>binarySearch</code>这个函数。</p>
<p>在这个递归函数中，每一次没有找到<code>target</code>时，要么调用 左边 的 <code>binarySearch</code>函数，要么调用 右边 的 <code>binarySearch</code>函数。也就是说在此次递归中，最多调用了一次递归调用而已。根据数学知识，需要 log2n 次才能递归到底。因此，二分查找法的时间复杂度为 O(logn)。</p>
<h6 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h6><p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeITdVEicwQ7T05FPwkggMR2IiaS8P0IxiarxvqcTwqc0SHBOzmnyGvQkXE8pticX5DDicu68ILLcopaSnvw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="keyword">int</span> sum (<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="symbol">2 </span> <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="symbol">3 </span> <span class="keyword">return</span> n + sum( n - <span class="number">1</span> )</span><br><span class="line"><span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中比较容易理解递归深度随输入 n 的增加而线性递增，因此时间复杂度为 O (n)。</p>
<h6 id="求幂"><a href="#求幂" class="headerlink" title="求幂"></a>求幂</h6><p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeITdVEicwQ7T05FPwkggMR2Iiap3NSVdYcYMicDw1PpsuxY8qQacHM8cIMOt3oBya9UHFrmWypASsyXkA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>//递归深度：logn</span><br><span class="line"><span class="number">2</span>//时间复杂度：O(logn)</span><br><span class="line"><span class="number">3d</span>ouble pow( double x, <span class="keyword">int</span> n)&#123;</span><br><span class="line"><span class="symbol">4 </span> <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">6 </span> double t = pow(x,n/<span class="number">2</span>);</span><br><span class="line"><span class="symbol">7 </span> <span class="keyword">if</span> (n %<span class="number">2</span>) <span class="keyword">return</span> x*t*t;</span><br><span class="line"><span class="symbol">8 </span> <span class="keyword">return</span> t * t;</span><br><span class="line"><span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<p>递归深度为 <code>logn</code>，因为是求需要除以 2 多少次才能到底。</p>
<h5 id="②-递归中进行多次递归调用的复杂度分析"><a href="#②-递归中进行多次递归调用的复杂度分析" class="headerlink" title="② 递归中进行多次递归调用的复杂度分析"></a>② 递归中进行多次递归调用的复杂度分析</h5><p>递归算法中比较难计算的是多次递归调用。</p>
<p>先看下面这段代码，有两次递归调用。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>// O(<span class="number">2</span>^n) 指数级别的数量级，后续动态规划的优化点</span><br><span class="line"><span class="number">2</span><span class="keyword">int</span> f(<span class="keyword">int</span> n)&#123;</span><br><span class="line"><span class="symbol">3 </span><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="symbol">4 </span><span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n - <span class="number">1</span>);</span><br><span class="line"><span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeITdVEicwQ7T05FPwkggMR2Iia9S7ev0pwvhCLF5PbyWHVTXrDoJQ79xdSmf1H96AQo6l0A3ttnbaSVQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>递归树中节点数就是代码计算的调用次数。</p>
<p>比如 当 <code>n = 3</code> 时，调用次数计算公式为</p>
<blockquote>
<p>1 + 2 + 4 + 8 = 15</p>
</blockquote>
<p>一般的，调用次数计算公式为</p>
<blockquote>
<p>2^0 + 2^1 + 2^2 + …… + 2^n = 2^(n+1) - 1 = O(2^n)</p>
</blockquote>
<p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeITdVEicwQ7T05FPwkggMR2Iia7WpvIv6ibiaQibGibtSO0BvQyGSssye1sT7RmPOCsXB4e3xQPaicNbibJibqA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>与之有所类似的是 归并排序 的递归树，区别点在于</p>
<ul>
<li>\1. 上述例子中树的深度为 <code>n</code>，而 归并排序 的递归树深度为<code>logn</code>。</li>
<li>\2. 上述例子中每次处理的数据规模是一样的，而在 归并排序 中每个节点处理的数据规模是逐渐缩小的</li>
</ul>
<p>因此，在如 归并排序 等排序算法中，每一层处理的数据量为 O(n) 级别，同时有 <code>logn</code> 层，时间复杂度便是 O(nlogn)。</p>
<h4 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h4><p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeITdVEicwQ7T05FPwkggMR2IiaocwzriaeqkOJQsorsR5Q0jqxRY9GhRbC7MYiaDKyAstD7v6plsHuHPPw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<p>最好、最坏情况时间复杂度指的是特殊情况下的时间复杂度。</p>
<p>动图表明的是在数组 array 中寻找变量 x 第一次出现的位置，若没有找到，则返回 -1；否则返回位置下标。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="keyword">int</span> find(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> x) &#123;</span><br><span class="line"><span class="symbol">2 </span> <span class="keyword">for</span> (  <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line"><span class="symbol">3 </span>   <span class="keyword">if</span> (array[i] == x) &#123;</span><br><span class="line"><span class="symbol">4 </span>       <span class="keyword">return</span> i;</span><br><span class="line"><span class="symbol">5 </span>       break;</span><br><span class="line"><span class="symbol">6 </span>   &#125;</span><br><span class="line"><span class="symbol">7 </span> &#125;</span><br><span class="line"><span class="symbol">8 </span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在这里当数组中第一个元素就是要找的 x 时，时间复杂度是 O(1)；而当最后一个元素才是 x 时，时间复杂度则是 O(n)。</p>
<p>最好情况时间复杂度就是在最理想情况下执行代码的时间复杂度，它的时间是最短的；最坏情况时间复杂度就是在最糟糕情况下执行代码的时间复杂度，它的时间是最长的。</p>
<h4 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h4><p>最好、最坏时间复杂度反应的是极端条件下的复杂度，发生的概率不大，不能代表平均水平。那么为了更好的表示平均情况下的算法复杂度，就需要引入平均时间复杂度。</p>
<p>平均情况时间复杂度可用代码在所有可能情况下执行次数的加权平均值表示。</p>
<p>还是以 <code>find</code> 函数为例，从概率的角度看， x 在数组中每一个位置的可能性是相同的，为 1 / n。那么，那么平均情况时间复杂度就可以用下面的方式计算：</p>
<blockquote>
<p>((1 + 2 + … + n) / n + n) / 2 = (3n + 1) / 4</p>
</blockquote>
<p><code>find</code> 函数的平均时间复杂度为 O(n)。</p>
<h4 id="均摊复杂度分析"><a href="#均摊复杂度分析" class="headerlink" title="均摊复杂度分析"></a>均摊复杂度分析</h4><p>我们通过一个动态数组的 <code>push_back</code> 操作来理解 <strong>均摊复杂度</strong>。</p>
<p><img data-src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeITdVEicwQ7T05FPwkggMR2Iia0cnwqHXWTLZQO4dNl7hgE2g4iaibhJTqmRN12wTHFJiav5grgVCEyYNtw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>template &lt;typename T&gt;</span><br><span class="line"> <span class="number">2</span>class MyVector&#123;</span><br><span class="line"> <span class="number">3</span><span class="keyword">private</span>:</span><br><span class="line"> <span class="number">4</span>    T* data;</span><br><span class="line"> <span class="number">5</span>    <span class="built_in">int</span> size;       <span class="comment">// 存储数组中的元素个数</span></span><br><span class="line"> <span class="number">6</span>    <span class="built_in">int</span> capacity;   <span class="comment">// 存储数组中可以容纳的最大的元素个数</span></span><br><span class="line"> <span class="number">7</span>    <span class="comment">// 复杂度为 O(n)</span></span><br><span class="line"> <span class="number">8</span>    <span class="built_in">void</span> resize(<span class="built_in">int</span> newCapacity)&#123;</span><br><span class="line"> <span class="number">9</span>        T *newData = new T[newCapacity];</span><br><span class="line"><span class="number">10</span>        <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++ )&#123;</span><br><span class="line"><span class="number">11</span>              newData[i] = data[i];</span><br><span class="line"><span class="number">12</span>            &#125;</span><br><span class="line"><span class="number">13</span>        data = newData;</span><br><span class="line"><span class="number">14</span>        capacity = newCapacity;</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line"><span class="number">16</span><span class="keyword">public</span>:</span><br><span class="line"><span class="number">17</span>    MyVector()&#123;</span><br><span class="line"><span class="number">18</span>        data = new T[<span class="number">100</span>];</span><br><span class="line"><span class="number">19</span>        size = <span class="number">0</span>;</span><br><span class="line"><span class="number">20</span>        capacity = <span class="number">100</span>;</span><br><span class="line"><span class="number">21</span>    &#125;</span><br><span class="line"><span class="number">22</span>    <span class="comment">// 平均复杂度为 O(1)</span></span><br><span class="line"><span class="number">23</span>    <span class="built_in">void</span> push_back(T e)&#123;</span><br><span class="line"><span class="number">24</span>        <span class="keyword">if</span>(size == capacity)</span><br><span class="line"><span class="number">25</span>            resize(<span class="number">2</span> * capacity);</span><br><span class="line"><span class="number">26</span>        data[size++] = e;</span><br><span class="line"><span class="number">27</span>    &#125;</span><br><span class="line"><span class="number">28</span>    <span class="comment">// 平均复杂度为 O(1)</span></span><br><span class="line"><span class="number">29</span>    T pop_back()&#123;</span><br><span class="line"><span class="number">30</span>        size --;</span><br><span class="line"><span class="number">31</span>        <span class="keyword">return</span> data[size];</span><br><span class="line"><span class="number">32</span>    &#125;</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">34</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><code>push_back</code>实现的功能是往数组的末尾增加一个元素，如果数组没有满，直接往后面插入元素；如果数组满了，即 <code>size == capacity</code> ，则将数组扩容一倍，然后再插入元素。</p>
<p>例如，数组长度为 n，则前 n 次调用 <code>push_back</code> 复杂度都为 O(1) 级别；在第 n + 1 次则需要先进行 n 次元素转移操作，然后再进行 1 次插入操作，复杂度为 O(n)。</p>
<p>因此，平均来看：对于容量为 n 的动态数组，前面添加元素需要消耗了 1 _ n 的时间，扩容操作消耗 n 时间 ，总共就是 2 _ n 的时间，因此均摊时间复杂度为 O(2n / n) = O(2)，也就是 O(1) 级别了。</p>
<p>可以得出一个比较有意思的结论：一个相对比较耗时的操作，如果能保证它不会每次都被触发，那么这个相对比较耗时的操作，它所相应的时间是可以分摊到其它的操作中来的。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分：</p>
<p>(1) 固定部分，这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。</p>
<p>(2) 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。</p>
<p>一个算法所需的存储空间用 f(n)表示。S(n)=O(f(n))，其中 n 为问题的规模，S(n)表示空间复杂度。</p>
<p><strong>空间复杂度可以理解为除了原始序列大小的内存，在算法过程中用到的额外的存储空间。</strong></p>
<p>以二叉查找树为例，举例说明二叉排序树的查找性能。</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>如果二叉树的是以红黑树等平衡二叉树实现的，则 n 个节点的二叉排序树的高度为 log2n+1 ，其查找效率为 O(Log2n)，近似于折半查找。</p>
<p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/D67peceibeITdVEicwQ7T05FPwkggMR2IiaepCia27n7uxlH4ZuxKZTe7L6HypIkFLYHfoJ7xEBicoztf6nmeV43uhw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="列表二叉树"><a href="#列表二叉树" class="headerlink" title="列表二叉树"></a>列表二叉树</h3><p>如果二叉树退变为列表了，则 n 个节点的高度或者说是长度变为了 n，查找效率为 O(n)，变成了顺序查找。</p>
<p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/D67peceibeITdVEicwQ7T05FPwkggMR2Iia4hZdT7n7GAkmzCDNL9fweZm4RnRV8Or4cOmW1j1sqS1eeqvaecyW4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="一般二叉树"><a href="#一般二叉树" class="headerlink" title="一般二叉树"></a>一般二叉树</h3><p>介于「列表二叉树」与「平衡二叉树」之间，查找性能也在 O(Log2n)到 O(n)之间。</p>
<h2 id="冰火交融"><a href="#冰火交融" class="headerlink" title="冰火交融"></a>冰火交融</h2><p>对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。</p>
<p>比如说，要判断某某年是不是闰年：</p>
<ul>
<li>\1. 可以编写一个算法来计算，这也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。</li>
<li>\2. 还有另一个办法就是，事先建立一个有 5555 个元素的数组（年数比现实多就行），然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是 1，如果不是值为 0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这 5555 个 0 和 1 。</li>
</ul>
<p>这就是典型的使用空间换时间的概念。</p>
<p>当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；<br>反之，求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。</p>
<p>另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>模块</title>
    <url>/2020/09/20/%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>从 ECMAScript 2015 开始，JavaScript 引入了模块的概念。TypeScript 也沿用这个概念。</p>
<p>模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用<a href="https://www.tslang.cn/docs/handbook/modules.html#export"><code>export</code>形式</a>之一导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 <a href="https://www.tslang.cn/docs/handbook/modules.html#import"><code>import</code>形式</a>之一。</p>
<p>模块是自声明的；两个模块之间的关系是通过在文件级别上使用 imports 和 exports 建立的。</p>
<p>模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 大家最熟知的 JavaScript 模块加载器是服务于 Node.js 的 <a href="https://en.wikipedia.org/wiki/CommonJS">CommonJS</a>和服务于 Web 应用的<a href="http://requirejs.org/">Require.js</a>。</p>
<p>TypeScript 与 ECMAScript 2015 一样，任何包含顶级<code>import</code>或者<code>export</code>的文件都被当成一个模块。相反地，如果一个文件不带有顶级的<code>import</code>或者<code>export</code>声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。</p>
<h2 id="导出-export"><a href="#导出-export" class="headerlink" title="导出(export)"></a>导出(export)</h2><h3 id="导出声明"><a href="#导出声明" class="headerlink" title="导出声明"></a>导出声明</h3><p>任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加<code>export</code>关键字来导出。</p>
<p>Validation.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导出语句"><a href="#导出语句" class="headerlink" title="导出语句"></a>导出语句</h3><p>导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> mainValidator &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="重新导出"><a href="#重新导出" class="headerlink" title="重新导出"></a>重新导出</h3><p>我们经常会去扩展其它模块，并且只导出那个模块的部分内容。 重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。</p>
<p>ParseIntBasedZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ParseIntBasedZipCodeValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; <span class="built_in">parseInt</span>(s).toString() === s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出原先的验证器但做了重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> RegExpBasedZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>或者一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：<code>export * from &quot;module&quot;</code>。</p>
<p>AllValidators.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./StringValidator&quot;</span>; <span class="comment">// exports interface StringValidator</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./LettersOnlyValidator&quot;</span>; <span class="comment">// exports class LettersOnlyValidator</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>; <span class="comment">// exports class ZipCodeValidator</span></span><br></pre></td></tr></table></figure>

<h2 id="导入-import"><a href="#导入-import" class="headerlink" title="导入(import)"></a>导入(import)</h2><p>模块的导入操作与导出一样简单。 可以使用以下 <code>import</code>形式之一来导入其它模块中的导出内容。</p>
<h3 id="导入一个模块中的某个导出内容"><a href="#导入一个模块中的某个导出内容" class="headerlink" title="导入一个模块中的某个导出内容"></a>导入一个模块中的某个导出内容</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> ZipCodeValidator();</span><br></pre></td></tr></table></figure>

<p>可以对导入内容重命名</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> ZCV &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> ZCV();</span><br></pre></td></tr></table></figure>

<h3 id="将整个模块导入到一个变量，并通过它来访问模块的导出部分"><a href="#将整个模块导入到一个变量，并通过它来访问模块的导出部分" class="headerlink" title="将整个模块导入到一个变量，并通过它来访问模块的导出部分"></a>将整个模块导入到一个变量，并通过它来访问模块的导出部分</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> validator <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> validator.ZipCodeValidator();</span><br></pre></td></tr></table></figure>

<h3 id="具有副作用的导入模块"><a href="#具有副作用的导入模块" class="headerlink" title="具有副作用的导入模块"></a>具有副作用的导入模块</h3><p>尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。 这些模块可能没有任何的导出或用户根本就不关注它的导出。 使用下面的方法来导入这类模块：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./my-module.js&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h2><p>每个模块都可以有一个<code>default</code>导出。 默认导出使用 <code>default</code>关键字标记；并且一个模块只能够有一个<code>default</code>导出。 需要使用一种特殊的导入形式来导入 <code>default</code>导出。</p>
<p><code>default</code>导出十分便利。 比如，像<code>JQuery</code>这样的类库可能有一个默认导出 <code>jQuery</code>或<code>$</code>，并且我们基本上也会使用同样的名字<code>jQuery</code>或<code>$</code>导出<code>JQuery</code>。</p>
<p>JQuery.d.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> $: JQuery;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> $;</span><br></pre></td></tr></table></figure>

<p>App.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;JQuery&quot;</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;button.continue&quot;</span>).html(<span class="string">&quot;Next Step...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。</p>
<p>ZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> ZipCodeValidator &#123;</span><br><span class="line">  <span class="keyword">static</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; ZipCodeValidator.numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> validator <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> validator();</span><br></pre></td></tr></table></figure>

<p>或者</p>
<p>StaticZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">s: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> validate <span class="keyword">from</span> <span class="string">&quot;./StaticZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;98052&quot;</span>, <span class="string">&quot;101&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use function validate</span></span><br><span class="line">strings.forEach(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`&quot;<span class="subst">$&#123;s&#125;</span>&quot; <span class="subst">$&#123;validate(s) ? <span class="string">&quot; matches&quot;</span> : <span class="string">&quot; does not match&quot;</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>default</code>导出也可以是一个值</p>
<p>OneTwoThree.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Log.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> num <span class="keyword">from</span> <span class="string">&quot;./OneTwoThree&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="export-和-import-require"><a href="#export-和-import-require" class="headerlink" title="export = 和 import = require()"></a>export = 和 import = require()</h2><p>CommonJS 和 AMD 的环境里都有一个<code>exports</code>变量，这个变量包含了一个模块的所有导出内容。</p>
<p>CommonJS 和 AMD 的<code>exports</code>都可以被赋值为一个对象，这种情况下其作用就类似于 es6 语法里的默认导出，即 <code>export default</code>语法了。虽然作用相似，但是 <code>export default</code> 语法并不能兼容 CommonJS 和 AMD 的<code>exports</code>。</p>
<p>为了支持 CommonJS 和 AMD 的<code>exports</code>, TypeScript 提供了<code>export =</code>语法。</p>
<p><code>export =</code>语法定义一个模块的导出对象。 这里的对象一词指的是类，接口，命名空间，函数或枚举。</p>
<p>若使用<code>export =</code>导出一个模块，则必须使用 TypeScript 的特定语法<code>import module = require(&quot;module&quot;)</code>来导入此模块。</p>
<p>ZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="keyword">class</span> ZipCodeValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> = ZipCodeValidator;</span><br></pre></td></tr></table></figure>

<p>Test.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zip = <span class="built_in">require</span>(<span class="string">&quot;./ZipCodeValidator&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;98052&quot;</span>, <span class="string">&quot;101&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validator = <span class="keyword">new</span> zip();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line">strings.forEach(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`&quot;<span class="subst">$&#123;s&#125;</span>&quot; - <span class="subst">$&#123;validator.isAcceptable(s) ? <span class="string">&quot;matches&quot;</span> : <span class="string">&quot;does not match&quot;</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="生成模块代码"><a href="#生成模块代码" class="headerlink" title="生成模块代码"></a>生成模块代码</h2><p>根据编译时指定的模块目标参数，编译器会生成相应的供 Node.js，CommonJS，Require.js，AMD，UMD，SystemJS 或 ES6 模块加载系统使用的代码。 想要了解生成代码中 <code>define</code>，<code>require</code> 和 <code>register</code>的意义，请参考相应模块加载器的文档。</p>
<p>下面的例子说明了导入导出语句里使用的名字是怎么转换为相应的模块加载器代码的。</p>
<p>SimpleModule.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> m = <span class="built_in">require</span>(<span class="string">&quot;mod&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> t = m.something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>AMD / RequireJS SimpleModule.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>, <span class="string">&quot;./mod&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, mod_1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.t = mod_1.something + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>CommonJS / Node SimpleModule.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mod_1 = <span class="built_in">require</span>(<span class="string">&quot;./mod&quot;</span>);</span><br><span class="line"><span class="built_in">exports</span>.t = mod_1.something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>UMD SimpleModule.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> v = factory(<span class="built_in">require</span>, <span class="built_in">exports</span>);</span><br><span class="line">    <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) <span class="built_in">module</span>.exports = v;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    define([<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>, <span class="string">&quot;./mod&quot;</span>], factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mod_1 = <span class="built_in">require</span>(<span class="string">&quot;./mod&quot;</span>);</span><br><span class="line">  <span class="built_in">exports</span>.t = mod_1.something + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>System SimpleModule.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">System.register([<span class="string">&quot;./mod&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">exports_1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mod_1;</span><br><span class="line">  <span class="keyword">let</span> t;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setters: [</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">mod_1_1</span>) </span>&#123;</span><br><span class="line">        mod_1 = mod_1_1;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      exports_1(<span class="string">&quot;t&quot;</span>, (t = mod_1.something + <span class="number">1</span>));</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>ES6 SimpleModule.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&quot;./mod&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> t = something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。</p>
<p>为了编译，我们必需要在命令行上指定一个模块目标。对于 Node.js 来说，使用<code>--module commonjs</code>； 对于 Require.js 来说，使用<code>--module amd</code>。比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tsc --module commonjs Test.ts</span><br></pre></td></tr></table></figure>

<p>编译完成后，每个模块会生成一个单独的<code>.js</code>文件。 好比使用了 reference 标签，编译器会根据 <code>import</code>语句编译相应的文件。</p>
<p>Validation.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LettersOnlyValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StringValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./Validation&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> lettersRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StringValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./Validation&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StringValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./Validation&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LettersOnlyValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./LettersOnlyValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;98052&quot;</span>, <span class="string">&quot;101&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: StringValidator &#125; = &#123;&#125;;</span><br><span class="line">validators[<span class="string">&quot;ZIP code&quot;</span>] = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">validators[<span class="string">&quot;Letters only&quot;</span>] = <span class="keyword">new</span> LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line">strings.forEach(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`&quot;<span class="subst">$&#123;s&#125;</span>&quot; - <span class="subst">$&#123;validators[name].isAcceptable(s) ? <span class="string">&quot;matches&quot;</span> : <span class="string">&quot;does not match&quot;</span>&#125;</span> <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="可选的模块加载和其它高级加载场景"><a href="#可选的模块加载和其它高级加载场景" class="headerlink" title="可选的模块加载和其它高级加载场景"></a>可选的模块加载和其它高级加载场景</h2><p>有时候，你只想在某种条件下才加载某个模块。 在 TypeScript 里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且可以保证类型完全。</p>
<p>编译器会检测是否每个模块都会在生成的 JavaScript 中用到。 如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 <code>require</code>这个模块的代码。 省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。</p>
<p>这种模式的核心是<code>import id = require(&quot;...&quot;)</code>语句可以让我们访问模块导出的类型。 模块加载器会被动态调用（通过 <code>require</code>），就像下面<code>if</code>代码块里那样。 它利用了省略引用的优化，所以模块只在被需要时加载。 为了让这个模块工作，一定要注意 <code>import</code>定义的标识符只能在表示类型处使用（不能在会转换成 JavaScript 的地方）。</p>
<p>为了确保类型安全性，我们可以使用<code>typeof</code>关键字。 <code>typeof</code>关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。</p>
<p>示例：Node.js 里的动态模块加载</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleName: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> Zip &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">  <span class="keyword">let</span> ZipCodeValidator: <span class="keyword">typeof</span> Zip = <span class="built_in">require</span>(<span class="string">&quot;./ZipCodeValidator&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> validator = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">  <span class="keyword">if</span> (validator.isAcceptable(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：require.js 里的动态模块加载</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleNames: <span class="built_in">string</span>[], onLoad: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Zip <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&quot;./ZipCodeValidator&quot;</span>], <span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> validator = <span class="keyword">new</span> ZipCodeValidator.ZipCodeValidator();</span><br><span class="line">    <span class="keyword">if</span> (validator.isAcceptable(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：System.js 里的动态模块加载</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> System: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> Zip &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">  System.import(<span class="string">&quot;./ZipCodeValidator&quot;</span>).then(<span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">    <span class="keyword">if</span> (x.isAcceptable(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用其它的-JavaScript-库"><a href="#使用其它的-JavaScript-库" class="headerlink" title="使用其它的 JavaScript 库"></a>使用其它的 JavaScript 库</h2><p>要想描述非 TypeScript 编写的类库的类型，我们需要声明类库所暴露出的 API。</p>
<p>我们叫它声明因为它不是“外部程序”的具体实现。 它们通常是在 <code>.d.ts</code>文件里定义的。 如果你熟悉 C/C++，你可以把它们当做 <code>.h</code>文件。 让我们看一些例子。</p>
<h3 id="外部模块"><a href="#外部模块" class="headerlink" title="外部模块"></a>外部模块</h3><p>在 Node.js 里大部分工作是通过加载一个或多个模块实现的。 我们可以使用顶级的 <code>export</code>声明来为每个模块都定义一个<code>.d.ts</code>文件，但最好还是写在一个大的<code>.d.ts</code>文件里。 我们使用与构造一个外部命名空间相似的方法，但是这里使用 <code>module</code>关键字并且把名字用引号括起来，方便之后<code>import</code>。 例如：</p>
<p>node.d.ts (simplified excerpt)</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;url&quot; &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Url &#123;</span><br><span class="line">    protocol?: <span class="built_in">string</span>;</span><br><span class="line">    hostname?: <span class="built_in">string</span>;</span><br><span class="line">    pathname?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">urlStr: <span class="built_in">string</span>, parseQueryString?, slashesDenoteHost?</span>): <span class="title">Url</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;path&quot; &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">p: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">...paths: <span class="built_in">any</span>[]</span>): <span class="title">string</span></span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> sep: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以<code>/// &lt;reference&gt;</code> <code>node.d.ts</code>并且使用<code>import url = require(&quot;url&quot;);</code>或<code>import * as URL from &quot;url&quot;</code>加载模块。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> URL <span class="keyword">from</span> <span class="string">&quot;url&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myUrl = URL.parse(<span class="string">&quot;http://www.typescriptlang.org&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="外部模块简写"><a href="#外部模块简写" class="headerlink" title="外部模块简写"></a>外部模块简写</h3><p>假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。</p>
<p>declarations.d.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;hot-new-<span class="keyword">module</span>&quot;;</span><br></pre></td></tr></table></figure>

<p>简写模块里所有导出的类型将是<code>any</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> x, &#123; y &#125; <span class="keyword">from</span> <span class="string">&quot;hot-new-module&quot;</span>;</span><br><span class="line">x(y);</span><br></pre></td></tr></table></figure>

<h3 id="模块声明通配符"><a href="#模块声明通配符" class="headerlink" title="模块声明通配符"></a>模块声明通配符</h3><p>某些模块加载器如<a href="https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax">SystemJS</a> 和 <a href="https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md">AMD</a>支持导入非 JavaScript 内容。 它们通常会使用一个前缀或后缀来表示特殊的加载语法。 模块声明通配符可以用来表示这些情况。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;*!text&quot; &#123;</span><br><span class="line">  <span class="keyword">const</span> content: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Some do it the other way around.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;json!*&quot; &#123;</span><br><span class="line">  <span class="keyword">const</span> value: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你可以就导入匹配<code>&quot;*!text&quot;</code>或<code>&quot;json!*&quot;</code>的内容了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fileContent <span class="keyword">from</span> <span class="string">&quot;./xyz.txt!text&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&quot;json!http://example.com/data.json&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data, fileContent);</span><br></pre></td></tr></table></figure>

<h3 id="UMD-模块"><a href="#UMD-模块" class="headerlink" title="UMD 模块"></a>UMD 模块</h3><p>有些模块被设计成兼容多个模块加载器，或者不使用模块加载器（全局变量）。 它们以 <a href="https://github.com/umdjs/umd">UMD</a>模块为代表。 这些库可以通过导入的形式或全局变量的形式访问。 例如：</p>
<p>math-lib.d.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> mathLib;</span><br></pre></td></tr></table></figure>

<p>之后，这个库可以在某个模块里通过导入来使用：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isPrime &#125; <span class="keyword">from</span> <span class="string">&quot;math-lib&quot;</span>;</span><br><span class="line">isPrime(<span class="number">2</span>);</span><br><span class="line">mathLib.isPrime(<span class="number">2</span>); <span class="comment">// 错误: 不能在模块内使用全局定义。</span></span><br></pre></td></tr></table></figure>

<p>它同样可以通过全局变量的形式使用，但只能在某个脚本（指不带有模块导入或导出的脚本文件）里。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">mathLib.isPrime(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="创建模块结构指导"><a href="#创建模块结构指导" class="headerlink" title="创建模块结构指导"></a>创建模块结构指导</h2><h3 id="尽可能地在顶层导出"><a href="#尽可能地在顶层导出" class="headerlink" title="尽可能地在顶层导出"></a>尽可能地在顶层导出</h3><p>用户应该更容易地使用你模块导出的内容。 嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。</p>
<p>从你的模块中导出一个命名空间就是一个增加嵌套的例子。 虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。 这对用户来说是很不便的并且通常是多余的。</p>
<p>导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。 除非它能方便表述或便于清晰使用，否则请考虑直接导出一个辅助方法。</p>
<h3 id="如果仅导出单个-class-或-function，使用-export-default"><a href="#如果仅导出单个-class-或-function，使用-export-default" class="headerlink" title="如果仅导出单个 class 或 function，使用 export default"></a>如果仅导出单个 <code>class</code> 或 <code>function</code>，使用 <code>export default</code></h3><p>就像“在顶层上导出”帮助减少用户使用的难度，一个默认的导出也能起到这个效果。 如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。 这会令模块的导入和使用变得些许简单。 比如：</p>
<p>MyClass.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> SomeType &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyFunc.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;thing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consumer.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> t <span class="keyword">from</span> <span class="string">&quot;./MyClass&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> f <span class="keyword">from</span> <span class="string">&quot;./MyFunc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> t();</span><br><span class="line"><span class="built_in">console</span>.log(f());</span><br></pre></td></tr></table></figure>

<p>对用户来说这是最理想的。他们可以随意命名导入模块的类型（本例为<code>t</code>）并且不需要多余的（.）来找到相关对象。</p>
<h3 id="如果要导出多个对象，把它们放在顶层里导出"><a href="#如果要导出多个对象，把它们放在顶层里导出" class="headerlink" title="如果要导出多个对象，把它们放在顶层里导出"></a>如果要导出多个对象，把它们放在顶层里导出</h3><p>MyThings.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> SomeType &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">someFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相反地，当导入的时候：</p>
<h3 id="明确地列出导入的名字"><a href="#明确地列出导入的名字" class="headerlink" title="明确地列出导入的名字"></a>明确地列出导入的名字</h3><p>Consumer.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; SomeType, someFunc &#125; <span class="keyword">from</span> <span class="string">&quot;./MyThings&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> SomeType();</span><br><span class="line"><span class="keyword">let</span> y = someFunc();</span><br></pre></td></tr></table></figure>

<h3 id="使用命名空间导入模式当你要导出大量内容的时候"><a href="#使用命名空间导入模式当你要导出大量内容的时候" class="headerlink" title="使用命名空间导入模式当你要导出大量内容的时候"></a>使用命名空间导入模式当你要导出大量内容的时候</h3><p>MyLargeModule.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Dog &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Cat &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Tree &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Flower &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Consumer.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myLargeModule <span class="keyword">from</span> <span class="string">&quot;./MyLargeModule.ts&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> myLargeModule.Dog();</span><br></pre></td></tr></table></figure>

<h3 id="使用重新导出进行扩展"><a href="#使用重新导出进行扩展" class="headerlink" title="使用重新导出进行扩展"></a>使用重新导出进行扩展</h3><p>你可能经常需要去扩展一个模块的功能。 JS 里常用的一个模式是 JQuery 那样去扩展原对象。 如我们之前提到的，模块不会像全局命名空间对象那样去 _合并_。 推荐的方案是 <em>不要</em>去改变原来的对象，而是导出一个新的实体来提供新的功能。</p>
<p>假设<code>Calculator.ts</code>模块里定义了一个简单的计算器实现。 这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。</p>
<p>Calculator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Calculator &#123;</span><br><span class="line">  <span class="keyword">private</span> current = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> memory = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> operator: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> processDigit(digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (digit &gt;= <span class="string">&quot;0&quot;</span> &amp;&amp; digit &lt;= <span class="string">&quot;9&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> currentValue * <span class="number">10</span> + (digit.charCodeAt(<span class="number">0</span>) - <span class="string">&quot;0&quot;</span>.charCodeAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> processOperator(operator: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>].indexOf(operator) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> operator;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> evaluateOperator(operator: <span class="built_in">string</span>, left: <span class="built_in">number</span>, right: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.operator) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left - right;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left * right;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left / right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> evaluate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.operator) &#123;</span><br><span class="line">      <span class="built_in">this</span>.memory = <span class="built_in">this</span>.evaluateOperator(<span class="built_in">this</span>.operator, <span class="built_in">this</span>.memory, <span class="built_in">this</span>.current);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.memory = <span class="built_in">this</span>.current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> handleChar(char: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">&quot;=&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.evaluate();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="built_in">this</span>.processDigit(char, <span class="built_in">this</span>.current);</span><br><span class="line">      <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.current = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="built_in">this</span>.processOperator(char);</span><br><span class="line">        <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.evaluate();</span><br><span class="line">          <span class="built_in">this</span>.operator = value;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Unsupported input: &#x27;<span class="subst">$&#123;char&#125;</span>&#x27;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getResult() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.memory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">c: Calculator, input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">    c.handleChar(input[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`result of &#x27;<span class="subst">$&#123;input&#125;</span>&#x27; is &#x27;<span class="subst">$&#123;c.getResult()&#125;</span>&#x27;`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面使用导出的<code>test</code>函数来测试计算器。</p>
<p>TestCalculator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Calculator, test &#125; <span class="keyword">from</span> <span class="string">&quot;./Calculator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Calculator();</span><br><span class="line">test(c, <span class="string">&quot;1+2*33/11=&quot;</span>); <span class="comment">// prints 9</span></span><br></pre></td></tr></table></figure>

<p>现在扩展它，添加支持输入其它进制（十进制以外），让我们来创建<code>ProgrammerCalculator.ts</code>。</p>
<p>ProgrammerCalculator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Calculator &#125; <span class="keyword">from</span> <span class="string">&quot;./Calculator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ProgrammerCalculator <span class="keyword">extends</span> Calculator &#123;</span><br><span class="line">  <span class="keyword">static</span> digits = [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> base: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">const</span> maxBase = ProgrammerCalculator.digits.length;</span><br><span class="line">    <span class="keyword">if</span> (base &lt;= <span class="number">0</span> || base &gt; maxBase) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`base has to be within 0 to <span class="subst">$&#123;maxBase&#125;</span> inclusive.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> processDigit(digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ProgrammerCalculator.digits.indexOf(digit) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> currentValue * <span class="built_in">this</span>.base + ProgrammerCalculator.digits.indexOf(digit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Export the new extended calculator as Calculator</span></span><br><span class="line"><span class="keyword">export</span> &#123; ProgrammerCalculator <span class="keyword">as</span> Calculator &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also, export the helper function</span></span><br><span class="line"><span class="keyword">export</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">&quot;./Calculator&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>新的<code>ProgrammerCalculator</code>模块导出的 API 与原先的<code>Calculator</code>模块很相似，但却没有改变原模块里的对象。 下面是测试 ProgrammerCalculator 类的代码：</p>
<p>TestProgrammerCalculator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Calculator, test &#125; <span class="keyword">from</span> <span class="string">&quot;./ProgrammerCalculator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Calculator(<span class="number">2</span>);</span><br><span class="line">test(c, <span class="string">&quot;001+010=&quot;</span>); <span class="comment">// prints 3</span></span><br></pre></td></tr></table></figure>

<h3 id="模块里不要使用命名空间"><a href="#模块里不要使用命名空间" class="headerlink" title="模块里不要使用命名空间"></a>模块里不要使用命名空间</h3><p>当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。 模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。 记住这点，命名空间在使用模块时几乎没什么价值。</p>
<p>在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型进行分组是很便利的。 例如，在 C#里，你会从 <code>System.Collections</code>里找到所有集合的类型。 通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。 然而，模块本身已经存在于文件系统之中，这是必须的。 我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。 我们可以创建 <code>/collections/generic/</code>文件夹，把相应模块放在这里面。</p>
<p>命名空间对解决全局作用域里命名冲突来说是很重要的。 比如，你可以有一个 <code>My.Application.Customer.AddForm</code>和<code>My.Application.Order.AddForm</code> – 两个类型的名字相同，但命名空间不同。 然而，这对于模块来说却不是一个问题。 在一个模块里，没有理由两个对象拥有同一个名字。 从模块的使用角度来说，使用者会挑出他们用来引用模块的名字，所以也没有理由发生重名的情况。</p>
<blockquote>
<p>更多关于模块和命名空间的资料查看<a href="https://www.tslang.cn/docs/handbook/namespaces-and-modules.html">命名空间和模块</a></p>
</blockquote>
<h3 id="危险信号"><a href="#危险信号" class="headerlink" title="危险信号"></a>危险信号</h3><p>以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间：</p>
<ul>
<li>文件的顶层声明是<code>export namespace Foo &#123; ... &#125;</code> （删除<code>Foo</code>并把所有内容向上层移动一层）</li>
<li>文件只有一个<code>export class</code>或<code>export function</code> （考虑使用<code>export default</code>）</li>
<li>多个文件的顶层具有同样的<code>export namespace Foo &#123;</code> （不要以为这些会合并到一个<code>Foo</code>中！）</li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
</search>
