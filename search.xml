<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写给亚瑟的一封信</title>
    <url>/2020/09/18/AletterToArthur/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=78171705&bvid=BV1TJ411i7u9&cid=133749242&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>&emsp;&emsp;我偶尔还是会在西部的荒野疾驰，去听听森林的鸟鸣，去和那该死的灰熊相扑，去拜访一下你以前的老友，少了你的西部，少了点狂野味道</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4280.jpg" width=100%/>

<p>&emsp;&emsp;以前和你疾驰在西部的时候那得多狂野，在瓦伦丁酒吧那次枪战，可谓是一举成名啊杀的人可以排满整个瓦伦丁的铁路，抢的马可以堆满我们营地的那片草原了瓦伦丁的邮局甚至都不敢贴我们俩的悬赏名单，觊觎我们项上人头的赏金猎人可以从黑水镇排到安妮斯堡，可就是没人敢过来惹咱俩，毕竟你的死亡之眼可不是徒有虚名的，甚至于到了罗兹，咱们还特意跑回去瓦伦丁的银行，和比尔、凯伦、蓝尼他们狠狠地抢了一波，想起来那倒是痛快，毕竟谁能想到这居然是这段时间乃至以后最成功的一次抢银行，后来被赶到了罗兹，却被那该死的格雷家族和布雷斯维特家族利用，我们是谁？单凭神枪手—亚瑟摩根，你的项上人头就值 5000 美金，更何况还有我在，结果那自然是罗兹镇的格雷家族横尸遍野以及那让他们引以为傲的布雷斯维特庄园被烧成灰烬，</p>
<a id="more"></a>

<p>&emsp;&emsp;但是逃亡的日子也总是不好过，尤其是西恩死后和小杰克被抢走后，那日子愈发的紧张了不过我们起码到了个不错的居所，你曾经的居所，一个可以遮风挡雨的地方，从黑水镇以后达奇确实是变了，大家也都变得紧张起来当小杰克回来时，他那句：这是我经历过最快乐的时光了，着实刺疼你和约翰看得出约翰和你都露出难堪的脸色，一群亡命之徒带着一个孩子，算什么亡命之徒，对吧你们想要着最为平静的生活，而达奇却依旧在幻想他的美好世界，直到被削了的脑袋的基兰被送回营地时，我们才意识到我们结下的梁子和麻烦有多少</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4WvT.jpg" width=100%/>

<p>&emsp;&emsp;可那达奇被那该死的勃朗特洗了脑，被忽悠着抢了座分文不值的驿站，而后我们又在抢银行时被那平克顿侦探截了胡，何西亚和蓝尼就这样永久离开了我们。再然后你就和我们这群人就这样走散了而等到你们回来时，你的脸色就不太好了。而自打你从医生那回来，你就告诉我，你最近时常能梦到一匹鹿，在静谧的森林里的一头鹿</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4gCq.jpg" width=100%/>

<p>&emsp;&emsp;我知道的，我早该知道，是肺结核，那该死的唐斯一家，那该死的放债人，尤其是那该死的西部幻想家，这他妈都做了多少事，总是不切实际地让我们干着干那，你这身体无论如何都会吃不消的。我说再去西部狂野一把，去狩猎，去抢银行，可是你却说算了算了，帮派还有那么多不安稳的人接着帮达奇干起了的肮脏的勾当，你还是相信着他的美梦，只是没那么蠢了后来你终于醒了看来是被那该死的唐斯太太给劝醒了也不知道该不该谢谢这位唐斯太太最后的那段时间，你简直换了个人，但又还是那个亚瑟以往对达奇言听计从的亚瑟背着他救出了约翰、飞鹰，以往视金钱如命的亚瑟居然散尽家财帮助其他人</p>
<p>&emsp;&emsp;后来你还告诉我，你认识了一名老兵，一名和你很像的老兵，看清了生死；那印第安人的首领——落雨，是为数不多想帮你减轻痛苦的人，是他告诉了你人生的意义，他才是那位真正有远识的人在去和达奇见最后一面时，你告诉我，你因没有救下飞鹰而后悔，你甚至后悔没有告诉玛丽你的事情，你没有安排好所有人，只能把他们的命运托给沙迪夫人和我，</p>
<p>&emsp;&emsp;我想你是想好好和他们道个别的，但总是少那么个机会毕竟西部的世界总是那么狂野，狂野到没有坐下来好好休息、聊天的时间听你说你喜欢能看见太阳的地方，查尔斯还特意选了个好位置给你呢，这下你可有时间坐下来好好休息了可这西部啊，少了你，就少了点味道少了那味道，我都不知道该干些什么了你知道吗，在你离开之后，帮派也散了。皮尔逊那家伙去当了个商店老板，这个脑袋少根筋的家伙居然还把我们的合照挂在了墙头，也不怕其他人闻起来，不知道这个自恋的家伙追到他喜欢的姑娘没？莎迪夫人还是老样子，雷厉风行，她说：像她这种人，在屋子被烧掉后，就注定没有归宿。于是一个人在狂野的西部当起了赏金猎人，虽然她的枪法很烂而且整个人还是鲁莽，但我还是希望她能活久一点，毕竟她骑马去打听迈卡消息的时候，我居然看到了一丝你的身影</p>
<p>&emsp;&emsp;还记得那个被你赶走的放债人吗，那家伙最后一笔债放给一个叫做亚瑟的人。一路上听见的都是“亚瑟死了”，真他妈的难听。就是这样一个斯文败类又弱不禁风的德国人最后还是被平克顿侦探抓住了。只是没想到，这家伙即使是被折磨致死都不肯说出我们的下落，果然人就不能看那该死的行为，你看那杀千刀迈卡不就是一个 25 仔？噢，</p>
<p>&emsp;&emsp;对了，怎么能忘了约翰·马斯顿这家伙？这家伙，正如你所说的：be a god damn man，这个开头被狼啃坏脑子的人居然真得开始了农场主的生活。虽然还是那幅牛仔样，还是那个一言不合就拔枪的人。说起来你还真狡猾，居然把全部东西给了马斯顿，你的帽子，枪，照片，日记甚至是戒指。不过也好，倘若是留给我那就是压箱底的宝物了，我可不像那马斯顿，拿起你的日记继续写着他的生活，甚至还拿起你的戒指在黑水镇的胡中心向阿比盖尔求起了婚，天晓得这对老夫老妻有多幸福。如果那天你逃出来了，是不是会拿着这枚戒指跑去找玛丽。不过，你应该不敢，在爱人这方面，你可比马斯顿逊色多了</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4R2V.jpg" width=100%/>

<p>&emsp;&emsp;对了，说起马斯顿，这家伙居然不听阿比盖尔的劝和莎迪去找迈卡报仇了，带着你的帽子和你的枪。不得不说，这家伙功夫还是不到家啊，你喝醉酒的枪法都比清醒时的他强，甚至在最后差点被迈卡所杀，好在达奇那老糊涂总算是清醒了一次大家都过得很好，该成家立业都成家立业，即使是大叔和查尔斯在外流浪的人也都留在了马斯顿的身边经营着那新建的农场。如果你肯定会喜欢这种生活，毕竟你和马斯顿曾经在瓦伦丁一起赶过羊呢！玛丽，她说着和你永远不相见，却还是偷偷跑去你的墓旁哭泣，她大概是再也不会遇到一个那么傻的神枪手了，</p>
<p>&emsp;&emsp;我至今还是无法回忆起你“血仇，血债，血偿”那条路，那条路上的你总是想起最后那段时间他们所说的话，但总得还是那句——“做你能做的”。那句对达奇说的：i gave you all i had，是我见过最无奈的话了我可太不同意查尔斯那句话了：“知道自己的死期比很多人幸运。”但我又太同意这句话了，西恩，何西亚，蓝尼甚至连话都没说就被这狂野的西部杀了，措手不及。于是在最后的时刻你尽力自己所能救了他们，也救了自己。至少在最后，你会说：in the end，i did it 最后我还是选择留在了之前有你的瓦伦丁镇，毕竟只有那时候，大家还是有退路，而你还是那个意气风发的神枪手</p>
]]></content>
      <categories>
        <category>游戏日记</category>
      </categories>
      <tags>
        <tag>荒野大镖客</tag>
        <tag>亚瑟-摩根</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest</title>
    <url>/2020/09/19/jest/</url>
    <content><![CDATA[<h3 id="Jest环境搭建"><a href="#Jest环境搭建" class="headerlink" title="Jest环境搭建"></a>Jest环境搭建</h3>]]></content>
      <categories>
        <category>前端自动化测试</category>
      </categories>
      <tags>
        <tag>jest</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 中的高级类型</title>
    <url>/2020/09/13/ts%E9%AB%98%E7%BA%A7%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型，这让我们可以把现有的多种类型叠加到一起作为一种类型，它包含了所需的所有类型的特性，例如<code>Person &amp; Serializable &amp; Loggable </code>同时是 <code>Person</code> 和 <code>Serializable</code> 和 <code>Loggable</code>。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>
<p>我们大多是在混入或其他不适合经典面向对象的地方看到交叉类型的使用，（在<code>JavaScript</code>中发生这种情况的场合会很多）下面是如何创建混入的一个简单的例子:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">    (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Loggable &#123;</span><br><span class="line">  log(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</span><br><span class="line">  log() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">&quot;Jim&quot;</span>), <span class="keyword">new</span> ConsoleLogger());</span><br><span class="line"><span class="keyword">var</span> n = jim.name;</span><br><span class="line">jim.log();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型与交叉类型很有关联，但是使用上却完全不同，偶尔你会遇到这种情况，一个代码库希望传入<code>number</code>或<code>string</code>类型作为参数，例如下面的函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Takes a string and adds &quot;padding&quot; to the left.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a string, then &#x27;padding&#x27; is appended to the left side.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a number, then that number of spaces is added to the left side.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">padLeft(<span class="string">&quot;Hello world&quot;</span>, <span class="number">4</span>); <span class="comment">// returns &quot;    Hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在 <code> padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定为了 <code>any</code> ，这就是说我们可以传入一个既不是<code>number</code> 也不是 <code>string</code> 类型的参数，但是<code>typescript</code>却不报错，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">&quot;Hello world&quot;</span>, <span class="literal">true</span>); <span class="comment">// 编译阶段通过，运行时报错</span></span><br></pre></td></tr></table></figure>

<p>在传统的面向对象语言里，我们可能会将这两种抽象成底层的类型，这么做显然是非常清晰的，但同时也存在了过度设计，<code>padleft</code> 原始版本的好处之一就是允许我们呢出传入原始类型，这样做的话用起来简单又方便，如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。</p>
<p>代替<code>any</code>，我们可以使用联合类型作为 <code>padding</code> 的参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Takes a string and adds &quot;padding&quot; to the left.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a string, then &#x27;padding&#x27; is appended to the left side.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a number, then that number of spaces is added to the left side.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">&quot;Hello world&quot;</span>, <span class="literal">true</span>); <span class="comment">// errors during compilation</span></span><br></pre></td></tr></table></figure>

<p>联合类型表示一个值可以是几种类型之一，我们用竖线（<code>|</code>）分割每个类型，所以<code>number|string|boolean</code>，表示值可以是<code>number</code> <code>string</code> 或 <code>boolean</code></p>
<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  fly();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  swim();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line">pet.layEggs(); <span class="comment">// okay</span></span><br><span class="line">pet.swim(); <span class="comment">// errors</span></span><br></pre></td></tr></table></figure>

<p>这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是 <code>A | B</code>，我们能够 确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。 这个例子里， <code>Bird</code>具有一个 <code>fly</code>成员。 我们不能确定一个 <code>Bird | Fish</code>类型的变量是否有 <code>fly</code>方法。 如果变量在运行时是 <code>Fish</code> 类型，那么调用 <code>pet.fly()</code> 就出错了。</p>
<h3 id="类型保护与区分类型"><a href="#类型保护与区分类型" class="headerlink" title="类型保护与区分类型"></a>类型保护与区分类型</h3><p>联合类型适合于那些值可以作为不同类型的情况，但当我们想确切的了解是否为 <code>Fish</code> 时怎么办？ <code>JavaScript</code> 里常用来区分两个可能的值的方法是检查成员是否存在，如之前提及的，我们只能访问联合类型中共同拥有的成员</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个成员访问都会报错</span></span><br><span class="line"><span class="keyword">if</span> (pet.swim) &#123;</span><br><span class="line">  pet.swim();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet.fly) &#123;</span><br><span class="line">  pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让这段代码工作，我们需要使用类型断言</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((&lt;Fish&gt;pet).swim) &#123;</span><br><span class="line">  (&lt;Fish&gt;pet).swim();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  (&lt;Bird&gt;pet).fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用户自定义的类型保护</strong></p>
<p>这里可以注意到，我们不得不多次使用类型断言，假如我们一旦检查过类型，就能在之后的每个分支里清楚的知道 <code>pet</code> 的类型的话就好了</p>
<p>这样 <code>TypeScript</code> 里的 类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 _类型谓词_：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里， <code>pet is Fish</code>就是类型谓词。 谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p>
<p>每当使用一些变量调用 <code>isFish</code> 时，<code>TypeScript</code> 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#x27;swim&#x27; 和 &#x27;fly&#x27; 调用都没有问题了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</span><br><span class="line">  pet.swim();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>typescript</code>不仅知道在<code>if</code>分支里 <code>pet</code> 是 <code>Fish</code> 类型的，它还清楚在 <code>else</code> 分支里，一定不是 <code>Fish</code> 类型的，一定是 <code>Bird</code> 类型的</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>前端测试开篇</title>
    <url>/2020/09/19/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="什么是自动化测试"><a href="#什么是自动化测试" class="headerlink" title="什么是自动化测试"></a>什么是自动化测试</h3><blockquote>
<p>在软件测试中，测试自动化（英语：Test automation）是一种测试方法，使用特定的软件，去控制测试流程，并比较实际的结果与预期结果之间的差异。通过将测试自动化，可以让正式的测试过程中的必要测试，可以反复进行；通过这种方法，也可以将难以手动进行的测试，交由软件来做。测试自动化的最大优势就是可以快速而且反复的进行测试。</p>
</blockquote>
<p>简单理解，自动化测试是指软件测试的自动化，让软件代替人工测试，可以快速，反复进行</p>
<p>关于自动化测试有一个金字塔理论，把测试从上到下分为 /UI（用户界面测试）/Service（服务测试） /Unit（单元测试 ）。如图所示，越往金字塔底层，测试的效率越高，测试质量保障程度越高，测试的成本越低。怎么理解这句话呢？前端项目通常 UI 变化频繁，一旦发生变化，UI 测试用例就无法执行且难以维护，所以 UI 自动化测试的成本高，收益小；相比 UI 测试，Service 测试更加简单直接且变化不会很频繁；单元测试主要对公共函数、方法进行测试，测试用例复用度高且更能保证代码质量。</p>
<a id="more"></a>

<img data-src='https://pic4.zhimg.com/80/v2-99fbbe6203ee75133178cdd5b131b4ac_720w.jpg'>

<h3 id="实现自动化测试有什么好处"><a href="#实现自动化测试有什么好处" class="headerlink" title="实现自动化测试有什么好处"></a>实现自动化测试有什么好处</h3><p>测试最重要的目的是验证代码正确性，确保项目质量。举个例子，某一天我写了一个逻辑复杂的函数，这个函数被很多地方调用，过了一个月之后，我可能忘记这里面的具体逻辑了，出于某种原因需要为这个函数增加一些功能，修改这个函数的代码，那我要怎么做才能保证修改代码后不影响其他的调用者呢，或者说，我要怎么做，才能快速的知道哪些地方受影响，哪些地方不受影响呢？答案就是实施自动化测试，跑测试用例。</p>
<p>如果不进行自动化测试，我们会如何验证代码的正确性？通常 FE 使用的方法是手动测试：console、alert、打断点、点点点。但手动测试是一次性的，如果下次有人对代码功能做了修改，我们不得不再次重复手动测试的工作，并且很难保证测试的全覆盖。但如果编写测试用例进行自动化测试，第一次写完的测试用例是可以重复使用的，一次编写，多次运行。如果测试用例写的完善、语义化，开发人员还可以通过看测试用例快速了解项目需求。实施自动化测试可以驱动开发人员在代码的设计中做更好的抽象，写可测试的代码，以测试公用方法为例，要确保被测试的方法无副作用，既对外部变量没有依赖，也不会改变全局原本的状态。</p>
<p>总结一下，实施自动化测试有四个好处：</p>
<ul>
<li>可以验证代码正确性，保证项目质量</li>
<li>测试用例可以复用，一次编写，多次运行</li>
<li>通过看测试用例可以快速了解需求</li>
<li>驱动开发，指导设计，保证写的代码可测试</li>
</ul>
<h3 id="什么样的项目适合自动化测试"><a href="#什么样的项目适合自动化测试" class="headerlink" title="什么样的项目适合自动化测试"></a>什么样的项目适合自动化测试</h3><p>自动化测试如此优秀，那是不是所有项目都适合进行自动化测试？答案是否定的，因为有成本。在实施自动化测试之前需要对软件开发过程进行分析，基于投入产出来判断是否适合实施自动化测试。实施自动化测试的项目通常需要同时满足以下条件：</p>
<ul>
<li>需求变动不频繁</li>
<li>项目周期足够长</li>
<li>自动化测试脚本可重复使用</li>
<li>代码规范可测试</li>
</ul>
<p>如果需求变动过于频繁，维护测试脚本的成本太高；如果项目周期比较短，没有足够的时间去支持自动化测试的过程；如果测试脚本重复使用率低，耗费的精力大于创造的价值，不值得；如果代码不规范，可测试性差，那自动化测试实施起来会比较困难。</p>
<hr>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>ATDD： Acceptance Test Driven Development（验收测试驱动开发）</strong></p>
<p>这是一种在编码开始之前将客户带入测试设计过程的技术。它也是一个协作实践，用户，测试人员和开发人员定义了自动验收标准。 ATDD 有助于确保所有项目成员准确理解需要完成和实施的内容。如果系统未通过测试可提供快速反馈，说明未满足要求。验收测试以业务领域术语进行指定。每个功能都必须提供真实且可衡量的业务价值，事实上，如果您的功能没有追溯至至少一个业务目标，那么您应该想知道为什么您要首先实施它。</p>
<p><strong>TDD：Test-driven development （测试驱动开发）</strong></p>
<p>是一种使用自动化单元测试来推动软件设计并强制依赖关系解耦的技术。使用这种做法的结果是一套全面的单元测试，可随时运行，以提供软件可以正常工作的反馈。TDD 重点是培养整个研发过程的节奏感，就像跳踢踏舞一样，“ti-ta-ti”。在编写真正实现功能的代码之前先编写测试，每次测试之后，重构完成，然后再次执行相同或类似的测试。该过程根据需要重复多次，直到每个单元根据所需的规格运行。</p>
<p><strong>BDD：Behavior-Driven Development (行为驱动开发)</strong></p>
<p>BDD 将 TDD 的一般技术和原理与领域驱动设计(DDD)的想法相结合。 BDD 是一个设计活动，您可以根据预期行为逐步构建功能块。BDD 的重点是软件开发过程中使用的语言和交互。行为驱动的开发人员使用他们的母语与领域驱动设计的语言相结合来描述他们的代码的目的和好处。使用 BDD 的团队应该能够以用户故事的形式提供大量的“功能文档”，并增加可执行场景或示例。 BDD 通常有助于领域专家理解实现而不是暴露代码级别测试。它通常以 GWT 格式定义：GIVEN WHEN＆THEN。</p>
<blockquote>
<p>小结：TDD 的原理是在开发功能代码之前，先编写单元测试用例代码（先写测试再开发，一般都是单元测试，白盒测试）；BDD 的原理是系统业务专家、开发者、测试人员一起合作，分析软件的需求，然后将这些需求写成一个个的故事。开发者负责填充这些故事的内容，保证程序实现效果与用户需求一致。也就是 BDD 是按照用户的行为来开发，再根据用户的行为编写测试用例 （一般都是集成测试，黑盒测试）</p>
</blockquote>
<h3 id="黑盒测试和白盒测试"><a href="#黑盒测试和白盒测试" class="headerlink" title="黑盒测试和白盒测试"></a>黑盒测试和白盒测试</h3><ul>
<li>黑盒测试一般也被称为功能测试，黑盒测试要求测试人员将程序看作一个整体，不考虑其内部结构和特性，只是按照期望验证程序是否能正常工作</li>
<li>白盒测试是基于代码本身的测试，一般指对代码逻辑结构的测试。</li>
</ul>
<h3 id="测试分类（部分）"><a href="#测试分类（部分）" class="headerlink" title="测试分类（部分）"></a>测试分类（部分）</h3><p>单元测试(Unit Testing)</p>
<ul>
<li>对软件中的最小可测试单元进行检查和验证。例如测试一个函数、一个模块、一个组件…，前端所说的单元测试就是对一个模块进行测试。也就是说前端测试的时候，你测试的东西一定是一个模块。</li>
</ul>
<p>集成测试(Integration Testing)</p>
<ul>
<li>将已测试过的单元测试函数进行组合集成暴露出的高层函数或类的封装，对这些函数或类进行的测试</li>
</ul>
<p>端到端测试(E2E Testing)</p>
<ul>
<li>打开应用程序模拟输入，检查功能以及界面是否正确</li>
</ul>
]]></content>
      <categories>
        <category>前端自动化测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2020/09/22/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>假设有一个快餐店，而我是快餐店的点餐服务员，那么我一天的工作应该是这样的，当某位客人点餐或者打来订餐电话后，我会把它的需求都写在清单上，然后提交给厨房，客人不同关心是那些厨师帮他炒菜，我们餐厅还可以满足可客人的需要的定时服务，比如客人可能当前正在回家的路上，要求一个小时后才开始炒他的菜，只要订单还在，厨师就不会忘记，客人也可以很方便的打电话来撤销订单，另外如果有太多的客人点单，厨师可以按照订单的顺序排队炒菜</p>
<p>这些记录着订餐信息的清单，便是命令模式中的命令对象</p>
<h2 id="命令模式的用途"><a href="#命令模式的用途" class="headerlink" title="命令模式的用途"></a>命令模式的用途</h2><p>命令模式是最简单的优雅模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令</p>
<p>命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么，此时希望有一种松耦合的方式来设计程序的，使得请求送者和请求接收者能够消除彼此间的耦合关系</p>
]]></content>
      <categories>
        <category>JavaScript设计模式与开发实践据</category>
      </categories>
  </entry>
  <entry>
    <title>声明合并</title>
    <url>/2020/09/20/%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Typescript 中有些独特的概念可以在类型层面上描述 JavaScript 对象类型，这其中有其独特的有一个例子是“声明合并”的概念，理解了这个概念，将有助于操作现有的 JavaScript 代码，同时，也会有助于理解更多高级抽象的概念，</p>
<p>对本文来说，“声明合并”是指编译器将针对同一个名字的两个独立声明合并为一个声明，合并后的声明同时拥有原先两个声明的特性，任何数量的声明都可以被合并；并不局限于两个</p>
<a id="more"></a>

<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>typescript 的声明会创建以下三种实体之一：命名空间，类型或值，创建命名空间的声明会新建一个命名空间，它包含了（.）符号来方式时使用的名字，创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上，最后，创建值的声明会创建在 JavaScript 输出中看到的值</p>
<blockquote>
<p>创建一个命名空间其实就是创建了一个对象，命名空间中用 export 导出的值都会成为兑现的属性</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Declaration Type</th>
<th align="center">Namespace</th>
<th align="center">Type</th>
<th align="center">Value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Namespace（命名空间）</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">Class（类）</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">Enum（枚举）</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">Interface（接口）</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Type Alias（类型别名）</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Function（函数）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">Variable（值）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>理解每个声明创建了什么，有助于理解当声明合并时有哪些东西被合并了</p>
<h3 id="合并接口"><a href="#合并接口" class="headerlink" title="合并接口"></a>合并接口</h3><p>最简单也最常见的声明合并是接口合并，从根本上说，合并的机制是把双方的成员放到一个同名的接口里</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Box &#123;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Box &#123;</span><br><span class="line">  scale: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> box: Box = &#123; height: <span class="number">5</span>, width: <span class="number">6</span>, scale: <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>接口的非函数成员应该是唯一的，如果他们不是唯一的，那么他们必须是相同的类型，如果两个接口同时声明了同名的非函数成员且他们的类型不同，则编译器会报错</p>
<p>对于函数成员，每个同名的函数声明都会被当成函数的一个重载，同时需要注意，当接口 A 与后来的接口 A 合并的时候，后面的接口具有更高的优先级</p>
<p>如下例所示</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Animal): Animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Sheep): Sheep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Dog): Dog;</span><br><span class="line">  clone(animal: Cat): Cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个接口会合并成一个声明</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Dog): Dog;</span><br><span class="line">  clone(animal: Cat): Cat;</span><br><span class="line">  clone(animal: Sheep): Sheep;</span><br><span class="line">  clone(animal: Animal): Animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前位置。</p>
<p>这个规则有一个例外是当出现特殊的函数签名时。 如果签名里有一个参数的类型是 <em>单一</em>的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。</p>
<p>比如，下面的接口会合并到一起：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">  createElement(tagName: <span class="built_in">any</span>): Element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;div&quot;</span>): HTMLDivElement;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;span&quot;</span>): HTMLSpanElement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">  createElement(tagName: <span class="built_in">string</span>): HTMLElement;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;canvas&quot;</span>): HTMLCanvasElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并后的 <code>Document</code>将会像下面这样：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;canvas&quot;</span>): HTMLCanvasElement;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;div&quot;</span>): HTMLDivElement;</span><br><span class="line">  createElement(tagName: <span class="string">&quot;span&quot;</span>): HTMLSpanElement;</span><br><span class="line">  createElement(tagName: <span class="built_in">string</span>): HTMLElement;</span><br><span class="line">  createElement(tagName: <span class="built_in">any</span>): Element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并命名空间"><a href="#合并命名空间" class="headerlink" title="合并命名空间"></a>合并命名空间</h3><p>与接口类似，同名的命名空间也会合并其成员，命名空间创建出命名空间和值，我们需要知道这两者是怎们合并的</p>
<p>对于命名空间的合并，模块导出的同名接口进行合并，</p>
<p>对于命名空间里值的合并，如果当前已经存在的给定名字的命名空间，那么后来的命名空间的导出成员会被加到以存在的那个模块里</p>
<p><code>Animals</code>声明合并示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animals &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Zebra &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Animals &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Legged &#123;</span><br><span class="line">    numberOfLegs: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Dog &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animals &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Legged &#123;</span><br><span class="line">    numberOfLegs: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Zebra &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Dog &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这些合并外，你还需要了解非导出成员是如何处理的，非导出成员仅在其原有（合并前）命名空间内可以，这就是说合并之后，从其他命名空间合并进来的成员无法访问非导出成员</p>
<p>看下面例子</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animal &#123;</span><br><span class="line">  <span class="keyword">let</span> haveMuscles = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">animalsHaveMuscles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> haveMuscles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Animal &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doAnimalsHaveMuscles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> haveMuscles; <span class="comment">// Error, because haveMuscles is not accessible here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>haveMuscles</code>并没有导出，只有 <code>animalsHaveMuscles</code>函数共享了原始未合并的命名空间可以访问这个变量。 <code>doAnimalsHaveMuscles</code>函数虽是合并命名空间的一部分，但是访问不了未导出的成员。</p>
<h3 id="命名空间与类和函数和枚举类型合并"><a href="#命名空间与类和函数和枚举类型合并" class="headerlink" title="命名空间与类和函数和枚举类型合并"></a>命名空间与类和函数和枚举类型合并</h3><p>命名空间可以与其他类型的声明进行合并，只要命名空间的定义符合将要合并类型的定义，合并结果包含两者的声明类型，typescript 使用这个功能去实现一些 JavaScript 里的设计模式</p>
<h4 id="合并命名空间和类"><a href="#合并命名空间和类" class="headerlink" title="合并命名空间和类"></a>合并命名空间和类</h4><p>这让我们可以表示内部类</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Album &#123;</span><br><span class="line">  label: Album.AlbumLabel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Album &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> AlbumLabel &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并规则与上面 <code>合并命名空间</code>小节里讲的规则一致，我们必须导出 <code>AlbumLabel</code>类，好让合并的类能访问。 合并结果是一个类并带有一个内部类。 你也可以使用命名空间为类增加一些静态属性。</p>
<p>除了内部类的模式，你在 JavaScript 里，创建一个函数稍后扩展它增加一些属性也是很常见的。 TypeScript 使用声明合并来达到这个目的并保证类型安全。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildLabel</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildLabel.prefix + name + buildLabel.suffix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> buildLabel &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> suffix = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> prefix = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buildLabel(<span class="string">&quot;Sam Smith&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>相似的，命名空间可以用来扩展枚举型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  red = <span class="number">1</span>,</span><br><span class="line">  green = <span class="number">2</span>,</span><br><span class="line">  blue = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Color &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixColor</span>(<span class="params">colorName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (colorName == <span class="string">&quot;yellow&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Color.red + Color.green;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorName == <span class="string">&quot;white&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Color.red + Color.green + Color.blue;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorName == <span class="string">&quot;magenta&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Color.red + Color.blue;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorName == <span class="string">&quot;cyan&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Color.green + Color.blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非法的合并"><a href="#非法的合并" class="headerlink" title="非法的合并"></a>非法的合并</h3><p>TypeScript 并非允许所有的合并。 目前，类不能与其它类或变量合并。 想要了解如何模仿类的合并，请参考 <a href="https://www.tslang.cn/docs/handbook/mixins.html">TypeScript 的混入</a>。</p>
<h3 id="模块扩展"><a href="#模块扩展" class="headerlink" title="模块扩展"></a>模块扩展</h3><p>虽然 JavaScript 不支持合并，但你可以为导出的对西昂打补丁以更新他们，让我们考察以下这个玩具性的示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// observable.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Observable&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ... implementation left as an exercise for the reader ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">&quot;./observable&quot;</span>;</span><br><span class="line">Observable.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... another exercise for the reader</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它也可以很好地工作在 TypeScript 中， 但编译器对 <code>Observable.prototype.map</code>一无所知。 你可以使用扩展模块来将它告诉编译器：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// observable.ts stays the same</span></span><br><span class="line"><span class="comment">// map.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">&quot;./observable&quot;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;./observable&quot; &#123;</span><br><span class="line">  <span class="keyword">interface</span> Observable&lt;T&gt; &#123;</span><br><span class="line">    map&lt;U&gt;(f: <span class="function">(<span class="params">x: T</span>) =&gt;</span> U): Observable&lt;U&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Observable.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... another exercise for the reader</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// consumer.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">&quot;./observable&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./map&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> o: Observable&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">o.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x.toFixed());</span><br></pre></td></tr></table></figure>

<p>模块名的解析和用 <code>import</code>/ <code>export</code>解析模块标识符的方式是一致的。 更多信息请参考 <a href="https://www.tslang.cn/docs/handbook/modules.html">Modules</a>。 当这些声明在扩展中合并时，就好像在原始位置被声明了一样。 但是，你不能在扩展中声明新的顶级声明－仅可以扩展模块中已经存在的声明。</p>
<h4 id="全局扩展"><a href="#全局扩展" class="headerlink" title="全局扩展"></a>全局扩展</h4><p>你也以在模块内部添加声明到全局作用域中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; observable.ts</span><br><span class="line">export class Observable&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; ... still no implementation ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare global &#123;</span><br><span class="line">    interface Array&lt;T&gt; &#123;</span><br><span class="line">        toObservable(): Observable&lt;T&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.toObservable &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局扩展与模块扩展的行为和限制是相同的。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>类型兼容性</title>
    <url>/2020/09/21/%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TypeScript 里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 看下面的例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Named;</span><br><span class="line"><span class="comment">// OK, because of structural typing</span></span><br><span class="line">p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>在使用基于名义类型的语言，比如 C#或 Java 中，这段代码会报错，因为 Person 类没有明确说明其实现了 Named 接口。</p>
<p>TypeScript 的结构性子类型是根据 JavaScript 代码的典型写法来设计的。 因为 JavaScript 里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。</p>
<a id="more"></a>

<h3 id="关于可靠性的注意事项"><a href="#关于可靠性的注意事项" class="headerlink" title="关于可靠性的注意事项"></a>关于可靠性的注意事项</h3><p>TypeScript 的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript 允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>TypeScript 结构化类型系统的基本规则是，如果<code>x</code>要兼容<code>y</code>，那么<code>y</code>至少具有与<code>x</code>相同的属性。比如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Named;</span><br><span class="line"><span class="comment">// y&#x27;s inferred type is &#123; name: string; location: string; &#125;</span></span><br><span class="line"><span class="keyword">let</span> y = &#123; name: <span class="string">&quot;Alice&quot;</span>, location: <span class="string">&quot;Seattle&quot;</span> &#125;;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure>

<p>这里要检查<code>y</code>是否能赋值给<code>x</code>，编译器检查<code>x</code>中的每个属性，看是否能在<code>y</code>中也找到对应属性。 在这个例子中，<code>y</code>必须包含名字是<code>name</code>的<code>string</code>类型成员。<code>y</code>满足条件，因此赋值正确。</p>
<p>检查函数参数时使用相同的规则：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">n: Named</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello, &quot;</span> + n.name);</span><br><span class="line">&#125;</span><br><span class="line">greet(y); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>y</code>有个额外的<code>location</code>属性，但这不会引发错误。 只有目标类型（这里是<code>Named</code>）的成员会被一一检查是否兼容。</p>
<p>这个比较过程是递归进行的，检查每个成员及子成员。</p>
<h2 id="比较两个函数"><a href="#比较两个函数" class="headerlink" title="比较两个函数"></a>比较两个函数</h2><p>相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 下面我们从两个简单的函数入手，它们仅是参数列表略有不同：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// OK</span></span><br><span class="line">x = y; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>要查看<code>x</code>是否能赋值给<code>y</code>，首先看它们的参数列表。 <code>x</code>的每个参数必须能在<code>y</code>里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，<code>x</code>的每个参数在<code>y</code>中都能找到对应的参数，所以允许赋值。</p>
<p>第二个赋值错误，因为<code>y</code>有个必需的第二个参数，但是<code>x</code>并没有，所以不允许赋值。</p>
<p>你可能会疑惑为什么允许<code>忽略</code>参数，像例子<code>y = x</code>中那样。 原因是忽略额外的参数在 JavaScript 里是很常见的。 例如，<code>Array#forEach</code>给回调函数传 3 个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t force these extra arguments</span></span><br><span class="line">items.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> <span class="built_in">console</span>.log(item));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Should be OK!</span></span><br><span class="line">items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item));</span><br></pre></td></tr></table></figure>

<p>下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">() =&gt;</span> (&#123; name: <span class="string">&quot;Alice&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">() =&gt;</span> (&#123; name: <span class="string">&quot;Alice&quot;</span>, location: <span class="string">&quot;Seattle&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// OK</span></span><br><span class="line">y = x; <span class="comment">// Error, because x() lacks a location property</span></span><br></pre></td></tr></table></figure>

<p>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。</p>
<h3 id="函数参数双向协变"><a href="#函数参数双向协变" class="headerlink" title="函数参数双向协变"></a>函数参数双向协变</h3><p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多 JavaScript 里的常见模式。例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> EventType &#123;</span><br><span class="line">  Mouse,</span><br><span class="line">  Keyboard,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Event &#123;</span><br><span class="line">  timestamp: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> MouseEvent <span class="keyword">extends</span> Event &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> KeyEvent <span class="keyword">extends</span> Event &#123;</span><br><span class="line">  keyCode: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listenEvent</span>(<span class="params">eventType: EventType, handler: (n: Event) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsound, but useful and common</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> <span class="built_in">console</span>.log(e.x + <span class="string">&quot;,&quot;</span> + e.y));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Undesirable alternatives in presence of soundness</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">console</span>.log((&lt;MouseEvent&gt;e).x + <span class="string">&quot;,&quot;</span> + (&lt;MouseEvent&gt;e).y));</span><br><span class="line">listenEvent(EventType.Mouse, &lt;<span class="function">(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">void</span>&gt;(<span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> <span class="built_in">console</span>.log(e.x + <span class="string">&quot;,&quot;</span> + e.y)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Still disallowed (clear error). Type safety enforced for wholly incompatible types</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">console</span>.log(e));</span><br></pre></td></tr></table></figure>

<h3 id="可选参数及剩余参数"><a href="#可选参数及剩余参数" class="headerlink" title="可选参数及剩余参数"></a>可选参数及剩余参数</h3><p>比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。</p>
<p>当一个函数有剩余参数时，它被当做无限个可选参数。</p>
<p>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些<code>undefinded</code>。</p>
<p>有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeLater</span>(<span class="params">args: <span class="built_in">any</span>[], callback: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... Invoke callback with &#x27;args&#x27; ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span></span><br><span class="line">invokeLater([<span class="number">1</span>, <span class="number">2</span>], <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">console</span>.log(x + <span class="string">&quot;, &quot;</span> + y));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Confusing (x and y are actually required) and undiscoverable</span></span><br><span class="line">invokeLater([<span class="number">1</span>, <span class="number">2</span>], <span class="function">(<span class="params">x?, y?</span>) =&gt;</span> <span class="built_in">console</span>.log(x + <span class="string">&quot;, &quot;</span> + y));</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。比如，</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Status &#123;</span><br><span class="line">  Ready,</span><br><span class="line">  Waiting,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Blue,</span><br><span class="line">  Green,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> status = Status.Ready;</span><br><span class="line">status = Color.Green; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  feet: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, numFeet: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Size &#123;</span><br><span class="line">  feet: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">numFeet: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal;</span><br><span class="line"><span class="keyword">let</span> s: Size;</span><br><span class="line"></span><br><span class="line">a = s; <span class="comment">// OK</span></span><br><span class="line">s = a; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h3 id="类的私有成员和受保护成员"><a href="#类的私有成员和受保护成员" class="headerlink" title="类的私有成员和受保护成员"></a>类的私有成员和受保护成员</h3><p>类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>因为 TypeScript 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如，</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// OK, because y matches structure of x</span></span><br></pre></td></tr></table></figure>

<p>上面代码里，<code>x</code>和<code>y</code>是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// Error, because x and y are not compatible</span></span><br></pre></td></tr></table></figure>

<p>在这里，泛型类型在使用时就好比不是一个泛型类型。</p>
<p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成<code>any</code>比较。 然后用结果类型进行比较，就像上面第一个例子。</p>
<p>比如，</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> identity = <span class="function"><span class="keyword">function</span> &lt;<span class="title">T</span>&gt;(<span class="params">x: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reverse = <span class="function"><span class="keyword">function</span> &lt;<span class="title">U</span>&gt;(<span class="params">y: U</span>): <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">identity = reverse; <span class="comment">// OK, because (x: any) =&gt; any matches (y: any) =&gt; any</span></span><br></pre></td></tr></table></figure>

<h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="子类型与赋值"><a href="#子类型与赋值" class="headerlink" title="子类型与赋值"></a>子类型与赋值</h3><p>目前为止，我们使用了“兼容性”，它在语言规范里没有定义。 在 TypeScript 里，有两种兼容性：子类型和赋值。 它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和<code>any</code>来回赋值，以及<code>enum</code>和对应数字值之间的来回赋值。</p>
<p>语言里的不同地方分别使用了它们之中的机制。 实际上，类型兼容性是由赋值兼容性来控制的，即使在<code>implements</code>和<code>extends</code>语句也不例外。</p>
<p>更多信息，请参阅<a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md">TypeScript 语言规范</a>.</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/09/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<p>单例模式是一种常用的模式，有一些对象我们往往只需要一个比如，线程池，全局缓存，浏览器中的 window 对象等，在 JavaScript 开发中，单例模式的用途同样非常广泛，试想一下，当我们点击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗只会被创建一次，那么这个登录浮窗就是和使用单例模式来创建</p>
<h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><p>要实现一个单例模式其实并不复杂，无非是用一个变量来标指当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Stingleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Stingleton.prototype.instance = <span class="literal">null</span>;</span><br><span class="line">Stingleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">Stingleton.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.instance)&#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = <span class="keyword">new</span> Stingleton(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = Stingleton.getInstance(<span class="string">&quot;sven1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = Stingleton.getInstance(<span class="string">&quot;sven2&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a === b)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span>  instance = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">           instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>我们通过<code>Singleton.getInstance</code>来获取 <code>Singleton</code> 类的唯一对象，这种方式相对简单，但有一个问题，就是为了增加这个类的‘不透明性’，<code>Singleton</code>类的使用者必须知道这是一个单例类，根以往通过<code>new XXX</code>的方式来获取对象不同，这里偏要使用 <code>Singleton.getInstance </code>来获取对象。</p>
<p>接下来顺便进行一些小测试，来证明这个单例类是可以信赖的；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = Singleton.getInstance(<span class="string">&#x27;sven1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> b = Singleton.getInstance(<span class="string">&#x27;sven2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b)</span><br></pre></td></tr></table></figure>

<p>虽然现在已经完成了一个单例模式的编写，但这段单例模式代码的意义并不大，从下一节开始，我们将一步步编写出更好的单例模式</p>
<h3 id="透明的单例模式"><a href="#透明的单例模式" class="headerlink" title="透明的单例模式"></a>透明的单例模式</h3><p>我们现在的目标是实现一个透明的单例类，用户从这个类中创建对象的时候，可以像使用其他任何普通类一样，在下面的例子中，我们将使用<code>CreateDiv</code>单例类，它的作用是负责在页面中创建唯一的<code>div</code>节点，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 判单之前是否创建过/ 如果有则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (instances) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.html = html;</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">        instance = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(instance)</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;;</span><br><span class="line">    CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">        div.innerHTML = <span class="built_in">this</span>.html;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> CreateDiv;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> CreateDiv(<span class="string">&quot;sven1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> CreateDiv(<span class="string">&quot;sven2&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a === b)</span><br></pre></td></tr></table></figure>

<p>虽然现在已经完成了一个透明单例类的编写，但它同样有一些缺点。为了把<code>instance</code>封装起来，这增加了一些程序的复杂性，阅读起来不是很舒服</p>
<p>观察现在的<code>Singleton</code>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判单之前是否创建过/ 如果有则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.html = html;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">    instance = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(instance)</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码中，<code>CreateDiv</code> 的构造函数实际上负责了两件事情，第一是创建对象和执行初始化 init 方法，第二是保障只有一个对象，虽然我们目前还没有接触过”单一职责”的概念，但可以明确的是，这是一种不好的做法，至少这个构造函数看起来很奇怪。假设我们某天需要利用这个类，在页面上创建千千万万的 div，即要让这个类从一个单例类变成一个普通的可以生产多个实例的类，那我们必须改写 CreateDiv 的构造函数，把控制创建 唯一对象的那一段去掉，这种修改会给我们带来不必要的麻烦</p>
<h3 id="使用代理实现单例模式"><a href="#使用代理实现单例模式" class="headerlink" title="使用代理实现单例模式"></a>使用代理实现单例模式</h3><p>现在我们通过引入代理类的方式，来解决上面提到的问题</p>
<p>我们依然使用上面的代码， 首先在<code>CreateDiv</code>的构造函数中把负责管理单例的代码移除出去，使他成为一个普通的创建 div 的类，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.html=html;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    div.innerHTML = <span class="built_in">this</span>.html;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来引入代理类 ProxySingletonCreateDiv;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ProxySingletonCreateDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;;</span><br><span class="line">    <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> CreateDiv(html);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ProxySingletonCreateDiv(<span class="string">&quot;sven1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ProxySingletonCreateDiv(<span class="string">&quot;sven2&quot;</span>);</span><br><span class="line">alert(a === b)</span><br></pre></td></tr></table></figure>

<p>通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们把负责管理单例的逻辑移到了代理类 ProxySingletonCreateDiv 中，这样一来，CreateDiv 就变成了一个普普通通的类，它跟 proxySingletonCreateDiv 组合起来就可以达到单例模式的效果</p>
<p>本例是缓存代理的应用之之一，在第六章中，我们继续了解代理带来的好处</p>
<h3 id="JavaScript-中的单例模式"><a href="#JavaScript-中的单例模式" class="headerlink" title="JavaScript 中的单例模式"></a>JavaScript 中的单例模式</h3><p>前面提到的几种单例模式的实现，更多的是接近传统面向对象语言中的实现，单例对象从“类”中创建而来，在以类为中心的语言中，这是很自然的做法，比如在 java 中，如果需要某个对象，那就必须先定义类，对象总是从类中创建而来</p>
<p>但 JavaScript 其实是一门无类（class-free）语言，也正因为如此，生搬代理模式的概念并无意义，在 JavaScript 中创建对象的方法非常简单，既然我们只需要一个“唯一”的对象，为什么要为它先创建一个“类”呢，这无异于穿棉衣洗澡，传统的单例模式实现在 JavaScript 中并不适用，</p>
<p>单例模式的核心是确保只有一个实例，并提供全局访问。</p>
<p>全局变量不是单例模式，但在 JavaScript 开发中，我们经常会把全局变量当成单例来使用例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>当用这种方式创建对象 a 的时候，对象 a 确实是独一无二的，如果 a 变量声明在全局作用域下，则我们可以在代码中的任何位置使用这个变量，JavaScript 中的变量也很容易被不小心覆盖，相信每个 JavaScript 程序员都曾经经历过变量冲突的痛苦，就像上面的对象 var a = {}; 随时有可能被被人覆盖</p>
<p>作为普通开发者，我们有必要尽量减少使用全局变量的使用，即使需要，也要把它的污染降低到最小，一下几种方式可以相对降低全局变量带来的命名污染</p>
<p>使用命名空间</p>
<p>适当的使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量最简单的方法依然是对象字面的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> namespace1 = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把<code>a</code>和<code>b</code>都定义为 <code>namespace1</code> 的属性，这样就可以减少变量和全局作用域打交道的机会，另外我们还可以动态的创建命名空间， 代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> myApp = &#123;&#125;;</span><br><span class="line">myApp.namespace = funcqqtion (name) &#123;</span><br><span class="line">  <span class="keyword">let</span> parts = name.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> current = myApp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> parts) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!current[parts[i]]) &#123;</span><br><span class="line">      current[parts[i]] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current[parts[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myApp.namespace(<span class="string">&quot;event&quot;</span>);</span><br><span class="line">myApp.namespace(<span class="string">&quot;dom.style&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myApp);</span><br></pre></td></tr></table></figure>

<p>也可以使用 闭包封装私有变量这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _name = <span class="string">&#x27;sven&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> _age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _name + _age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>我们使用下划线来约定私有变量，<code>_name</code>和<code>_age</code> 它们被封装到闭包产生的作用域里，外部都是访问不到这两个变量的，这就避免了对全局的命令污染</p>
<h3 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h3><p>前面我们了解了单例模式的一些实现方法，本节我们来了惰性单例。惰性单例指的是在需要的时候才创建对象的实例，惰性单例是单例模式的重点，这种技术在实际开发中非常有用， 有用程度可能超出我们的想像，实际上在本章开头就使用过这种技术了，<code>instance</code>实例对象总是在我们调用<code>Singleton.getInstance</code>的时候才被创建，而不是在页面加载好的时候就创建，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(name)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>不过这是基于“类”的单例模式，前面说过，基于“类”的单例模式在 JavaScript 中并不适用，下面我们将以 webQQ 的登录浮窗为例，介绍与全局变量结合实现惰性的单例</p>
<p>假设我们设计 webqq 的开发人员，当点击导航上的 qq 头像的时候，会出现一个登录弹窗，很明显这个浮窗在页面中总是唯一的，不可能出现同时存在两个登录弹窗的情况</p>
<p>第一种解决方案是在页面加载完成的时候，便创建好这个 div 浮窗，这个浮窗一开始肯定是隐藏的，只有当用户点击登录的时候他才会出现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> loginLayer = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="javascript">      div.innerHTML = <span class="string">&quot;我是登录弹窗&quot;</span>;</span></span><br><span class="line"><span class="javascript">      div.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.appendchild(div);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div;</span></span><br><span class="line">    &#125;)();</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      loginLayer.style = <span class="string">&quot;block&quot;</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方式有一个问题，也许我们进入 qq 这是为了玩玩游戏或者看看天气，根本不需要进行登录操作，因为登录弹窗总是一开始就被创建好，那么可能白白浪费一些 dom 节点现在我们改写一下代码，使用户点击登录按钮的时候才开始创建该弹窗</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="javascript">      div.innerHTML = <span class="string">&quot;我是登录弹窗&quot;</span>;</span></span><br><span class="line"><span class="javascript">      div.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.appendchild(div);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div;</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> loginLayer = createLoginLayer();</span></span><br><span class="line"><span class="javascript">      loginLayer.style = <span class="string">&quot;block&quot;</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在我们达到了惰性的目的，但是也失去了单例的效果，当我们每次点击登录按钮的时候，都会创建一个新的登录浮窗 div 虽然我们可以点击浮窗上的关闭按钮，把这个节点从页面中删除掉，但这样频繁的创建和删除节点明显是不合理的也是不必要的</p>
<p>也许你已经想到了，我们可以用一个变量来判断是否已经创建过登录浮窗，这也是本节第一段代码中的做法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createLoginLayer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!div)&#123;</span><br><span class="line">            div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">            div.innerHTML = <span class="string">&#x27;我是登录弹窗&#x27;</span></span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> div</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loginLayer = createLoginLayer()</span><br><span class="line">    loginLayer.style = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通用单例模式"><a href="#通用单例模式" class="headerlink" title="通用单例模式"></a>通用单例模式</h3><p>上一节我们完成了一个可用的惰性单例，但是我们发现它还有如下一些问题，</p>
<ul>
<li>这段代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在 createLoginLayer 对象内部</li>
<li>如果我们下此需要创建页面中唯一的 iframe，或者 script 标签，用来跨域请求数据，就必须如法炮制，把 createLoginLayer 函数几乎照抄一遍</li>
</ul>
<p>我们现在需要把不变的部分隔离出来，先不考虑创建一个 div 和创建一个 iframe 有多少差异，管理单例的逻辑其实是可以完全抽离出来的，这个逻辑始终是一样的，用一个变量来标志是否创建过对象，如果是，则在下次直接返回这个已经创建好的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj;</span><br><span class="line"><span class="keyword">if</span>(!obj)&#123;</span><br><span class="line">    obj = xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们把管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在 getSingle 函数内部，创建对象的方法当成参数动态传入到 getSingle 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来将用于创建登录浮窗的方法用参数形式传入到 getSingle 函数中，我们不仅可以传入 createLoginLayer 还可以传入其他 createScript createIframe createXhr 等，之后再让 getSingle 返回一个新的函数，并且用变量 result 来保存 fn 的计算结果，result 变量因为身在闭包中，它永远不会被销毁，在将来的请求中，如果 result 已经被赋值了，那么它将返回这个值，代码如下，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    div.innerHTML = <span class="string">&quot;我是登录弹窗&quot;</span>;</span><br><span class="line">    div.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.appendchild(div)</span><br><span class="line">    <span class="keyword">return</span> div</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> createSingleLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loginLayer = createSingleLoginLayer()</span><br><span class="line">    loginLayer.style = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们再试试创建唯一 iframe 用于动态加载三方页面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createIframe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">    <span class="built_in">document</span>.appendchild(iframe)</span><br><span class="line">    <span class="keyword">return</span> iframe</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loginLayer = createIframe();</span><br><span class="line">    loginLayer.src = <span class="string">&#x27;http://www.baidu.com&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们把创建实例对象的职责和管理单例的职责分别放置在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能，看起来是一件挺奇妙的事情这种单例模式的用途远不止创建对象，比如我们通常渲染完页面中的一个列表之后，接下来要给这个列表绑定 click 事件，如果是通过 ajax 动态往列表里加数据，在使用事件代理的前提下 click 事件实际上只需要在第一次列表渲染的时候被便规定一次，但是我们不想去判断当前是否第一次渲染，如果借助于 jquery 我们通常选择给节点绑定 one 事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;div&quot;</span>).one(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;click&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染列表&quot;</span>)</span><br><span class="line">    bindEvent()</span><br><span class="line">&#125;</span><br><span class="line">render()</span><br><span class="line">render()</span><br><span class="line">render()</span><br></pre></td></tr></table></figure>

<p>那如果使用 getSingle 函数呢，如何达到一样的效果，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bindEvent = getSingle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染列表&quot;</span>)</span><br><span class="line">    bindEvent()</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br><span class="line">render();</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>单例模式是我们学习的第一个模式，我们先学习了传统的单例模式实现，也了解到因为语言的差异性，有更适合的方法在 JavaScript 中创建单例，第一章还提到了代理模式和单一职责原则，后面我们会对他们进行更加详细的介绍</p>
<p>在 getSingle 函数中，实际上也提到了闭包和高阶函数的概念，单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个，更奇妙的是，创建对象和管理单例的职责被划分到两个不同的方法中，这两个方法组合起来才具有单例模式的威力</p>
]]></content>
      <categories>
        <category>JavaScript设计模式与开发实践</category>
      </categories>
  </entry>
  <entry>
    <title>模块</title>
    <url>/2020/09/20/%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>从 ECMAScript 2015 开始，JavaScript 引入了模块的概念。TypeScript 也沿用这个概念。</p>
<p>模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用<a href="https://www.tslang.cn/docs/handbook/modules.html#export"><code>export</code>形式</a>之一导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 <a href="https://www.tslang.cn/docs/handbook/modules.html#import"><code>import</code>形式</a>之一。</p>
<p>模块是自声明的；两个模块之间的关系是通过在文件级别上使用 imports 和 exports 建立的。</p>
<p>模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 大家最熟知的 JavaScript 模块加载器是服务于 Node.js 的 <a href="https://en.wikipedia.org/wiki/CommonJS">CommonJS</a>和服务于 Web 应用的<a href="http://requirejs.org/">Require.js</a>。</p>
<p>TypeScript 与 ECMAScript 2015 一样，任何包含顶级<code>import</code>或者<code>export</code>的文件都被当成一个模块。相反地，如果一个文件不带有顶级的<code>import</code>或者<code>export</code>声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。</p>
<a id="more"></a>

<h2 id="导出-export"><a href="#导出-export" class="headerlink" title="导出(export)"></a>导出(export)</h2><h3 id="导出声明"><a href="#导出声明" class="headerlink" title="导出声明"></a>导出声明</h3><p>任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加<code>export</code>关键字来导出。</p>
<p>Validation.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导出语句"><a href="#导出语句" class="headerlink" title="导出语句"></a>导出语句</h3><p>导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> mainValidator &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="重新导出"><a href="#重新导出" class="headerlink" title="重新导出"></a>重新导出</h3><p>我们经常会去扩展其它模块，并且只导出那个模块的部分内容。 重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。</p>
<p>ParseIntBasedZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ParseIntBasedZipCodeValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; <span class="built_in">parseInt</span>(s).toString() === s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出原先的验证器但做了重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> RegExpBasedZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>或者一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：<code>export * from &quot;module&quot;</code>。</p>
<p>AllValidators.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./StringValidator&quot;</span>; <span class="comment">// exports interface StringValidator</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./LettersOnlyValidator&quot;</span>; <span class="comment">// exports class LettersOnlyValidator</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>; <span class="comment">// exports class ZipCodeValidator</span></span><br></pre></td></tr></table></figure>

<h2 id="导入-import"><a href="#导入-import" class="headerlink" title="导入(import)"></a>导入(import)</h2><p>模块的导入操作与导出一样简单。 可以使用以下 <code>import</code>形式之一来导入其它模块中的导出内容。</p>
<h3 id="导入一个模块中的某个导出内容"><a href="#导入一个模块中的某个导出内容" class="headerlink" title="导入一个模块中的某个导出内容"></a>导入一个模块中的某个导出内容</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> ZipCodeValidator();</span><br></pre></td></tr></table></figure>

<p>可以对导入内容重命名</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> ZCV &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> ZCV();</span><br></pre></td></tr></table></figure>

<h3 id="将整个模块导入到一个变量，并通过它来访问模块的导出部分"><a href="#将整个模块导入到一个变量，并通过它来访问模块的导出部分" class="headerlink" title="将整个模块导入到一个变量，并通过它来访问模块的导出部分"></a>将整个模块导入到一个变量，并通过它来访问模块的导出部分</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> validator <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> validator.ZipCodeValidator();</span><br></pre></td></tr></table></figure>

<h3 id="具有副作用的导入模块"><a href="#具有副作用的导入模块" class="headerlink" title="具有副作用的导入模块"></a>具有副作用的导入模块</h3><p>尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。 这些模块可能没有任何的导出或用户根本就不关注它的导出。 使用下面的方法来导入这类模块：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./my-module.js&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h2><p>每个模块都可以有一个<code>default</code>导出。 默认导出使用 <code>default</code>关键字标记；并且一个模块只能够有一个<code>default</code>导出。 需要使用一种特殊的导入形式来导入 <code>default</code>导出。</p>
<p><code>default</code>导出十分便利。 比如，像<code>JQuery</code>这样的类库可能有一个默认导出 <code>jQuery</code>或<code>$</code>，并且我们基本上也会使用同样的名字<code>jQuery</code>或<code>$</code>导出<code>JQuery</code>。</p>
<p>JQuery.d.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> $: JQuery;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> $;</span><br></pre></td></tr></table></figure>

<p>App.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;JQuery&quot;</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;button.continue&quot;</span>).html(<span class="string">&quot;Next Step...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。</p>
<p>ZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> ZipCodeValidator &#123;</span><br><span class="line">  <span class="keyword">static</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; ZipCodeValidator.numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> validator <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> validator();</span><br></pre></td></tr></table></figure>

<p>或者</p>
<p>StaticZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">s: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> validate <span class="keyword">from</span> <span class="string">&quot;./StaticZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;98052&quot;</span>, <span class="string">&quot;101&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use function validate</span></span><br><span class="line">strings.forEach(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`&quot;<span class="subst">$&#123;s&#125;</span>&quot; <span class="subst">$&#123;validate(s) ? <span class="string">&quot; matches&quot;</span> : <span class="string">&quot; does not match&quot;</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>default</code>导出也可以是一个值</p>
<p>OneTwoThree.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Log.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> num <span class="keyword">from</span> <span class="string">&quot;./OneTwoThree&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="export-和-import-require"><a href="#export-和-import-require" class="headerlink" title="export = 和 import = require()"></a>export = 和 import = require()</h2><p>CommonJS 和 AMD 的环境里都有一个<code>exports</code>变量，这个变量包含了一个模块的所有导出内容。</p>
<p>CommonJS 和 AMD 的<code>exports</code>都可以被赋值为一个对象，这种情况下其作用就类似于 es6 语法里的默认导出，即 <code>export default</code>语法了。虽然作用相似，但是 <code>export default</code> 语法并不能兼容 CommonJS 和 AMD 的<code>exports</code>。</p>
<p>为了支持 CommonJS 和 AMD 的<code>exports</code>, TypeScript 提供了<code>export =</code>语法。</p>
<p><code>export =</code>语法定义一个模块的导出对象。 这里的对象一词指的是类，接口，命名空间，函数或枚举。</p>
<p>若使用<code>export =</code>导出一个模块，则必须使用 TypeScript 的特定语法<code>import module = require(&quot;module&quot;)</code>来导入此模块。</p>
<p>ZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="keyword">class</span> ZipCodeValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> = ZipCodeValidator;</span><br></pre></td></tr></table></figure>

<p>Test.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zip = <span class="built_in">require</span>(<span class="string">&quot;./ZipCodeValidator&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;98052&quot;</span>, <span class="string">&quot;101&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validator = <span class="keyword">new</span> zip();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line">strings.forEach(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`&quot;<span class="subst">$&#123;s&#125;</span>&quot; - <span class="subst">$&#123;validator.isAcceptable(s) ? <span class="string">&quot;matches&quot;</span> : <span class="string">&quot;does not match&quot;</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="生成模块代码"><a href="#生成模块代码" class="headerlink" title="生成模块代码"></a>生成模块代码</h2><p>根据编译时指定的模块目标参数，编译器会生成相应的供 Node.js，CommonJS，Require.js，AMD，UMD，SystemJS 或 ES6 模块加载系统使用的代码。 想要了解生成代码中 <code>define</code>，<code>require</code> 和 <code>register</code>的意义，请参考相应模块加载器的文档。</p>
<p>下面的例子说明了导入导出语句里使用的名字是怎么转换为相应的模块加载器代码的。</p>
<p>SimpleModule.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> m = <span class="built_in">require</span>(<span class="string">&quot;mod&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> t = m.something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>AMD / RequireJS SimpleModule.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>, <span class="string">&quot;./mod&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, mod_1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.t = mod_1.something + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>CommonJS / Node SimpleModule.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mod_1 = <span class="built_in">require</span>(<span class="string">&quot;./mod&quot;</span>);</span><br><span class="line"><span class="built_in">exports</span>.t = mod_1.something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>UMD SimpleModule.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> v = factory(<span class="built_in">require</span>, <span class="built_in">exports</span>);</span><br><span class="line">    <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) <span class="built_in">module</span>.exports = v;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    define([<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>, <span class="string">&quot;./mod&quot;</span>], factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mod_1 = <span class="built_in">require</span>(<span class="string">&quot;./mod&quot;</span>);</span><br><span class="line">  <span class="built_in">exports</span>.t = mod_1.something + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>System SimpleModule.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">System.register([<span class="string">&quot;./mod&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">exports_1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mod_1;</span><br><span class="line">  <span class="keyword">let</span> t;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setters: [</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">mod_1_1</span>) </span>&#123;</span><br><span class="line">        mod_1 = mod_1_1;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      exports_1(<span class="string">&quot;t&quot;</span>, (t = mod_1.something + <span class="number">1</span>));</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>ES6 SimpleModule.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&quot;./mod&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> t = something + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。</p>
<p>为了编译，我们必需要在命令行上指定一个模块目标。对于 Node.js 来说，使用<code>--module commonjs</code>； 对于 Require.js 来说，使用<code>--module amd</code>。比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tsc --module commonjs Test.ts</span><br></pre></td></tr></table></figure>

<p>编译完成后，每个模块会生成一个单独的<code>.js</code>文件。 好比使用了 reference 标签，编译器会根据 <code>import</code>语句编译相应的文件。</p>
<p>Validation.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LettersOnlyValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StringValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./Validation&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> lettersRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StringValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./Validation&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StringValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./Validation&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LettersOnlyValidator &#125; <span class="keyword">from</span> <span class="string">&quot;./LettersOnlyValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;98052&quot;</span>, <span class="string">&quot;101&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: StringValidator &#125; = &#123;&#125;;</span><br><span class="line">validators[<span class="string">&quot;ZIP code&quot;</span>] = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">validators[<span class="string">&quot;Letters only&quot;</span>] = <span class="keyword">new</span> LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line">strings.forEach(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`&quot;<span class="subst">$&#123;s&#125;</span>&quot; - <span class="subst">$&#123;validators[name].isAcceptable(s) ? <span class="string">&quot;matches&quot;</span> : <span class="string">&quot;does not match&quot;</span>&#125;</span> <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="可选的模块加载和其它高级加载场景"><a href="#可选的模块加载和其它高级加载场景" class="headerlink" title="可选的模块加载和其它高级加载场景"></a>可选的模块加载和其它高级加载场景</h2><p>有时候，你只想在某种条件下才加载某个模块。 在 TypeScript 里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且可以保证类型完全。</p>
<p>编译器会检测是否每个模块都会在生成的 JavaScript 中用到。 如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 <code>require</code>这个模块的代码。 省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。</p>
<p>这种模式的核心是<code>import id = require(&quot;...&quot;)</code>语句可以让我们访问模块导出的类型。 模块加载器会被动态调用（通过 <code>require</code>），就像下面<code>if</code>代码块里那样。 它利用了省略引用的优化，所以模块只在被需要时加载。 为了让这个模块工作，一定要注意 <code>import</code>定义的标识符只能在表示类型处使用（不能在会转换成 JavaScript 的地方）。</p>
<p>为了确保类型安全性，我们可以使用<code>typeof</code>关键字。 <code>typeof</code>关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。</p>
<p>示例：Node.js 里的动态模块加载</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleName: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> Zip &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">  <span class="keyword">let</span> ZipCodeValidator: <span class="keyword">typeof</span> Zip = <span class="built_in">require</span>(<span class="string">&quot;./ZipCodeValidator&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> validator = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">  <span class="keyword">if</span> (validator.isAcceptable(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：require.js 里的动态模块加载</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleNames: <span class="built_in">string</span>[], onLoad: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Zip <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&quot;./ZipCodeValidator&quot;</span>], <span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> validator = <span class="keyword">new</span> ZipCodeValidator.ZipCodeValidator();</span><br><span class="line">    <span class="keyword">if</span> (validator.isAcceptable(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：System.js 里的动态模块加载</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> System: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> Zip &#125; <span class="keyword">from</span> <span class="string">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needZipValidation) &#123;</span><br><span class="line">  System.import(<span class="string">&quot;./ZipCodeValidator&quot;</span>).then(<span class="function">(<span class="params">ZipCodeValidator: <span class="keyword">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">new</span> ZipCodeValidator();</span><br><span class="line">    <span class="keyword">if</span> (x.isAcceptable(<span class="string">&quot;...&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用其它的-JavaScript-库"><a href="#使用其它的-JavaScript-库" class="headerlink" title="使用其它的 JavaScript 库"></a>使用其它的 JavaScript 库</h2><p>要想描述非 TypeScript 编写的类库的类型，我们需要声明类库所暴露出的 API。</p>
<p>我们叫它声明因为它不是“外部程序”的具体实现。 它们通常是在 <code>.d.ts</code>文件里定义的。 如果你熟悉 C/C++，你可以把它们当做 <code>.h</code>文件。 让我们看一些例子。</p>
<h3 id="外部模块"><a href="#外部模块" class="headerlink" title="外部模块"></a>外部模块</h3><p>在 Node.js 里大部分工作是通过加载一个或多个模块实现的。 我们可以使用顶级的 <code>export</code>声明来为每个模块都定义一个<code>.d.ts</code>文件，但最好还是写在一个大的<code>.d.ts</code>文件里。 我们使用与构造一个外部命名空间相似的方法，但是这里使用 <code>module</code>关键字并且把名字用引号括起来，方便之后<code>import</code>。 例如：</p>
<p>node.d.ts (simplified excerpt)</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;url&quot; &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Url &#123;</span><br><span class="line">    protocol?: <span class="built_in">string</span>;</span><br><span class="line">    hostname?: <span class="built_in">string</span>;</span><br><span class="line">    pathname?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">urlStr: <span class="built_in">string</span>, parseQueryString?, slashesDenoteHost?</span>): <span class="title">Url</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;path&quot; &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">p: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">...paths: <span class="built_in">any</span>[]</span>): <span class="title">string</span></span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> sep: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以<code>/// &lt;reference&gt;</code> <code>node.d.ts</code>并且使用<code>import url = require(&quot;url&quot;);</code>或<code>import * as URL from &quot;url&quot;</code>加载模块。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> URL <span class="keyword">from</span> <span class="string">&quot;url&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myUrl = URL.parse(<span class="string">&quot;http://www.typescriptlang.org&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="外部模块简写"><a href="#外部模块简写" class="headerlink" title="外部模块简写"></a>外部模块简写</h3><p>假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。</p>
<p>declarations.d.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;hot-new-<span class="keyword">module</span>&quot;;</span><br></pre></td></tr></table></figure>

<p>简写模块里所有导出的类型将是<code>any</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> x, &#123; y &#125; <span class="keyword">from</span> <span class="string">&quot;hot-new-module&quot;</span>;</span><br><span class="line">x(y);</span><br></pre></td></tr></table></figure>

<h3 id="模块声明通配符"><a href="#模块声明通配符" class="headerlink" title="模块声明通配符"></a>模块声明通配符</h3><p>某些模块加载器如<a href="https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax">SystemJS</a> 和 <a href="https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md">AMD</a>支持导入非 JavaScript 内容。 它们通常会使用一个前缀或后缀来表示特殊的加载语法。 模块声明通配符可以用来表示这些情况。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;*!text&quot; &#123;</span><br><span class="line">  <span class="keyword">const</span> content: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Some do it the other way around.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> &quot;json!*&quot; &#123;</span><br><span class="line">  <span class="keyword">const</span> value: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你可以就导入匹配<code>&quot;*!text&quot;</code>或<code>&quot;json!*&quot;</code>的内容了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fileContent <span class="keyword">from</span> <span class="string">&quot;./xyz.txt!text&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&quot;json!http://example.com/data.json&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data, fileContent);</span><br></pre></td></tr></table></figure>

<h3 id="UMD-模块"><a href="#UMD-模块" class="headerlink" title="UMD 模块"></a>UMD 模块</h3><p>有些模块被设计成兼容多个模块加载器，或者不使用模块加载器（全局变量）。 它们以 <a href="https://github.com/umdjs/umd">UMD</a>模块为代表。 这些库可以通过导入的形式或全局变量的形式访问。 例如：</p>
<p>math-lib.d.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> mathLib;</span><br></pre></td></tr></table></figure>

<p>之后，这个库可以在某个模块里通过导入来使用：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isPrime &#125; <span class="keyword">from</span> <span class="string">&quot;math-lib&quot;</span>;</span><br><span class="line">isPrime(<span class="number">2</span>);</span><br><span class="line">mathLib.isPrime(<span class="number">2</span>); <span class="comment">// 错误: 不能在模块内使用全局定义。</span></span><br></pre></td></tr></table></figure>

<p>它同样可以通过全局变量的形式使用，但只能在某个脚本（指不带有模块导入或导出的脚本文件）里。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">mathLib.isPrime(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="创建模块结构指导"><a href="#创建模块结构指导" class="headerlink" title="创建模块结构指导"></a>创建模块结构指导</h2><h3 id="尽可能地在顶层导出"><a href="#尽可能地在顶层导出" class="headerlink" title="尽可能地在顶层导出"></a>尽可能地在顶层导出</h3><p>用户应该更容易地使用你模块导出的内容。 嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。</p>
<p>从你的模块中导出一个命名空间就是一个增加嵌套的例子。 虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。 这对用户来说是很不便的并且通常是多余的。</p>
<p>导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。 除非它能方便表述或便于清晰使用，否则请考虑直接导出一个辅助方法。</p>
<h3 id="如果仅导出单个-class-或-function，使用-export-default"><a href="#如果仅导出单个-class-或-function，使用-export-default" class="headerlink" title="如果仅导出单个 class 或 function，使用 export default"></a>如果仅导出单个 <code>class</code> 或 <code>function</code>，使用 <code>export default</code></h3><p>就像“在顶层上导出”帮助减少用户使用的难度，一个默认的导出也能起到这个效果。 如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。 这会令模块的导入和使用变得些许简单。 比如：</p>
<p>MyClass.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> SomeType &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyFunc.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;thing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consumer.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> t <span class="keyword">from</span> <span class="string">&quot;./MyClass&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> f <span class="keyword">from</span> <span class="string">&quot;./MyFunc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> t();</span><br><span class="line"><span class="built_in">console</span>.log(f());</span><br></pre></td></tr></table></figure>

<p>对用户来说这是最理想的。他们可以随意命名导入模块的类型（本例为<code>t</code>）并且不需要多余的（.）来找到相关对象。</p>
<h3 id="如果要导出多个对象，把它们放在顶层里导出"><a href="#如果要导出多个对象，把它们放在顶层里导出" class="headerlink" title="如果要导出多个对象，把它们放在顶层里导出"></a>如果要导出多个对象，把它们放在顶层里导出</h3><p>MyThings.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> SomeType &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">someFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相反地，当导入的时候：</p>
<h3 id="明确地列出导入的名字"><a href="#明确地列出导入的名字" class="headerlink" title="明确地列出导入的名字"></a>明确地列出导入的名字</h3><p>Consumer.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; SomeType, someFunc &#125; <span class="keyword">from</span> <span class="string">&quot;./MyThings&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> SomeType();</span><br><span class="line"><span class="keyword">let</span> y = someFunc();</span><br></pre></td></tr></table></figure>

<h3 id="使用命名空间导入模式当你要导出大量内容的时候"><a href="#使用命名空间导入模式当你要导出大量内容的时候" class="headerlink" title="使用命名空间导入模式当你要导出大量内容的时候"></a>使用命名空间导入模式当你要导出大量内容的时候</h3><p>MyLargeModule.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Dog &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Cat &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Tree &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Flower &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Consumer.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myLargeModule <span class="keyword">from</span> <span class="string">&quot;./MyLargeModule.ts&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> myLargeModule.Dog();</span><br></pre></td></tr></table></figure>

<h3 id="使用重新导出进行扩展"><a href="#使用重新导出进行扩展" class="headerlink" title="使用重新导出进行扩展"></a>使用重新导出进行扩展</h3><p>你可能经常需要去扩展一个模块的功能。 JS 里常用的一个模式是 JQuery 那样去扩展原对象。 如我们之前提到的，模块不会像全局命名空间对象那样去 _合并_。 推荐的方案是 <em>不要</em>去改变原来的对象，而是导出一个新的实体来提供新的功能。</p>
<p>假设<code>Calculator.ts</code>模块里定义了一个简单的计算器实现。 这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。</p>
<p>Calculator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Calculator &#123;</span><br><span class="line">  <span class="keyword">private</span> current = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> memory = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> operator: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> processDigit(digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (digit &gt;= <span class="string">&quot;0&quot;</span> &amp;&amp; digit &lt;= <span class="string">&quot;9&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> currentValue * <span class="number">10</span> + (digit.charCodeAt(<span class="number">0</span>) - <span class="string">&quot;0&quot;</span>.charCodeAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> processOperator(operator: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>].indexOf(operator) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> operator;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> evaluateOperator(operator: <span class="built_in">string</span>, left: <span class="built_in">number</span>, right: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.operator) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left - right;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left * right;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> left / right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> evaluate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.operator) &#123;</span><br><span class="line">      <span class="built_in">this</span>.memory = <span class="built_in">this</span>.evaluateOperator(<span class="built_in">this</span>.operator, <span class="built_in">this</span>.memory, <span class="built_in">this</span>.current);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.memory = <span class="built_in">this</span>.current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> handleChar(char: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">&quot;=&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.evaluate();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="built_in">this</span>.processDigit(char, <span class="built_in">this</span>.current);</span><br><span class="line">      <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.current = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="built_in">this</span>.processOperator(char);</span><br><span class="line">        <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.evaluate();</span><br><span class="line">          <span class="built_in">this</span>.operator = value;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Unsupported input: &#x27;<span class="subst">$&#123;char&#125;</span>&#x27;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getResult() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.memory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">c: Calculator, input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">    c.handleChar(input[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`result of &#x27;<span class="subst">$&#123;input&#125;</span>&#x27; is &#x27;<span class="subst">$&#123;c.getResult()&#125;</span>&#x27;`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面使用导出的<code>test</code>函数来测试计算器。</p>
<p>TestCalculator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Calculator, test &#125; <span class="keyword">from</span> <span class="string">&quot;./Calculator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Calculator();</span><br><span class="line">test(c, <span class="string">&quot;1+2*33/11=&quot;</span>); <span class="comment">// prints 9</span></span><br></pre></td></tr></table></figure>

<p>现在扩展它，添加支持输入其它进制（十进制以外），让我们来创建<code>ProgrammerCalculator.ts</code>。</p>
<p>ProgrammerCalculator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Calculator &#125; <span class="keyword">from</span> <span class="string">&quot;./Calculator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ProgrammerCalculator <span class="keyword">extends</span> Calculator &#123;</span><br><span class="line">  <span class="keyword">static</span> digits = [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> base: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">const</span> maxBase = ProgrammerCalculator.digits.length;</span><br><span class="line">    <span class="keyword">if</span> (base &lt;= <span class="number">0</span> || base &gt; maxBase) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`base has to be within 0 to <span class="subst">$&#123;maxBase&#125;</span> inclusive.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> processDigit(digit: <span class="built_in">string</span>, currentValue: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ProgrammerCalculator.digits.indexOf(digit) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> currentValue * <span class="built_in">this</span>.base + ProgrammerCalculator.digits.indexOf(digit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Export the new extended calculator as Calculator</span></span><br><span class="line"><span class="keyword">export</span> &#123; ProgrammerCalculator <span class="keyword">as</span> Calculator &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also, export the helper function</span></span><br><span class="line"><span class="keyword">export</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">&quot;./Calculator&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>新的<code>ProgrammerCalculator</code>模块导出的 API 与原先的<code>Calculator</code>模块很相似，但却没有改变原模块里的对象。 下面是测试 ProgrammerCalculator 类的代码：</p>
<p>TestProgrammerCalculator.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Calculator, test &#125; <span class="keyword">from</span> <span class="string">&quot;./ProgrammerCalculator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Calculator(<span class="number">2</span>);</span><br><span class="line">test(c, <span class="string">&quot;001+010=&quot;</span>); <span class="comment">// prints 3</span></span><br></pre></td></tr></table></figure>

<h3 id="模块里不要使用命名空间"><a href="#模块里不要使用命名空间" class="headerlink" title="模块里不要使用命名空间"></a>模块里不要使用命名空间</h3><p>当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。 模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。 记住这点，命名空间在使用模块时几乎没什么价值。</p>
<p>在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型进行分组是很便利的。 例如，在 C#里，你会从 <code>System.Collections</code>里找到所有集合的类型。 通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。 然而，模块本身已经存在于文件系统之中，这是必须的。 我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。 我们可以创建 <code>/collections/generic/</code>文件夹，把相应模块放在这里面。</p>
<p>命名空间对解决全局作用域里命名冲突来说是很重要的。 比如，你可以有一个 <code>My.Application.Customer.AddForm</code>和<code>My.Application.Order.AddForm</code> – 两个类型的名字相同，但命名空间不同。 然而，这对于模块来说却不是一个问题。 在一个模块里，没有理由两个对象拥有同一个名字。 从模块的使用角度来说，使用者会挑出他们用来引用模块的名字，所以也没有理由发生重名的情况。</p>
<blockquote>
<p>更多关于模块和命名空间的资料查看<a href="https://www.tslang.cn/docs/handbook/namespaces-and-modules.html">命名空间和模块</a></p>
</blockquote>
<h3 id="危险信号"><a href="#危险信号" class="headerlink" title="危险信号"></a>危险信号</h3><p>以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间：</p>
<ul>
<li>文件的顶层声明是<code>export namespace Foo &#123; ... &#125;</code> （删除<code>Foo</code>并把所有内容向上层移动一层）</li>
<li>文件只有一个<code>export class</code>或<code>export function</code> （考虑使用<code>export default</code>）</li>
<li>多个文件的顶层具有同样的<code>export namespace Foo &#123;</code> （不要以为这些会合并到一个<code>Foo</code>中！）</li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
</search>
