<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写给亚瑟的一封信</title>
    <url>/2020/09/18/AletterToArthur/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=78171705&bvid=BV1TJ411i7u9&cid=133749242&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>&emsp;&emsp;我偶尔还是会在西部的荒野疾驰，去听听森林的鸟鸣，去和那该死的灰熊相扑，去拜访一下你以前的老友，少了你的西部，少了点狂野味道</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4280.jpg" width=100%/>

<p>&emsp;&emsp;以前和你疾驰在西部的时候那得多狂野，在瓦伦丁酒吧那次枪战，可谓是一举成名啊杀的人可以排满整个瓦伦丁的铁路，抢的马可以堆满我们营地的那片草原了瓦伦丁的邮局甚至都不敢贴我们俩的悬赏名单，觊觎我们项上人头的赏金猎人可以从黑水镇排到安妮斯堡，可就是没人敢过来惹咱俩，毕竟你的死亡之眼可不是徒有虚名的，甚至于到了罗兹，咱们还特意跑回去瓦伦丁的银行，和比尔、凯伦、蓝尼他们狠狠地抢了一波，想起来那倒是痛快，毕竟谁能想到这居然是这段时间乃至以后最成功的一次抢银行，后来被赶到了罗兹，却被那该死的格雷家族和布雷斯维特家族利用，我们是谁？单凭神枪手—亚瑟摩根，你的项上人头就值 5000 美金，更何况还有我在，结果那自然是罗兹镇的格雷家族横尸遍野以及那让他们引以为傲的布雷斯维特庄园被烧成灰烬，</p>
<a id="more"></a>

<p>&emsp;&emsp;但是逃亡的日子也总是不好过，尤其是西恩死后和小杰克被抢走后，那日子愈发的紧张了不过我们起码到了个不错的居所，你曾经的居所，一个可以遮风挡雨的地方，从黑水镇以后达奇确实是变了，大家也都变得紧张起来当小杰克回来时，他那句：这是我经历过最快乐的时光了，着实刺疼你和约翰看得出约翰和你都露出难堪的脸色，一群亡命之徒带着一个孩子，算什么亡命之徒，对吧你们想要着最为平静的生活，而达奇却依旧在幻想他的美好世界，直到被削了的脑袋的基兰被送回营地时，我们才意识到我们结下的梁子和麻烦有多少</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4WvT.jpg" width=100%/>

<p>&emsp;&emsp;可那达奇被那该死的勃朗特洗了脑，被忽悠着抢了座分文不值的驿站，而后我们又在抢银行时被那平克顿侦探截了胡，何西亚和蓝尼就这样永久离开了我们。再然后你就和我们这群人就这样走散了而等到你们回来时，你的脸色就不太好了。而自打你从医生那回来，你就告诉我，你最近时常能梦到一匹鹿，在静谧的森林里的一头鹿</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4gCq.jpg" width=100%/>

<p>&emsp;&emsp;我知道的，我早该知道，是肺结核，那该死的唐斯一家，那该死的放债人，尤其是那该死的西部幻想家，这他妈都做了多少事，总是不切实际地让我们干着干那，你这身体无论如何都会吃不消的。我说再去西部狂野一把，去狩猎，去抢银行，可是你却说算了算了，帮派还有那么多不安稳的人接着帮达奇干起了的肮脏的勾当，你还是相信着他的美梦，只是没那么蠢了后来你终于醒了看来是被那该死的唐斯太太给劝醒了也不知道该不该谢谢这位唐斯太太最后的那段时间，你简直换了个人，但又还是那个亚瑟以往对达奇言听计从的亚瑟背着他救出了约翰、飞鹰，以往视金钱如命的亚瑟居然散尽家财帮助其他人</p>
<p>&emsp;&emsp;后来你还告诉我，你认识了一名老兵，一名和你很像的老兵，看清了生死；那印第安人的首领——落雨，是为数不多想帮你减轻痛苦的人，是他告诉了你人生的意义，他才是那位真正有远识的人在去和达奇见最后一面时，你告诉我，你因没有救下飞鹰而后悔，你甚至后悔没有告诉玛丽你的事情，你没有安排好所有人，只能把他们的命运托给沙迪夫人和我，</p>
<p>&emsp;&emsp;我想你是想好好和他们道个别的，但总是少那么个机会毕竟西部的世界总是那么狂野，狂野到没有坐下来好好休息、聊天的时间听你说你喜欢能看见太阳的地方，查尔斯还特意选了个好位置给你呢，这下你可有时间坐下来好好休息了可这西部啊，少了你，就少了点味道少了那味道，我都不知道该干些什么了你知道吗，在你离开之后，帮派也散了。皮尔逊那家伙去当了个商店老板，这个脑袋少根筋的家伙居然还把我们的合照挂在了墙头，也不怕其他人闻起来，不知道这个自恋的家伙追到他喜欢的姑娘没？莎迪夫人还是老样子，雷厉风行，她说：像她这种人，在屋子被烧掉后，就注定没有归宿。于是一个人在狂野的西部当起了赏金猎人，虽然她的枪法很烂而且整个人还是鲁莽，但我还是希望她能活久一点，毕竟她骑马去打听迈卡消息的时候，我居然看到了一丝你的身影</p>
<p>&emsp;&emsp;还记得那个被你赶走的放债人吗，那家伙最后一笔债放给一个叫做亚瑟的人。一路上听见的都是“亚瑟死了”，真他妈的难听。就是这样一个斯文败类又弱不禁风的德国人最后还是被平克顿侦探抓住了。只是没想到，这家伙即使是被折磨致死都不肯说出我们的下落，果然人就不能看那该死的行为，你看那杀千刀迈卡不就是一个 25 仔？噢，</p>
<p>&emsp;&emsp;对了，怎么能忘了约翰·马斯顿这家伙？这家伙，正如你所说的：be a god damn man，这个开头被狼啃坏脑子的人居然真得开始了农场主的生活。虽然还是那幅牛仔样，还是那个一言不合就拔枪的人。说起来你还真狡猾，居然把全部东西给了马斯顿，你的帽子，枪，照片，日记甚至是戒指。不过也好，倘若是留给我那就是压箱底的宝物了，我可不像那马斯顿，拿起你的日记继续写着他的生活，甚至还拿起你的戒指在黑水镇的胡中心向阿比盖尔求起了婚，天晓得这对老夫老妻有多幸福。如果那天你逃出来了，是不是会拿着这枚戒指跑去找玛丽。不过，你应该不敢，在爱人这方面，你可比马斯顿逊色多了</p>
<img data-src="https://s1.ax1x.com/2020/09/18/wh4R2V.jpg" width=100%/>

<p>&emsp;&emsp;对了，说起马斯顿，这家伙居然不听阿比盖尔的劝和莎迪去找迈卡报仇了，带着你的帽子和你的枪。不得不说，这家伙功夫还是不到家啊，你喝醉酒的枪法都比清醒时的他强，甚至在最后差点被迈卡所杀，好在达奇那老糊涂总算是清醒了一次大家都过得很好，该成家立业都成家立业，即使是大叔和查尔斯在外流浪的人也都留在了马斯顿的身边经营着那新建的农场。如果你肯定会喜欢这种生活，毕竟你和马斯顿曾经在瓦伦丁一起赶过羊呢！玛丽，她说着和你永远不相见，却还是偷偷跑去你的墓旁哭泣，她大概是再也不会遇到一个那么傻的神枪手了，</p>
<p>&emsp;&emsp;我至今还是无法回忆起你“血仇，血债，血偿”那条路，那条路上的你总是想起最后那段时间他们所说的话，但总得还是那句——“做你能做的”。那句对达奇说的：i gave you all i had，是我见过最无奈的话了我可太不同意查尔斯那句话了：“知道自己的死期比很多人幸运。”但我又太同意这句话了，西恩，何西亚，蓝尼甚至连话都没说就被这狂野的西部杀了，措手不及。于是在最后的时刻你尽力自己所能救了他们，也救了自己。至少在最后，你会说：in the end，i did it 最后我还是选择留在了之前有你的瓦伦丁镇，毕竟只有那时候，大家还是有退路，而你还是那个意气风发的神枪手</p>
]]></content>
      <categories>
        <category>游戏日记</category>
      </categories>
      <tags>
        <tag>荒野大镖客</tag>
        <tag>亚瑟-摩根</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 中的高级类型</title>
    <url>/2020/09/13/ts%E9%AB%98%E7%BA%A7%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型，这让我们可以把现有的多种类型叠加到一起作为一种类型，它包含了所需的所有类型的特性，例如<code>Person &amp; Serializable &amp; Loggable </code>同时是 <code>Person</code> 和 <code>Serializable</code> 和 <code>Loggable</code>。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>
<p>我们大多是在混入或其他不适合经典面向对象的地方看到交叉类型的使用，（在<code>JavaScript</code>中发生这种情况的场合会很多）下面是如何创建混入的一个简单的例子:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">    (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Loggable &#123;</span><br><span class="line">  log(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</span><br><span class="line">  log() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">&quot;Jim&quot;</span>), <span class="keyword">new</span> ConsoleLogger());</span><br><span class="line"><span class="keyword">var</span> n = jim.name;</span><br><span class="line">jim.log();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型与交叉类型很有关联，但是使用上却完全不同，偶尔你会遇到这种情况，一个代码库希望传入<code>number</code>或<code>string</code>类型作为参数，例如下面的函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Takes a string and adds &quot;padding&quot; to the left.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a string, then &#x27;padding&#x27; is appended to the left side.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a number, then that number of spaces is added to the left side.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">padLeft(<span class="string">&quot;Hello world&quot;</span>, <span class="number">4</span>); <span class="comment">// returns &quot;    Hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在 <code> padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定为了 <code>any</code> ，这就是说我们可以传入一个既不是<code>number</code> 也不是 <code>string</code> 类型的参数，但是<code>typescript</code>却不报错，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">&quot;Hello world&quot;</span>, <span class="literal">true</span>); <span class="comment">// 编译阶段通过，运行时报错</span></span><br></pre></td></tr></table></figure>

<p>在传统的面向对象语言里，我们可能会将这两种抽象成底层的类型，这么做显然是非常清晰的，但同时也存在了过度设计，<code>padleft</code> 原始版本的好处之一就是允许我们呢出传入原始类型，这样做的话用起来简单又方便，如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。</p>
<p>代替<code>any</code>，我们可以使用联合类型作为 <code>padding</code> 的参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Takes a string and adds &quot;padding&quot; to the left.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a string, then &#x27;padding&#x27; is appended to the left side.</span></span><br><span class="line"><span class="comment"> * If &#x27;padding&#x27; is a number, then that number of spaces is added to the left side.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">&quot;Hello world&quot;</span>, <span class="literal">true</span>); <span class="comment">// errors during compilation</span></span><br></pre></td></tr></table></figure>

<p>联合类型表示一个值可以是几种类型之一，我们用竖线（<code>|</code>）分割每个类型，所以<code>number|string|boolean</code>，表示值可以是<code>number</code> <code>string</code> 或 <code>boolean</code></p>
<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  fly();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  swim();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line">pet.layEggs(); <span class="comment">// okay</span></span><br><span class="line">pet.swim(); <span class="comment">// errors</span></span><br></pre></td></tr></table></figure>

<p>这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是 <code>A | B</code>，我们能够 确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。 这个例子里， <code>Bird</code>具有一个 <code>fly</code>成员。 我们不能确定一个 <code>Bird | Fish</code>类型的变量是否有 <code>fly</code>方法。 如果变量在运行时是 <code>Fish</code> 类型，那么调用 <code>pet.fly()</code> 就出错了。</p>
<h3 id="类型保护与区分类型"><a href="#类型保护与区分类型" class="headerlink" title="类型保护与区分类型"></a>类型保护与区分类型</h3><p>联合类型适合于那些值可以作为不同类型的情况，但当我们想确切的了解是否为 <code>Fish</code> 时怎么办？ <code>JavaScript</code> 里常用来区分两个可能的值的方法是检查成员是否存在，如之前提及的，我们只能访问联合类型中共同拥有的成员</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个成员访问都会报错</span></span><br><span class="line"><span class="keyword">if</span> (pet.swim) &#123;</span><br><span class="line">  pet.swim();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet.fly) &#123;</span><br><span class="line">  pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让这段代码工作，我们需要使用类型断言</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((&lt;Fish&gt;pet).swim) &#123;</span><br><span class="line">  (&lt;Fish&gt;pet).swim();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  (&lt;Bird&gt;pet).fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用户自定义的类型保护</strong></p>
<p>这里可以注意到，我们不得不多次使用类型断言，假如我们一旦检查过类型，就能在之后的每个分支里清楚的知道 <code>pet</code> 的类型的话就好了</p>
<p>这样 <code>TypeScript</code> 里的 类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 _类型谓词_：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里， <code>pet is Fish</code>就是类型谓词。 谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p>
<p>每当使用一些变量调用 <code>isFish</code> 时，<code>TypeScript</code> 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#x27;swim&#x27; 和 &#x27;fly&#x27; 调用都没有问题了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</span><br><span class="line">  pet.swim();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>typescript</code>不仅知道在<code>if</code>分支里 <code>pet</code> 是 <code>Fish</code> 类型的，它还清楚在 <code>else</code> 分支里，一定不是 <code>Fish</code> 类型的，一定是 <code>Bird</code> 类型的</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/09/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<p>单例模式是一种常用的模式，有一些对象我们往往只需要一个比如，线程池，全局缓存，浏览器中的 window 对象等，在 JavaScript 开发中，单例模式的用途同样非常广泛，试想一下，当我们点击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗只会被创建一次，那么这个登录浮窗就是和使用单例模式来创建</p>
<h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><p>要实现一个单例模式其实并不复杂，无非是用一个变量来标指当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Stingleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Stingleton.prototype.instance = <span class="literal">null</span>;</span><br><span class="line">Stingleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">Stingleton.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.instance)&#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = <span class="keyword">new</span> Stingleton(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = Stingleton.getInstance(<span class="string">&quot;sven1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = Stingleton.getInstance(<span class="string">&quot;sven2&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a === b)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span>  instance = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">           instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>我们通过<code>Singleton.getInstance</code>来获取 <code>Singleton</code> 类的唯一对象，这种方式相对简单，但有一个问题，就是为了增加这个类的‘不透明性’，<code>Singleton</code>类的使用者必须知道这是一个单例类，根以往通过<code>new XXX</code>的方式来获取对象不同，这里偏要使用 <code>Singleton.getInstance </code>来获取对象。</p>
<p>接下来顺便进行一些小测试，来证明这个单例类是可以信赖的；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = Singleton.getInstance(<span class="string">&#x27;sven1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> b = Singleton.getInstance(<span class="string">&#x27;sven2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b)</span><br></pre></td></tr></table></figure>

<p>虽然现在已经完成了一个单例模式的编写，但这段单例模式代码的意义并不大，从下一节开始，我们将一步步编写出更好的单例模式</p>
<h3 id="透明的单例模式"><a href="#透明的单例模式" class="headerlink" title="透明的单例模式"></a>透明的单例模式</h3><p>我们现在的目标是实现一个透明的单例类，用户从这个类中创建对象的时候，可以像使用其他任何普通类一样，在下面的例子中，我们将使用<code>CreateDiv</code>单例类，它的作用是负责在页面中创建唯一的<code>div</code>节点，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 判单之前是否创建过/ 如果有则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (instances) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.html = html;</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">        instance = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(instance)</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;;</span><br><span class="line">    CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">        div.innerHTML = <span class="built_in">this</span>.html;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> CreateDiv;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> CreateDiv(<span class="string">&quot;sven1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> CreateDiv(<span class="string">&quot;sven2&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a === b)</span><br></pre></td></tr></table></figure>

<p>虽然现在已经完成了一个透明单例类的编写，但它同样有一些缺点。为了把<code>instance</code>封装起来，这增加了一些程序的复杂性，阅读起来不是很舒服</p>
<p>观察现在的<code>Singleton</code>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判单之前是否创建过/ 如果有则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.html = html;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">    instance = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(instance)</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码中，<code>CreateDiv</code> 的构造函数实际上负责了两件事情，第一是创建对象和执行初始化 init 方法，第二是保障只有一个对象，虽然我们目前还没有接触过”单一职责”的概念，但可以明确的是，这是一种不好的做法，至少这个构造函数看起来很奇怪。假设我们某天需要利用这个类，在页面上创建千千万万的 div，即要让这个类从一个单例类变成一个普通的可以生产多个实例的类，那我们必须改写 CreateDiv 的构造函数，把控制创建 唯一对象的那一段去掉，这种修改会给我们带来不必要的麻烦</p>
<h3 id="使用代理实现单例模式"><a href="#使用代理实现单例模式" class="headerlink" title="使用代理实现单例模式"></a>使用代理实现单例模式</h3><p>现在我们通过引入代理类的方式，来解决上面提到的问题</p>
<p>我们依然使用上面的代码， 首先在<code>CreateDiv</code>的构造函数中把负责管理单例的代码移除出去，使他成为一个普通的创建 div 的类，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.html=html;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    div.innerHTML = <span class="built_in">this</span>.html;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来引入代理类 ProxySingletonCreateDiv;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ProxySingletonCreateDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;;</span><br><span class="line">    <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> CreateDiv(html);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ProxySingletonCreateDiv(<span class="string">&quot;sven1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ProxySingletonCreateDiv(<span class="string">&quot;sven2&quot;</span>);</span><br><span class="line">alert(a === b)</span><br></pre></td></tr></table></figure>

<p>通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们把负责管理单例的逻辑移到了代理类 ProxySingletonCreateDiv 中，这样一来，CreateDiv 就变成了一个普普通通的类，它跟 proxySingletonCreateDiv 组合起来就可以达到单例模式的效果</p>
<p>本例是缓存代理的应用之之一，在第六章中，我们继续了解代理带来的好处</p>
<h3 id="JavaScript-中的单例模式"><a href="#JavaScript-中的单例模式" class="headerlink" title="JavaScript 中的单例模式"></a>JavaScript 中的单例模式</h3><p>前面提到的几种单例模式的实现，更多的是接近传统面向对象语言中的实现，单例对象从“类”中创建而来，在以类为中心的语言中，这是很自然的做法，比如在 java 中，如果需要某个对象，那就必须先定义类，对象总是从类中创建而来</p>
<p>但 JavaScript 其实是一门无类（class-free）语言，也正因为如此，生搬代理模式的概念并无意义，在 JavaScript 中创建对象的方法非常简单，既然我们只需要一个“唯一”的对象，为什么要为它先创建一个“类”呢，这无异于穿棉衣洗澡，传统的单例模式实现在 JavaScript 中并不适用，</p>
<p>单例模式的核心是确保只有一个实例，并提供全局访问。</p>
<p>全局变量不是单例模式，但在 JavaScript 开发中，我们经常会把全局变量当成单例来使用例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>当用这种方式创建对象 a 的时候，对象 a 确实是独一无二的，如果 a 变量声明在全局作用域下，则我们可以在代码中的任何位置使用这个变量，JavaScript 中的变量也很容易被不小心覆盖，相信每个 JavaScript 程序员都曾经经历过变量冲突的痛苦，就像上面的对象 var a = {}; 随时有可能被被人覆盖</p>
<p>作为普通开发者，我们有必要尽量减少使用全局变量的使用，即使需要，也要把它的污染降低到最小，一下几种方式可以相对降低全局变量带来的命名污染</p>
<p>使用命名空间</p>
<p>适当的使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量最简单的方法依然是对象字面的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> namespace1 = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把<code>a</code>和<code>b</code>都定义为 <code>namespace1</code> 的属性，这样就可以减少变量和全局作用域打交道的机会，另外我们还可以动态的创建命名空间， 代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> myApp = &#123;&#125;;</span><br><span class="line">myApp.namespace = funcqqtion (name) &#123;</span><br><span class="line">  <span class="keyword">let</span> parts = name.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> current = myApp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> parts) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!current[parts[i]]) &#123;</span><br><span class="line">      current[parts[i]] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current[parts[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myApp.namespace(<span class="string">&quot;event&quot;</span>);</span><br><span class="line">myApp.namespace(<span class="string">&quot;dom.style&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myApp);</span><br></pre></td></tr></table></figure>

<p>也可以使用 闭包封装私有变量这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _name = <span class="string">&#x27;sven&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> _age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _name + _age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>我们使用下划线来约定私有变量，<code>_name</code>和<code>_age</code> 它们被封装到闭包产生的作用域里，外部都是访问不到这两个变量的，这就避免了对全局的命令污染</p>
<h3 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h3><p>前面我们了解了单例模式的一些实现方法，本节我们来了惰性单例。惰性单例指的是在需要的时候才创建对象的实例，惰性单例是单例模式的重点，这种技术在实际开发中非常有用， 有用程度可能超出我们的想像，实际上在本章开头就使用过这种技术了，<code>instance</code>实例对象总是在我们调用<code>Singleton.getInstance</code>的时候才被创建，而不是在页面加载好的时候就创建，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(name)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>不过这是基于“类”的单例模式，前面说过，基于“类”的单例模式在 JavaScript 中并不适用，下面我们将以 webQQ 的登录浮窗为例，介绍与全局变量结合实现惰性的单例</p>
<p>假设我们设计 webqq 的开发人员，当点击导航上的 qq 头像的时候，会出现一个登录弹窗，很明显这个浮窗在页面中总是唯一的，不可能出现同时存在两个登录弹窗的情况</p>
<p>第一种解决方案是在页面加载完成的时候，便创建好这个 div 浮窗，这个浮窗一开始肯定是隐藏的，只有当用户点击登录的时候他才会出现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> loginLayer = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="javascript">      div.innerHTML = <span class="string">&quot;我是登录弹窗&quot;</span>;</span></span><br><span class="line"><span class="javascript">      div.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.appendchild(div);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div;</span></span><br><span class="line">    &#125;)();</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      loginLayer.style = <span class="string">&quot;block&quot;</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方式有一个问题，也许我们进入 qq 这是为了玩玩游戏或者看看天气，根本不需要进行登录操作，因为登录弹窗总是一开始就被创建好，那么可能白白浪费一些 dom 节点现在我们改写一下代码，使用户点击登录按钮的时候才开始创建该弹窗</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="javascript">      div.innerHTML = <span class="string">&quot;我是登录弹窗&quot;</span>;</span></span><br><span class="line"><span class="javascript">      div.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.appendchild(div);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> div;</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> loginLayer = createLoginLayer();</span></span><br><span class="line"><span class="javascript">      loginLayer.style = <span class="string">&quot;block&quot;</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在我们达到了惰性的目的，但是也失去了单例的效果，当我们每次点击登录按钮的时候，都会创建一个新的登录浮窗 div 虽然我们可以点击浮窗上的关闭按钮，把这个节点从页面中删除掉，但这样频繁的创建和删除节点明显是不合理的也是不必要的</p>
<p>也许你已经想到了，我们可以用一个变量来判断是否已经创建过登录浮窗，这也是本节第一段代码中的做法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createLoginLayer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!div)&#123;</span><br><span class="line">            div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">            div.innerHTML = <span class="string">&#x27;我是登录弹窗&#x27;</span></span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> div</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loginLayer = createLoginLayer()</span><br><span class="line">    loginLayer.style = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通用单例模式"><a href="#通用单例模式" class="headerlink" title="通用单例模式"></a>通用单例模式</h3><p>上一节我们完成了一个可用的惰性单例，但是我们发现它还有如下一些问题，</p>
<ul>
<li>这段代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在 createLoginLayer 对象内部</li>
<li>如果我们下此需要创建页面中唯一的 iframe，或者 script 标签，用来跨域请求数据，就必须如法炮制，把 createLoginLayer 函数几乎照抄一遍</li>
</ul>
<p>我们现在需要把不变的部分隔离出来，先不考虑创建一个 div 和创建一个 iframe 有多少差异，管理单例的逻辑其实是可以完全抽离出来的，这个逻辑始终是一样的，用一个变量来标志是否创建过对象，如果是，则在下次直接返回这个已经创建好的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj;</span><br><span class="line"><span class="keyword">if</span>(!obj)&#123;</span><br><span class="line">    obj = xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们把管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在 getSingle 函数内部，创建对象的方法当成参数动态传入到 getSingle 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来将用于创建登录浮窗的方法用参数形式传入到 getSingle 函数中，我们不仅可以传入 createLoginLayer 还可以传入其他 createScript createIframe createXhr 等，之后再让 getSingle 返回一个新的函数，并且用变量 result 来保存 fn 的计算结果，result 变量因为身在闭包中，它永远不会被销毁，在将来的请求中，如果 result 已经被赋值了，那么它将返回这个值，代码如下，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    div.innerHTML = <span class="string">&quot;我是登录弹窗&quot;</span>;</span><br><span class="line">    div.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.appendchild(div)</span><br><span class="line">    <span class="keyword">return</span> div</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> createSingleLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loginLayer = createSingleLoginLayer()</span><br><span class="line">    loginLayer.style = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们再试试创建唯一 iframe 用于动态加载三方页面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createIframe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">    <span class="built_in">document</span>.appendchild(iframe)</span><br><span class="line">    <span class="keyword">return</span> iframe</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;login&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loginLayer = createIframe();</span><br><span class="line">    loginLayer.src = <span class="string">&#x27;http://www.baidu.com&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们把创建实例对象的职责和管理单例的职责分别放置在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能，看起来是一件挺奇妙的事情这种单例模式的用途远不止创建对象，比如我们通常渲染完页面中的一个列表之后，接下来要给这个列表绑定 click 事件，如果是通过 ajax 动态往列表里加数据，在使用事件代理的前提下 click 事件实际上只需要在第一次列表渲染的时候被便规定一次，但是我们不想去判断当前是否第一次渲染，如果借助于 jquery 我们通常选择给节点绑定 one 事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;div&quot;</span>).one(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;click&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染列表&quot;</span>)</span><br><span class="line">    bindEvent()</span><br><span class="line">&#125;</span><br><span class="line">render()</span><br><span class="line">render()</span><br><span class="line">render()</span><br></pre></td></tr></table></figure>

<p>那如果使用 getSingle 函数呢，如何达到一样的效果，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bindEvent = getSingle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染列表&quot;</span>)</span><br><span class="line">    bindEvent()</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br><span class="line">render();</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>单例模式是我们学习的第一个模式，我们先学习了传统的单例模式实现，也了解到因为语言的差异性，有更适合的方法在 JavaScript 中创建单例，第一章还提到了代理模式和单一职责原则，后面我们会对他们进行更加详细的介绍</p>
<p>在 getSingle 函数中，实际上也提到了闭包和高阶函数的概念，单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个，更奇妙的是，创建对象和管理单例的职责被划分到两个不同的方法中，这两个方法组合起来才具有单例模式的威力</p>
]]></content>
      <categories>
        <category>JavaScript设计模式与开发实践</category>
      </categories>
  </entry>
</search>
